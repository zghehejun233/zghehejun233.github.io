<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++入门学习笔记</title>
    <url>/blog/posts/5078/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="关于二进制">关于二进制</h2>
<h3 id="存储和转换">存储和转换</h3>
<h4 id="十进制整数">十进制整数</h4>
<ul>
<li>逐个与2相除，得到的余数依次组成一串数字，最后进行反转即可得到对应的二进制数</li>
</ul>
<h4 id="十进制小数">十进制小数</h4>
<ul>
<li>逐次与2相乘，得到的个位数组成一串数字，并且每次个位不为零时都抹去个位数进入下次操作</li>
</ul>
<h3 id="原码反码和补码">原码、反码和补码</h3>
<ol type="1">
<li>原码即数字的原形式</li>
<li>将原码逐位取反，即得到对应的反码</li>
<li>反码+1得到的就是补码</li>
</ol>
<blockquote>
<p>求得反码时，<span class="math inline">\(0\)</span>会出现<span class="math inline">\(+0\)</span>和<span class="math inline">\(-0\)</span>两种表达，因此引入了补码</p>
</blockquote>
<h2 id="c的编码风格">C的编码风格</h2>
<h3 id="匈牙利命名法">匈牙利命名法</h3>
<ul>
<li><p>以一个或多个小写字母开头，指定数据类型</p></li>
<li><p>后跟一个或多个首字母大写的单词，描绘变量的功能</p>
<blockquote>
<p>可以视作对驼峰命名法的强化数据类型的命名方法</p>
</blockquote></li>
</ul>
<h3 id="google标准">Google标准</h3>
<blockquote>
<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/" class="uri">https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/</a></p>
</blockquote>
<h3 id="定义和声明">定义和声明</h3>
<ul>
<li>定义性声明称为定义</li>
<li>非定义性声明称为声明</li>
</ul>
<h2 id="结构化程序设计">结构化程序设计</h2>
<ul>
<li>单入口和单出口</li>
<li>原来，面向过程就是结构化程序设计</li>
</ul>
<h2 id="c的简单示例">C++的简单示例</h2>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

int main()
&#123;
cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl
return 0;
&#125;</code></pre></div>
<ul>
<li><code>#include&lt;name&gt;</code>与<code>import</code>的作用类似，可以近似理解为对文件的引用或调用</li>
<li>C++一般使用流来进行输入输出，比如<code>cout &lt;&lt; "Hello World" &lt;&lt; endl</code>，而C一般会使用printf和scanf来实现基本输入输出</li>
</ul>
<h2 id="c一家人">C一家人</h2>
<h3 id="c">C++</h3>
<p>C++在C的基础上，添加类代表的面向对象语言；C++模板添加了泛型编程</p>
<p>早期的C++编译器将C++代码转译为C代码，再由C编译器编译。这个编译器也就是下面要提到的前端（CFront）</p>
<h1 id="编译与环境配置">编译与环境配置</h1>
<h2 id="简述">简述</h2>
<h3 id="gnugccclang和cmake都是些啥">GNU、GCC、CLang和CMake都是些啥</h3>
<blockquote>
<p>参考资料</p>
<p><a href="https://developer.51cto.com/article/630677.html" class="uri">https://developer.51cto.com/article/630677.html</a></p>
</blockquote>
<h4 id="编译器的一般构成">编译器的一般构成</h4>
<p>传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)</p>
<p>在编译过程中，<strong>前端主要负责词法和语法分析</strong>，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。</p>
<h4 id="gccgnu-compiler-collection">GCC（GNU Compiler Collection）</h4>
<p>GCC是一套GNU开发的<strong>编译器</strong></p>
<p>GCC 作为一款开源的编译器，一直做得不错，但 Apple 逼事儿比较多，对编译工具会提出更高的要求。原因主要有以下两点</p>
<ul>
<li>GCC对Objective-C的支持慢。Apple 对 Objective-C 语言（包括后来对C语言）新增很多特性，但 GCC 开发者并不买Apple的账——不给实现，因此索性后来两者分成两条分支分别开发，这也造成 Apple 的编译器版本远落后于 GCC 的官方版本</li>
<li>GCC代码质量差。GCC 的代码<strong>耦合度太高</strong>，很难独立，而且越是后期的版本，代码质量越差，但 Apple 想做的很多功能（比如更好的 IDE 支持），需要模块化的方式来调用 GCC，但 GCC一直不给做。</li>
</ul>
<h4 id="llvm-low-level-virtual-machine底层虚拟机">LLVM (Low Level Virtual Machine，底层虚拟机)</h4>
<p>LLVM提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种编译器的<strong>后台</strong>来使用</p>
<h4 id="clangllvm2.0">Clang—LLVM2.0</h4>
<p>Clang的诞生和Apple息息相关，准确的说，和巨佬Chiris Lattner相关。</p>
<blockquote>
<p>2000年，本科毕业的 Chris Lattner 像中国多数大学生一样，按部就班地考了GRE，最终前往UIUC（伊利诺伊大学厄巴纳香槟分校），开始了艰苦读计算机硕士和博士的生涯。</p>
<p>在这阶段，他不仅周游美国各大景点，更是翻烂了《Compilers: Principles, Techniques, and Tools》，成了GPA满分(4.0) 牛人，并不断地研究探索关于编译器的未知领域，发表了一篇又一篇的论文。</p>
</blockquote>
<p>他在求学阶段一个值得讨论的故事，是在<strong>硕士毕业论文</strong>里提出了一套完整的在编译时、链接时、运行时甚至是在闲置时优化程序的编译思想，直<strong>接奠定了LLVM 的基础</strong>。</p>
<p>LLVM 在他念博士时更加成熟，使用GCC 作为前端来对用户程序进行语义分析产生IF（Intermidiate Format），然后 LLVM 使用分析结果完成代码优化和生成。</p>
<p>后来，Chirs Lattner被Apple吸收，在Apple，他干了这些事情</p>
<ul>
<li><p>优化OpenGL</p>
<blockquote>
<p>Chris Lattner把 LLVM运行时的编译架在 OpenGL 栈上，这样OpenGL 栈能够产出更高效率的图形代码。</p>
<p>如果显卡足够高级，这些代码会直接扔入GPU 执行。但对于一些不支持全部OpenGL特性的显卡（比如当时的Intel GMA卡），LLVM 则能够把这些指令优化成高效的 CPU指令，使程序依然能够正常运行</p>
</blockquote></li>
<li><p>Apple1代码链接优化</p>
<blockquote>
<p>LLVM的链接优化被直接加入到 Apple 的代码链接器上，而 LLVM-GCC也被同步到使用 GCC4.0 代码。</p>
</blockquote></li>
<li><p>开发Clang</p></li>
</ul>
<p>Clang也就是文章这一部分的重头戏，它是LLVM的前端。相比GCC，只支持C/C++/Objective-C三种语言。</p>
<p>与GCC相比，Clang有如下主要的特点</p>
<ul>
<li><p>高性能：Clang在编译速度、空间占用上都优于GCC</p>
<blockquote>
<p>速度快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 比 GCC 快2倍多。</p>
<p>内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10 倍。</p>
</blockquote></li>
<li><p>高可用性：Clang有更好的错误提示信息，还支持GCC不具有的静态分析</p>
<blockquote>
<p>Clang显示的错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有~~~~~和^的提示，相比之下 GCC 的提示很天书。</p>
</blockquote></li>
<li><p>高兼容性：可以说GCC最初就被设计为一个单独的应用程序，而Clang1有更好的可移植性。Clang与GCC相比更像是一个插件，任何IDE都可以考虑将他设计进去</p>
<blockquote>
<p>Clang 从一开始就被设计为一个API，允许它被源代码分析工具和 IDE 集成。GCC 被构建成一个单一的静态编译器，这使得它非常难以被作为 API 并集成到其他工具中。</p>
</blockquote></li>
<li><p>平台的局限：Clang的诞生和Apple高度绑定，而且GCC还支持Fortran等语言</p></li>
</ul>
<p>与此同时，二者的许可证也有区别。Clang使用BSD许可证，GCC则使用GPL许可证</p>
<figure>
<img src="https://s3.51cto.com/oss/202011/03/8a147a8adcb105088554299a2afecb87.jpg" alt="详解三大编译器：gcc、llvm 和 clang" /><figcaption aria-hidden="true">详解三大编译器：gcc、llvm 和 clang</figcaption>
</figure>
<h4 id="总结">总结</h4>
<p>对新的项目而言，LLVM-GCC 看起來应该是个安全的选择，苹果公司认为它够稳定够成熟，所以才把它当做Xcode 4的预设选项。而且，既然选项使用的是GCC parser，向后兼容性应该没问题。</p>
<p>回顾GCC的历史，虽然它取得了巨大的成功，但<strong>开发GCC的初衷是提供一款免费的开源编译器</strong>，仅此而已。可后来随着GCC支持了越来越多的语言，GCC架构的问题也逐渐暴露出来。</p>
<p><strong>但GCC到底有什么问题呢？</strong></p>
<p>LLVM的优点也正是GCC的缺点。</p>
<p>传统编译器工作的时候过程一般如下</p>
<ol type="1">
<li><p>前端负责<strong>解析源代码，检查语法错误，并将其翻译为抽象的语法树（Abstract Syntax Tree）</strong>。</p></li>
<li><p>优化器对这一中间代码进行<strong>优化，试图使代码更高效</strong>。</p></li>
<li><p>后端则负责将优化器优化后的<strong>中间代码转换为目标机器的代码</strong>，这一过程后端会最大化的利用目标机器的特殊指令，以提高代码的性能。</p>
<blockquote>
<p>事实上，不光静态语言如此，动态语言也符合上面这个模型，例如Java。JVM也利用上面这个模型，将Java代码翻译为Java bytecode。</p>
</blockquote></li>
</ol>
<p>这一模型的好处有</p>
<ul>
<li><p><strong>当我们要支持多种语言时，只需要添加多个前端就可以了</strong>。当需要支持多种目标机器时，只需要添加<strong>多个后端就可以</strong>了。对于中间的优化器，我们可以使用通用的中间代码。</p></li>
<li><p><strong>开发前端的人只需要知道如何将源代码转换为优化器能够理解的中间代码</strong>就可以了，他不需要知道优化器的工作原理，也不需要了解目标机器的知识。这大大降低了编译器的开发难度，使更多的开发人员可以参与进来。</p></li>
</ul>
<p><strong>虽然这种三段式的编译器有很多优点，并且被写到了教科书上，但是在实际中这一结构却从来没有被完美实现过。</strong></p>
<p>做的比较好的应该属Java和.NET虚拟机。虚拟机可以将目标语言翻译为bytecode，所以理论上讲我们可以将任何语言翻译为bytecode，然后输入虚拟机中运行。但是这一动态语言的模型并不太适合C语言，所以硬将C语言翻译为bytecode并实现垃圾回收机制的效率是非常低的。GCC也将三段式做的比较好，并且实现了很多前端，支持了很多语言。但是上述这些编译器的致命缺陷是，<strong>他们是一个完整的可执行文件，没有给其它语言的开发者提供代码重用的接口</strong>。即使GCC是开源的，但是源代码重用的难度也比较大。</p>
<p>LLVM最初的定位是比较底层的虚拟机。它的出现正是为了解决<strong>编译器代码重用的问题</strong>，LLVM一上来就站在比较高的角度，制定了LLVM IR这一中间代码表示语言。LLVM IR充分考虑了各种应用场景，例如在IDE中调用LLVM进行实时的代码语法检查，对静态语言、动态语言的编译、优化等。从上面这个图中我们发现LLVM与GCC在三段式架构上并没有本质区别。</p>
<p>LLVM与其它编译器最大的差别是，<strong>它不仅仅是Compiler Collection，也是Libraries Collection</strong>。</p>
<blockquote>
<p>举个例子，假如说我要写一个X语言的优化器，我自己实现了PassX算法，用以处理X语言与其它语言差别最大的地方。而LLVM优化器提供的PassA和PassB算法则提供了X语言与其它语言共性的优化算法。那么我可以选择X优化器在链接的时候把LLVM提供的算法链接进来。</p>
</blockquote>
<p>LLVM不仅仅是编译器，<strong>也是一个SDK</strong>。</p>
<p>Apple LLVM compiler 4.2是一个真正的LLVM编译器，前端使用的是Clang，基于最新的LLVM 3.2编译的。LLVM GCC 4.2编译器的核心仍然是LLVM，但是前端使用的是GCC 4.2编译器。从LLVM的下载页面可以看出，LLVM从1.0到2.5使用的都是GCC作为前端，直到2.6开始才提供了Clang前端。</p>
<p>如果你下载 LLVM 的代码，那么它就是一个IR到ARM/机器码的编译器。比如bin/opt就是对IR的优化器，bin/llc就是IR-&gt;ASM的翻译，bin/llvm-mc就是汇编器。如果你再从<a href="http://llvm.org" class="uri">http://llvm.org</a>下载Clang，那么就有了C-&gt;IR的翻译以及完整的编译器Driver。GDB是GNU的调试器。只要编译器支持DWARF格式，就可以用GDB调试。</p>
<h3 id="ide集成开发环境">IDE（集成开发环境）</h3>
<h3 id="编辑器">编辑器</h3>
<h2 id="gnu-make">GNU Make</h2>
<blockquote>
<p>参考资料 <a href="https://seisman.github.io/how-to-write-makefile/overview.html" class="uri">https://seisman.github.io/how-to-write-makefile/overview.html</a></p>
</blockquote>
<h2 id="具体平台下的配置记录">具体平台下的配置记录</h2>
<h3 id="vscode-with-clang-on-macos">VSCode with Clang on macOS</h3>
<blockquote>
<p>参考资料</p>
<p><a href="https://code.visualstudio.com/docs/cpp/config-clang-mac" class="uri">https://code.visualstudio.com/docs/cpp/config-clang-mac</a></p>
</blockquote>
<h4 id="概述">概述</h4>
<h4 id="clang的安装与配置">Clang的安装与配置</h4>
<h4 id="vscode配置">VSCode配置</h4>
<h4 id="编译指令">编译指令</h4>
<h4 id="备注">备注</h4>
<h3 id="vscode-with-gcc-on-windows">VSCode with GCC on Windows</h3>
<h3 id="visual-studio">Visual Studio</h3>
<h1 id="语言的基本语法和特性">语言的基本语法和特性</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p>C为数据之间提供了基本的类型转换，但建议使用<code>&lt;type&gt;(var)</code>的形式（C++形式）</p>
<h3 id="字面常量">字面常量</h3>
<ul>
<li>十进制、八进制和十六进制的表示</li>
<li>整数类型字面常量默认为<code>int</code>类型，可以附加l/L、u/U表示类型</li>
<li>浮点类型默认为double类型，也可以附加f和l</li>
<li>特别的，有转义字符及其对应的八进制、十六进制</li>
<li>字符串常量直接使用双引号引起，一般会存储一个终止位<code>\0</code></li>
</ul>
<h3 id="符号常量">符号常量</h3>
<ul>
<li><p>使用以下形式声明</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define &lt;标识符&gt; &lt;值&gt;;
const &lt;类型&gt; &lt;标识符&gt; &#x3D; &lt;值&gt;</code></pre></div>
<blockquote>
<p>值得注意的是，这里的<code>#define</code>和<code>#include</code>一样使用#表示 我们称这些命令为<strong>宏定义命令</strong>，他们是一种<strong>预处理命令</strong> <code>const</code>声明在c++中引入，建议使用</p>
</blockquote></li>
<li><p>使用<code>#define</code>声明会在预编译阶段替换标识符出现的位置为其值再进行进一步编译运算，<code>const</code>声明直接参与编译和运算</p></li>
</ul>
<h3 id="全局变量">全局变量</h3>
<ul>
<li>与Python、Dart不同，C中一般不会使用下划线开头的命名方式</li>
<li>变量的基本特性有变量名、类型、值和内存空间地址</li>
<li>全局变量会<strong>自动赋初值</strong></li>
</ul>
<blockquote>
<p>全局变量可以定义在函数外的任何地方，如果在使用一个全局变量时未见到它的定义，则在使用前需要对该全局变量进行声明</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern &lt;类型名&gt; &lt;变量名&gt;;</code></pre></div>
<h3 id="整型">整型</h3>
<ul>
<li><p>最基本的整型为int</p></li>
<li><p>除int外，可以使用<strong>long和short</strong>进一步修饰。当使用修饰符时，也可以省略int关键字</p></li>
<li><p>除此之外，还有<strong>long long int</strong>类型</p></li>
<li><p>所有的数字类型都可以<strong>附加signed和unsigned来声明是否有符号</strong></p></li>
<li><p>常见的实现大小</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>大小</th>
<th>数字范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>short int</td>
<td>2</td>
<td></td>
</tr>
<tr class="even">
<td>int</td>
<td>2或4</td>
<td></td>
</tr>
<tr class="odd">
<td>long int</td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>long long int</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>计算机内，整型都是用<strong>二进制补码</strong>表示</p></li>
</ul>
<h3 id="浮点型">浮点型</h3>
<ul>
<li>float和double两种类型</li>
<li>double提供了<strong>long double</strong>类型进一步表示更大的数</li>
<li>float.h中定义了<code>FLT_EPSILON</code>和<code>DBL_EPSILON</code>两个值，约为<span class="math inline">\(1e-6\)</span>用来辅助判断浮点型之间是否近似相等</li>
</ul>
<h3 id="字符型">字符型</h3>
<ul>
<li><p>char类型</p></li>
<li><p>提供signed和unsigned</p>
<blockquote>
<p>其实所谓的unsigned，也就是相当于最早的七位ASCII码</p>
</blockquote></li>
<li><p>ASCII码使得大小写转换等操作比较方便，例如</p>
<ul>
<li>大小写：相差32，或者<code>int a = 'd' - 'a' + 'D'</code></li>
<li>提取字符数字：<code>int a = '9' - '0'</code></li>
</ul></li>
</ul>
<h3 id="逻辑数据类型">逻辑数据类型</h3>
<ul>
<li>1为true，0为false</li>
<li>bool同样使用了一个字节而不是位表示</li>
</ul>
<h3 id="空值数据类型">空值数据类型</h3>
<p>主要用于以下场景</p>
<ul>
<li>没有返回值的函数</li>
<li>通用指针<code>void *</code></li>
</ul>
<h3 id="整型和算术型">整型和算术型</h3>
<ul>
<li>int、char以及bool统称为<strong>整型</strong></li>
<li>整型和float统称为算术型</li>
</ul>
<h2 id="变量的存储类型">变量的存储类型</h2>
<h3 id="分类方法">分类方法</h3>
<ul>
<li>对于一个变量，我们会从两个角度考虑，一是这个变量的数据类型，具体体现就是在内存中开辟空间的大小；二是这个变量的生存周期，具体表现为在哪一块儿内存空间</li>
<li>保存变量当前值的存储单元有两类，一类是<strong>内存</strong>，另一类是 CPU 的寄存 器</li>
<li>C 语言中定义了 4 种存储属性，即<strong>自动变量、外部变量、静态变量和寄存器变量</strong></li>
</ul>
<h3 id="作用域">作用域</h3>
<ul>
<li><p>变量的<strong>作用范围又称为作用域</strong>,从空间角度,可以将变量分为<strong>全局变量和局部变量</strong></p></li>
<li><p>局部变量是在一 个函数或复合语句内定义的变量，它仅在函数或复合语句内有效。</p>
<p>编译时，编译系统不为局部变量分配内存单元，而是在程序运行过程中，当局部变量所在的函数被调用时，编译系统根据需要临时分配内存，调用结束，空间释放。</p></li>
<li><p>全局变量是在函数之外定义的变量，其作用范围为从定义处开始到本文件结束编译时，编译系统为其分配固定的内存单元，在程序运行的自始至终都占用固定单元。</p></li>
<li><p>默认情况下，使用<strong>作用范围最小的同名变量</strong>。</p>
<p>如果要使用外部的变量，可以使用<code>::x</code>的形式调用。</p>
<blockquote>
<p>不要饱了撑的重复定义同名变量</p>
</blockquote></li>
</ul>
<h3 id="生存期">生存期</h3>
<ul>
<li><p>变量的保留时间又称为生存期,从时间的角度,可将变量分为<strong>静态存储和动态存储</strong>两种情况</p></li>
<li><p>静态存储是指<strong>变量存储在内存的静态存储区</strong>，在编译时就分配了存储空间</p>
<p>在整个程序的运行期间，该变量占有固定的存储单元，程序结束后，这部分空间才释放，变量的值在整个程序中始终存在</p></li>
<li><p>动态存储是指变量存储在内存的动态存储区，在程序的运行过程中，只有当变量所在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值只在函数调用期存在</p></li>
</ul>
<h3 id="c中的内存分配">C中的内存分配</h3>
<figure>
<img src="https://pic3.zhimg.com/80/v2-deb39dc05a514a6e3bcf5751be932846_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>stack</li>
<li>heap</li>
<li>bss(Block Started by Symbol)：通常是指用来存放程序中未初始化的全局变量的一块内存区域，由static修饰，BSS段属于静态内存分配。</li>
<li>code/text segment：用来存放程序执行代码的一块内存区域。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等</li>
</ul>
<h3 id="存储类型">存储类型</h3>
<h4 id="自动变量">自动变量</h4>
<ul>
<li>auto通常作为缺省选项自动添加</li>
<li>自动型变量只能作为局部变量</li>
<li>对于出现嵌套的重名变量，以<strong>作用域最小的变量为准</strong></li>
</ul>
<h4 id="寄存器变量">寄存器变量</h4>
<ul>
<li>使用register关键字声明</li>
<li>通常用来声明<strong>少数调用最频繁的变量</strong>，将会被存储在<strong>CPU的通用寄存器中</strong></li>
<li>值得注意的是，不是都会被存储在寄存器中，需要寄存器有空余空间，存储数据短于寄存器位长</li>
</ul>
<h4 id="外部变量">外部变量</h4>
<ul>
<li>使用extern关键字声明</li>
<li>extern用于<strong>跨文件调用变量</strong>，将会存储在静态数据区</li>
<li>对于一个在其他文件中定义的变量，在另一个文件中访问时需要使用extern关键字，编译器将会在其他源文件中寻找变量的定义</li>
</ul>
<h4 id="静态变量">静态变量</h4>
<ul>
<li><p>使用static关键字声明</p></li>
<li><p>使用const定义也具有文件作用域</p>
<blockquote>
<p>建议使用在C++中引入的const</p>
<p>二者的区别详见</p>
<p><a href="https://www.runoob.com/w3cnote/cpp-static-const.html" class="uri">https://www.runoob.com/w3cnote/cpp-static-const.html</a></p>
</blockquote></li>
<li><p>static声明后的变量，<strong>不能通过extern引用</strong></p></li>
</ul>
<h2 id="基本输入输出">基本输入输出</h2>
<blockquote>
<p>记得引入stdio.h(cstdio)</p>
</blockquote>
<h3 id="格式化输出">格式化输出</h3>
<ul>
<li><p>与所有的格式化输出一样，printf函数接受两组变量，分别是输出格式和输出项系列，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;num &#x3D; %f \n&quot;,num);</code></pre></div></li>
<li><p>常用转换说明符</p>
<table>
<thead>
<tr class="header">
<th>说明符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%d</td>
<td>十进制整数（<strong>D</strong>ecimal）</td>
</tr>
<tr class="even">
<td>%x</td>
<td>十六进制整数（he<strong>X</strong>）</td>
</tr>
<tr class="odd">
<td>%f</td>
<td>浮点数（<strong>F</strong>loat）</td>
</tr>
<tr class="even">
<td>%c</td>
<td>字符（<strong>C</strong>har）</td>
</tr>
<tr class="odd">
<td>%s</td>
<td>字符串（<strong>S</strong>tring）</td>
</tr>
</tbody>
</table></li>
<li><p>说明符的更多控制方式（详见教材2.7.1）</p>
<ul>
<li><p>整数：</p>
<p>%md，其中m为指定的输出长度，若长度不足则用<strong>空格补足</strong>，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int n &#x3D; 234;
print(&quot;%6d&quot;,n);</code></pre></div>
<p>由于234不足666位，将会输出“000234”</p>
<p>%mld，输出长整型数据，同样可以指定长度</p></li>
<li><p>浮点数</p>
<p>留空，默认输出六位小数</p>
<p>%m.nf，输出m位整数，n位小数，长度不足用空格补足</p></li>
</ul></li>
<li><p>值得注意的是，格式化输出中的格式说明符与输出项系列是一一对应的，例如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf(&quot;%d %d %d&quot;,n1,n2,n3);</code></pre></div>
<p>就会依次输出n1,n2,n3的内容</p></li>
<li><p>使用转义字符要比<code>endl</code>效率更高</p></li>
</ul>
<h3 id="格式化输入">格式化输入</h3>
<ul>
<li><p>scanf函数与printf函数使用基本相同，需要记住的是输入项系列的每一项需要附加一个&amp;</p>
<blockquote>
<p>&amp;用来表示表示变量的地址</p>
</blockquote></li>
<li><p>输入分隔符的指定，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">scanf(&quot;%d,%d&quot;,&amp;n1,&amp;n2);
scanf(&quot;%d:%d&quot;,&amp;n1,&amp;n2);
scanf(&quot;%d;%d&quot;,&amp;n1,&amp;n2);</code></pre></div>
<p>他们的分隔符，分别为,、:和;</p></li>
<li><p>输入长度的指定</p>
<blockquote>
<p>一定程度上可以用来解析数据</p>
</blockquote>
<p>示例：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">scanf(&quot;%4d%2d%2d&quot;,&amp;a,&amp;b,&amp;c);</code></pre></div>
<p>会将输入值“19900125”拆分为1990、01和25</p></li>
</ul>
<blockquote>
<p>有些IDE会在结束执行任务之后关闭cmd窗口，这样会导致看不到运行的结果</p>
<p>可以添加一个<code>cin.get</code>语句，读取依次键盘输入即可解决（如果一个不行那就来两个）</p>
</blockquote>
<h3 id="字符输入与输出">字符输入与输出</h3>
<ul>
<li>getchar与putchar函数</li>
</ul>
<h1 id="预处理器">预处理器</h1>
<h1 id="数组类型">数组类型</h1>
<blockquote>
<p>数组之所以被叫做“复合数据类型”，是因为它有某个数据类型来创建的</p>
<p>在C中，他们被叫做“派生数据类型”，但C++引入了类的“派生”，因此使用术语了“复合”来描述这个关系</p>
<p>因此严格来讲，我们应该称呼一个数组为“xxx数组”</p>
</blockquote>
<h2 id="声明">声明</h2>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int nums[];
int nums[10]; &#x2F;&#x2F; 并不会进行初始化
int nums[] &#x3D; &#123;1,1,...&#125;;
int nums[10] &#x3D; &#123;1,1&#125;;  &#x2F;&#x2F; 未初始化的位置都会初始化为0</code></pre></div>
<p>C++11提供了一系列新的初始化方式</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int nums[] &#123;1,1,...&#125;; &#x2F;&#x2F;省略等号
int nums[10] &#123;&#125;; &#x2F;&#x2F;编译器将所有元素设置为0</code></pre></div>
<blockquote>
<p>C并不会对数组越界问题报错，如果我们访问了这个数组以外的位置，C会从最后一个元素所在的内存地址继续找下去。因此数组越界在这里只是找到了另一个地址，他确实能取到值，但不知道会是什么</p>
</blockquote>
<h2 id="数组的大小">数组的大小</h2>
<p>对数组使用<code>sizeof()</code>获得的是这个数组占用的内存空间，因此元素个数可以使用以下方式获得</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">type nums[] &#123;1,1,...&#125;;
int num_of_list &#x3D; sizeof(nums)&#x2F;sizeof(type);</code></pre></div>
<blockquote>
<p>需要注意<code>sizeof()</code>返回的是<code>sizez_t</code>数据类型，他的占位符是<code>%zd</code>或<code>%zu</code></p>
</blockquote>
<h2 id="参数传递">参数传递</h2>
<p>由于数组是内存中连续的一串空间，所以需要一个开头的内存地址即可，但是我们一般还会传入她的长度</p>
<p>因此C也将数组的变量名直接作为内存地址来处理，所以我们在将数组作为指针时就是采用了引用传递，比如说下面二者就是等价的</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 写法一
int sum(int arr[], int len);
&#x2F;&#x2F; 写法二
int sum(int* arr, int len);</code></pre></div>
<p>传递二维数组时，形参必须含有列数、不含行数，例如<code>int[][5]</code>；如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。举个例子</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum_array (int a[][4], int n);</code></pre></div>
<p>函数sum_array()的参数是一个二维数组。第一个参数是数组本身（a[][4]），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度4。</p>
<blockquote>
<p>这是因为函数内部拿到的，只是数组的起始地址a，以及第一维的成员数量2。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成int a[][4]，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是4 * sizeof(int)。</p>
</blockquote>
<p>传入变长数组时，需要注意先传入数组长度这个参数才能确定需要划分的内存大小</p>
<p>基于这种思想，我们可以得到一种新的传入高维数组的方式</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int sum_array(int n, int m, int a[n][m]);</code></pre></div>
<h2 id="数组指针">数组指针</h2>
<p>C对数组名和数组指针的处理，带来一些有意思的特性</p>
<p>首先是对数组成员的访问，有这样的关系恒成立</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">a[b] &#x3D;&#x3D; *(a + b)</code></pre></div>
<p>对于一个指针变量，我们都知道它是具有加法的，数组指针的加法其表现就是在数组元素之间移动，因此<code>p++</code>其实就是指针移向下一个元素，利用这个性质可以遍历数组，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[] &#x3D; &#123;11, 22, 33, 44, 55, 999&#125;;

int* p &#x3D; a;

while (*p !&#x3D; 999) &#123;
  printf(&quot;%d\n&quot;, *p);
  p++;
&#125;</code></pre></div>
<p>这份demo有两个需要关注的地方</p>
<ol type="1">
<li>数组名<code>a</code>相当于被<code>const</code>修饰，是不可以改变指向的。因此不能够使用<code>a++</code>这样的语句，而是使用<code>p</code>进行操作；显然，这是为了保护数组，避免数组称为垃圾</li>
<li>循环条件的判断一般使用数组元素，或者也可以接受<code>start</code>和<code>end</code>两个指针</li>
</ol>
<p>由于数组名是不可变的指针，所以其复制不能简单使用一个声明语句；非要说的话，<code>a=b</code>的含义也只是指向同一块内存地址而已，并不能算是复制，应该叫做“备份”。要复制一个数组，有两种方式</p>
<ol type="1">
<li>循环遍历，不建议使用，low</li>
<li><code>memcpy()</code>函数。顾名思义，可以拷贝内存数据，其调用形式为<code>memcpy(*ptr,*new_ptr,int length)</code>，速度要快得多</li>
</ol>
<blockquote>
<p>其实从这个复制操作，可以看出C具有底层操作性的特点，这里<code>memcpy()</code>所做的就是直接操作内存，其效率确实要比遍历复制快得多，但也相对危险 简化指针的操作，在C++中引入代替C的指针</p>
</blockquote>
<h1 id="字符串类型">字符串类型</h1>
<p>字符串处理的方便与否是衡量语言便利程度的标尺（暴论</p>
<h2 id="c风格字符串">C风格字符串</h2>
<p>C风格字符串是一个末位元素为<code>\0</code>的char数组</p>
<blockquote>
<p>严格来讲，C没有字符串类型</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char string[] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;&#125;; &#x2F;&#x2F; 这才是一个字符串
char not_string[] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;; &#x2F;&#x2F; 这个不是！</code></pre></div>
<p>当然，这样写多少有点离谱，C提供了一个语法糖，将双引号之间的内容自动处理成字符数组；对于跨行的字符串，为了便于缩紧，C还可以将两个间隔只包含空格的双引号的内容进行连接</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125; &#x3D; &quot;Hello&quot;*&#x2F;

char string[50] &#x3D; &quot;Hello&quot;
  &quot;world&quot;;</code></pre></div>
<h3 id="声明-1">声明</h3>
<p>C有两种基本的声明形式，字符数组和字符指针</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">char* s &#x3D; &quot;Hello, world&quot;;
char s[] &#x3D; &quot;Hello,world&quot;;</code></pre></div>
<h3 id="基本属性">基本属性</h3>
<p>C字符串对应的<code>cstring</code>头文件提供了<code>strlen()</code>函数，可以计算字符串的长度（而不是数组的长度）；同时，<code>strlen()</code>不会计算空字符</p>
<h3 id="读入数据">读入数据</h3>
<p><code>cin</code>对象默认是以‘单词’作为对象读取的，他根据空白符（空格、制表符等等）作为分割的依据，因此使用<code>cin &gt;&gt; string</code>不能读入一行字符串</p>
<p><code>cin</code>提供了<code>getline()</code>和<code>get()</code>函数来解决问题，他们都接受目标字符串和接受字符长度两个参数</p>
<p>二者的区别在于<code>getline()</code>会抛弃换行符，也就是说，使用<code>get()</code>函数的话，命令行中结束输入时的最后一个换行符，将被留在输入队列而不读入，如果在这个语句之后紧跟着一个<code>cin.get()</code>就可以吞掉没有读入的换行符</p>
<h3 id="复制和拼接">复制和拼接</h3>
<p><code>cstring</code>提供了<code>strcpy()</code>和<code>strcat()</code>实现复制粘贴 还有更安全的两个函数<code>strncpy()</code>和<code>strncat()</code>，他们接受第三个参数作为目标数组的最大长度</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h120dptlhrj20x20qsq62.jpg" alt="image-20220408082914099" /><figcaption aria-hidden="true">image-20220408082914099</figcaption>
</figure>
<h2 id="string类">string类</h2>
<p>C++98提供了string类库，将string作为一种对象处理，string因此可以被看做一个“数据类型”</p>
<p>与C字符串比起来，string类有这样的特点</p>
<ul>
<li><p>自适应长度</p></li>
<li><p>重载了<code>+、+=、=</code>等运算符</p></li>
<li><p>string作为一个对象，使用<code>.size()</code>方法获取长度</p></li>
<li><p>由于istream类在设计时没有考虑到string类型的读写，因此我们使用另一个<code>getline()</code>方法读取string</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str; &#x2F;&#x2F; 未被初始化的string长度将被置为0
getline(cin,str);</code></pre></div></li>
</ul>
<h1 id="c的函数">C的函数</h1>
<h2 id="定义与调用">定义与调用</h2>
<h3 id="函数的定义">函数的定义</h3>
<ul>
<li><p>函数是对过程/功能的抽象</p></li>
<li><p>一般建议函数的体积不超过单屏的显示面积</p></li>
<li><p>C中采用如下格式声明函数</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&lt;存储类型&gt; &lt;返回值类型&gt; function (形式参数及其说明)&#123;
 ;
&#125;</code></pre></div>
<p>注意，存储类型只有extern和static两种</p>
<p>返回值除了常见的数据类型，还可以是指针和结构体</p></li>
<li><p>C的实参可以指定参数名</p></li>
<li><p>C支持可变参数的定义，通过<code>...</code>标识</p></li>
<li><p>对于main函数，返回值可以使用<code>EXIT_SUCCESS</code>或<code>EXIT_FAILURE</code>宏，其被定义在<code>&lt;strlib&gt;</code>中</p></li>
</ul>
<h3 id="函数的调用">函数的调用</h3>
<p>函数调用主要存在两种情况，本文件调用和跨文件调用，但在此之前首先要明确函数的声明以及函数原型。</p>
<p>由于C编译器在编译时如果发现一个函数，需要立刻对其进行编译，因此调用的函数必须在调用前进行声明后使用；但问题来了，如果函数很多，甚至我们调用了外部的函数，就会难以满足这个条件，因此C提供了函数原型。只需要在源文件头部生命函数原型，即可正常调用该函数。</p>
<h3 id="static标识符">static标识符</h3>
<p>static标识符在发展过程中得到了三种主要的作用，首先最直观的是</p>
<ol type="1">
<li>声明静态变量。</br> 对一个函数来讲，其内部变量在函数被调用时总是会被初始化；使用<code>static</code>声明后，该变量将在第一次初始化之后被保护起来</li>
<li>声明内部函数。</br> 既然可以对一个变量使用<code>statcic</code>声明，自然也可以对一个函数使用。这种情况下，函数被视作内部函数，不可以被其他文件调用</li>
</ol>
<blockquote>
<p>换句话讲，这意味着函数不刻意生命的话是能够被其他文件调用的。这其实是<code>extern</code>标识符的作用，二者在这一角度上正好有相反的作用，而所有函数相当于默认都会添加一个<code>extern</code>标识符允许外部调用</p>
</blockquote>
<ol type="1">
<li>修饰数组参数。</li>
</ol>
<p>比如<code>void function(int a[static 3])</code>意味着该参数的数组长度应当大于3，这与其字面含义有些出入</p>
<h3 id="const标识符">const标识符</h3>
<p><code>const</code>含义更多的在于维持原本的值，而不是<code>static</code>这样一直保持这个值。在函数参数中出现的<code>cosnt</code>，意义在于表示函数内部不得修改该参数变量。</p>
<p>特别的，对于函数指针会有两种情况</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void f(const int* p );
void f(int* const p);</code></pre></div>
<p>前者<code>const</code>能够保证<code>p</code>这个指针的值不会被修改，也就是<code>p</code>所指向的内存被保护起来，其值不可以被修改；后者保证了<code>p</code>的安全，也就意味着<code>p</code>的指向不可以被修改，但其指向的值并没有被保护起来；当然，我们也可以在两个位置都使用<code>const</code>声明。</p>
<h4 id="头文件声明">头文件声明</h4>
<ul>
<li><p>对于C标准库，我们通过类似<code>#include &lt;stdio.h&gt;</code>的形式调用</p></li>
<li><p>自己定义头文件，使用类似<code>#include "file.h"</code>的形式调用</p>
<blockquote>
<p><code>&lt;文件名&gt;</code>表示在<strong>系统指定的目录</strong>下寻找指定文件。</p>
<p><code>“文件名”</code>表示先在包含#include命令的源文件所在的目录下查找指定文件，找不到时，再到系统指定的目录下寻找指定文件。</p>
</blockquote></li>
</ul>
<h2 id="由函数终止程序">由函数终止程序</h2>
<p>其实就是讨论<code>exit()</code>函数</p>
<p>exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件stdlib.h里面。其返回值一是<code>EXIT_SUCCESS</code>或<code>EXIT_FAILURE</code></p>
<p>有时调用<code>exit()</code>函数时还需要一些其他函数，C提供了一个<code>atexit()</code>函数，用来登记exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件stdlib.h。</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int atexit(void (*func)(void));</code></pre></div>
<h2 id="函数间数据传递">函数间数据传递</h2>
<h3 id="通过参数值传递">通过参数（值）传递</h3>
<blockquote>
<p>C默认使用值传递</p>
</blockquote>
<ul>
<li>只适合传输少数数据</li>
<li>传送的数据的<strong>一份样本</strong></li>
<li>传入值的所有操作不会对外部变量产生影响</li>
</ul>
<h3 id="通过地址传递">通过地址传递</h3>
<p>很明显值传递往往是不符合需要的，而且C/C++不支持返回多个返回值，这会带来很大不便</p>
<p>要解决这个小问题，只需要传入变量的地址即可，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Swap(int* x, int* y) &#123;
  int temp;
  temp &#x3D; *x;
  *x &#x3D; *y;
  *y &#x3D; temp;
&#125;</code></pre></div>
<h3 id="可变参数">可变参数</h3>
<p>有时函数接受的参数长度并不确定，可以使用<code>...</code>来表示可变数量的参数</p>
<p>头文件stdarg.h定义了一些宏，可以操作可变参数。</p>
<ol type="1">
<li><code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</li>
<li><code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</li>
<li><code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</li>
<li><code>va_end</code>：一个函数，用来清理可变参数对象。</li>
</ol>
<p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">double average(int i, ...) &#123;
  double total &#x3D; 0;
  va_list ap;
  va_start(ap, i);
  for (int j &#x3D; 1; j &lt;&#x3D; i; ++j) &#123;
    total +&#x3D; va_arg(ap, double);
  &#125;
  va_end(ap);
  return total &#x2F; i;
&#125;</code></pre></div>
<p>上面示例中，va_list ap定义ap为可变参数对象，va_start(ap, i)将参数i后面的参数统一放入ap，va_arg(ap, double)用来从ap依次取出一个参数，并且指定该参数为 double 类型，va_end(ap)用来清理可变参数对象。</p>
<h1 id="指针">指针</h1>
<p>首先啊要明确，指针是C的概念，它是一个记录内存地址的值；C++为了简化，设计了引用。</p>
<h2 id="基本概念和引入">基本概念和引入</h2>
<p>不难理解指针是一个指向某个内存地址的值，那么指针迎来了第一个问题——类型</p>
<p>指针是有类型的，它的类型决定了内存地址块的大小，区分数据类型本身和他的指针的方式就是指针类型会添加一个<code>*</code>。准确来说，<code>*</code>并不依附于原本类型，比如说</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p1;
int * p2;
int *p3;
int        *             p4;</code></pre></div>
<p>都是合法的声明方式，只是添加一个<code>*</code>即可。一般来说，我们使用<code>type* p</code>的形式，用来强调指针类型也是一种类型。</p>
<p>在声明后，编译器会为指针随机指向一块内存空间，显然这是不安全的，我们可以用声明同种数据类型的方式对他进行初始化</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p;
int i;
p &#x3D; &amp;i;

int* p &#x3D; NULL;</code></pre></div>
<blockquote>
<p>为了防止错误的使用，我们可以像最后一行那样将指针变量先指向<code>NULL</code>(内存地址0)，在没有初始化时对其调用就会报错</p>
</blockquote>
<p>指针指向一块内存地址，我们需要有方法得到和保存着快地址的一些信息</p>
<ul>
<li>取出地址:使用<code>&amp;</code>运算符，获得该指针指向的<strong>内存地址</strong></li>
<li>取出值:使用<code>*</code>运算符，获得该指针指向的内存地址所保存的<strong>数据值</strong></li>
</ul>
<h2 id="指针运算">指针运算</h2>
<p>指针的运算会有所不同，首先我们考虑指针具有的数据类型，其类型决定一个变量在内存中占据的大小，因此我们可以得到指针变量加法和减法的一些概念</p>
<ul>
<li>指针变量与数值加减：在原来内存地址的基础上，移动若干个类型的长度</li>
<li>指针变量之间的减法：返回两个指针指向的内存地址之间相隔该数据类型的个数 &gt; 此时返回值为`<code>ptrdiff_t，被定义在</code>stddef.h`中</li>
<li>指针变量之间的比较：较大的一方返回1</li>
</ul>
<h2 id="受限指针">受限指针</h2>
<p>声明指针变量时，可以使用<code>restrict</code>说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。</p>
<h2 id="指针与数组">指针与数组</h2>
<h2 id="指针与函数">指针与函数</h2>
<blockquote>
<p>在C内部，函数名也被视作一个指针：函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址</p>
</blockquote>
<p>函数指针的定义和使用会有些混乱，但我们先考虑上面所说的因素，这会使得调用函数有如下形式</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">print(var);
(*print)(var);
(&amp;print)(var);</code></pre></div>
<p>笔者认为其实这三种都可以认为是通过函数名直接调用，只是第一种方式通过符号名与实际内存地址的映射进行调用，有点像是语法糖的感觉；</p>
<blockquote>
<p>之所以这样说，是因为我们可以考虑将所有变量调用、函数调用都视作对内存的直接操作，这种语境下符号名显然就不具有实在的作用——特别是与后面两者相比，它既没有取出函数的地址也没有取出函数的值，所以不妨把它看作一种简化、语法糖</p>
</blockquote>
<p>第二种方式取出该函数名作为指针指向的内存的值，相当于取出了整块内存的数据得到这个函数；第三种则是将变量传入这块内存中。</p>
<p>如果我们引入函数指针，首先一个问题是它的声明会有些奇怪</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void (*print_ptr)(int) &#x3D; &amp;print;</code></pre></div>
<p>这样对函数的调用还有两种</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">(*print_ptr)(var);
*print_ptr(var);</code></pre></div>
<p>那么问题来了，为什么没有</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&amp;print_ptr(var);</code></pre></div>
<h1 id="c的内存操作">C的内存操作</h1>
<h2 id="分配内存">分配内存</h2>
<p>C提供了几个可以为程序在堆区分配内存的函数，分别是<code>malloc()</code>、<code>calloc()</code>和<code>realloc()</code>，他们都可以在内存中开辟指定大小的连续空间，其中<code>calloc()</code>简化了<code>malloc()</code>部分操作，<code>realloc()</code>则用于修改内存空间。</p>
<h3 id="开辟内存空间">开辟内存空间</h3>
<p><code>malloc()</code>接受一个<code>size_t</code>类型的参数，返回万能指针<code>void*</code>，用来记录开辟的内存的地址。</p>
<p><code>malloc()</code>分配的内存空间不包含类型信息，也没有对内存进行初始化，也就是说，仅仅分配内存也是可以访问的，但不安全也不确定。</p>
<p>通常会使用<code>sizeof(type)</code>来计算需要的内存空间大小，有时还会进行一次强制类型转换增强可读性，比如这样</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p &#x3D; (int*) malloc(sizeof(int));
&#x2F;&#x2F;动态分配内存
int* q &#x3D; (int*) malloc(sizeof(*q));</code></pre></div>
<blockquote>
<p>由于<code>malloc()</code>可以指定要分配的内存大小，所以在参数中包含的变量能够实现动态数组——根据前面运行的情况分配一定大小的数组，这是直接使用数组声明无法实现的。</p>
</blockquote>
<p><code>malloc()</code>分配内存有可能分配失败，这时返回常量 <code>NULL</code>。<code>Null</code>的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括<code>stdlib.h</code>等多个头文件里面都有定义，所以只要可以使用<code>malloc()</code>，就可以使用NULL。由于存在分配失败的可能，所以最好在使用<code>malloc()</code>之后检查一下，是否分配成功。比如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* p &#x3D; malloc(sizeof(int));

if (p &#x3D;&#x3D; NULL) &#123;
  &#x2F;&#x2F; 内存分配失败
&#125;

&#x2F;&#x2F; or
if (!p) &#123;
  &#x2F;&#x2F;...
&#125;</code></pre></div>
<blockquote>
<p>事实上，<code>NULL</code>的值不一定是0.前桥和弥在《征服C指针》中提到了<code>NULL</code>的细节</p>
</blockquote>
<p>malloc()最常用的场合，就是为数组和自定义数据结构分配内存。</p>
<h3 id="calloc的简化"><code>calloc()</code>的简化</h3>
<p><code>calloc()</code>可以视作对<code>malloc()</code>的简化，他有两个差异</p>
<ol type="1">
<li>接受两个参数，分别是数据类型的数量和单位字节长度。这使得使用<code>malloc()</code>时的<code>sizeof(type)*n</code>更换为两个参数，有更好的可读性。</li>
<li><code>calloc()</code>会将所分配的内存全部初始化为0。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为0，还要额外调用<code>memset()</code>函数。</li>
</ol>
<h3 id="内存块大小的修改">内存块大小的修改</h3>
<p><code>realloc()</code>函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回<code>NULL</code>。</p>
<p><code>realloc()</code>可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code>优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自行调用<code>memset()</code>）。比如下面的例子就是动态控制数组的长度</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">int* b;

b &#x3D; malloc(sizeof(int) * 10);
b &#x3D; realloc(b, sizeof(int) * 2000);</code></pre></div>
<p>当<code>realloc()</code>的第一个参数为<code>Null</code>，等价于开辟一块新的内存空间；第二个参数为<code>0</code>等价于清空内存。</p>
<h2 id="对内存的操作">对内存的操作</h2>
<h3 id="设置值">设置值</h3>
<p><code>memset()</code>函数可以向内存地址填充连续的同一个值，常用来初始化分配的新的内存块。</p>
<h3 id="复制">复制</h3>
<p><code>memcpy()</code>可以将内存中的内容从一个地址复制到另一个地址，这两个内存块不应该有互相重叠的区域。</p>
<p><code>memcpy()</code>可以取代<code>strcpy()</code>进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快。</p>
<p>以下是一种实现方式</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void* my_memcpy(void* dest, void* src, int byte_count) &#123;
  char* s &#x3D; src;
  char* d &#x3D; dest;

  while (byte_count--) &#123;
    *d++ &#x3D; *s++;
  &#125;

  return dest;

&#125;</code></pre></div>
<p><code>memmove()</code>函数用于将一段内存数据复制到另一段内存。它跟<code>memcpy()</code>的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与<code>memcpy()</code>行为相同。</p>
<h3 id="比较内容">比较内容</h3>
<p><code>memcmp()</code>函数用来比较两个内存区域。</p>
<h2 id="清理内存">清理内存</h2>
<p><code>free()</code>用于释放<code>malloc()</code>函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。</p>
<blockquote>
<p>如果程序存在未被回收的内存，最终就会引发“内存溢出”。</br> C中使用<code>malloc()</code>、<code>free()</code>等函数的过程可以算是一些语言的内存垃圾回收机制的核心工作。</p>
</blockquote>
<h1 id="结构与联合">结构与联合</h1>
<h2 id="结构">结构</h2>
<h3 id="声明和初始化">声明和初始化</h3>
<p>C与C++在声明结构时有语法习惯的差异，C会保留关键字<code>struct</code>，而C++会省略，这种改变目的在于强调对数据类型的声明</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct c_style_type &#123;&#125;;
cpp_style_type &#123;&#125;;</code></pre></div>
<p>通常情况下，使用外部声明声明结构数据类型，这也是C++鼓励的用法</p>
<p>C中，由于<code>struct</code>的声明需要采用这种形式</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hello &#123;
  int a;
  int b;
&#125;;

struct hello h;</code></pre></div>
<p>总是需要带上<code>struct</code>很是别扭，所以往往使用<code>typedef</code>关键字定义一个别名便于使用，增强可读性。</p>
<p><code>struct</code>占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。</p>
<blockquote>
<p>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</br> 由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递减的顺序定义每个属性将最大的一个属性放在最后，这样就能节省一些空间。</p>
</blockquote>
<h3 id="参数的传递">参数的传递</h3>
<ul>
<li>默认情况下，结构数据类型作为形参使用值传递</li>
</ul>
<p>在使用<code>struct</code>指针时，<code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符<code>-&gt;</code>，可以从 <code>struct</code>指针上直接获取属性，大大增强了代码的可读性。比如</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">void happy(struct turtle* t) &#123;
  t-&gt;age &#x3D; t-&gt;age + 1;
&#125;</code></pre></div>
<p>也就是说，对于<code>struct</code>变量名，使用点运算符<code>.</code>获取属性；对于<code>struct</code>变量指针，使用箭头运算符<code>-&gt;</code>获取属性。</p>
<h3 id="位字段">位字段</h3>
<h3 id="弹性数组成员">弹性数组成员</h3>
<p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p>
<p>弹性数组成员总是为结构的最后一个属性，且这个结构需要至少一个其他属性</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct vstring &#123;
  int len;
  char chars[];
&#125;;
struct vstring* str &#x3D; malloc(sizeof(struct vstring) + n * sizeof(char));
str-&gt;len &#x3D; n;</code></pre></div>
<h2 id="typedef"><code>typedef</code></h2>
<h2 id="联合共用体">联合/共用体</h2>
<p>共用体像是对数据类型的重载，他可以保存多种数据类型，但只能使用一种类型</p>
<p>他最常见的目的是节省内存</p>
<h1 id="c与c">C++与C</h1>
<h2 id="c引入的特性">C++引入的特性</h2>
<h3 id="一些关键字">一些关键字</h3>
<h3 id="命名空间">命名空间</h3>
<ul>
<li><p>在一个源文件中要用到两个分别在另外两个源文件中定义的不同全局程序实体（如：全局函数），而这两个全局程序实体的名字相同。</p></li>
<li><p>在一个命名空间中定义的全局标识符，其作用域为该命名空间</p></li>
<li><p>当在一个命名空间外部需要使用该名空间中定义的全局标识符时，可用该命名空间的名字来修饰或受限。</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模块1
namespace A
&#123; int x&#x3D;1;
void f()
&#123; ;
&#125; 
&#125;
&#x2F;&#x2F;模块2
namespace B
&#123; int x&#x3D;0;
void f()
&#123; ;
&#125; &#125;

&#x2F;&#x2F;模块3
... A::x ... &#x2F;&#x2F;A中的x 
A::f(); &#x2F;&#x2F;A中的f
... B::x ... &#x2F;&#x2F;B中的x
B::f(); &#x2F;&#x2F;B中的f</code></pre></div></li>
</ul>
<h2 id="类与结构体">类与结构体</h2>
<h1 id="c多模块结构">C++多模块结构</h1>
<h2 id="简介">简介</h2>
<ul>
<li>模块是为了便于从物理上对程序进行组织、管理和理解，便于多人合作开发一个程序</li>
<li>可以按某种规则对构成C++程序的各个逻辑单位（全局函数、全局常量、全局变量/对象、类等）的定义进行分组，分别把它们放在若干个源文件中（.cpp），构成若干个模块</li>
<li>模块可以单独编译</li>
</ul>
<h2 id="构成和实现">构成和实现</h2>
<ul>
<li>接口（.h）：给出在本模块中定义的、提供给其它模块使用的一些程序实体（如：全局函数、全局变量等）的<strong>声明</strong>和（如类型、常量等）<strong>定义</strong></li>
<li>实现(.cpp)：给出模块中的<strong>程序实体的定义</strong></li>
<li>在模块A中要用到模块B中定义的程序实体时，可以在A的.cpp文件中用文件<strong>包含命令（#include）把B的.h文件包含进来</strong></li>
</ul>
<h1 id="面向对象">面向对象</h1>
<h2 id="类与对象">类与对象</h2>
<h2 id="this指针">this指针</h2>
<h2 id="类成员特殊成员和对象成员等">类成员、特殊成员和对象成员等</h2>
<h2 id="友元">友元</h2>
<h2 id="继承">继承</h2>
<h2 id="多态">多态</h2>
<h1 id="常用库">常用库</h1>
<h2 id="stdio.h">&lt;stdio.h&gt;</h2>
<h2 id="cctype.h">&lt;cctype.h&gt;</h2>
<ul>
<li><code>tolower</code>和<code>tohigher</code></li>
</ul>
<h2 id="bios.h">&lt;bios.h&gt;</h2>
<ul>
<li>basic input &amp; output system</li>
</ul>
<h3 id="常用函数">常用函数</h3>
<ul>
<li><p>bioskey()</p>
<p>读取参数0时，能够获取键盘上的功能键</p></li>
</ul>
<h1 id="c和c的风格差异">C和C++的风格差异</h1>
<h2 id="小规则">小规则</h2>
<ul>
<li><p>类型强制转换</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(type) var;&#x2F;&#x2F; C
type(var);&#x2F;&#x2F; C++</code></pre></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++练习和DSA课程的准备</title>
    <url>/blog/posts/44011/</url>
    <content><![CDATA[<h2 id="google-guide">Google Guide</h2>
<h2 id="强化的数据类型">强化的数据类型</h2>
<h3 id="智能指针">智能指针</h3>
<h3 id="更安全的数组">更安全的数组</h3>
<h2 id="数据结构">数据结构</h2>
<h2 id="面向对象">面向对象</h2>
<h3 id="类的设计">类的设计</h3>
<p>设计一个<code>C++</code>类时，应当依次考虑一下几个问题<sup>1</sup></p>
<ol type="1">
<li>对象的初始化方式</li>
<li>构造函数</li>
<li>拷贝构造函数、赋值运算符</li>
<li>移动构造函数、移动赋值运算符</li>
<li>析构函数</li>
<li>继承体系</li>
<li>Rule of Three/Five</li>
<li>访问控制</li>
<li>传值和传引用</li>
<li>const语义</li>
<li>智能指针作为类的成员</li>
<li>异常处理</li>
<li>标准库使用</li>
<li>模板设计模式</li>
<li>线程安全及可重入</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>[1] <a href="https://zhuanlan.zhihu.com/p/271732707">如何设计一个C++的类 - Gemfield的文章 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/blog/posts/43a46ea2/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p>Flutter实战</p></li>
<li><p>Flutter Codelab</p></li>
<li><p>Flutter核心技术与实战</p></li>
</ul>
<h2 id="dart语言">Dart语言</h2>
<blockquote>
<p>Dart 在静态语法方面和 Java 非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和 JavaScript 很像，如函数式特性、异步支持等。</p>
</blockquote>
<h3 id="变量声明">变量声明</h3>
<ol type="1">
<li><p>使用var声明变量。</p>
<p>Dart 中 var 变量一旦赋值，类型便会确定，则不能再改变其类型。</p>
<blockquote>
<p>Dart不管怎么说也是个强类型的语言，所以第一次使用后就被确定</p>
</blockquote></li>
<li><p>使用<code>dynamic</code>和<code>Object</code></p>
<p>与Java相似，<code>Object</code>是所有对象的基类，<code>dynamic</code>与<code>Object</code>声明的变量都可以赋值任意对象，且后期可以改变赋值的类型，这和 <code>var</code> 是不同的</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">dynamic t;
Object x;
t &#x3D; &quot;hi world&quot;;
x &#x3D; &#39;Hello Object&#39;;
&#x2F;&#x2F;下面代码没有问题
t &#x3D; 1000;
x &#x3D; 1000;</code></pre></div>
<blockquote>
<p><code>dynamic</code>与<code>Object</code>不同的是<code>dynamic</code>声明的对象编译器会提供所有可能的组合，而<code>Object</code>声明的对象只能使用 <code>Object</code> 的属性与方法, 否则编译器会报错</p>
</blockquote></li>
<li><p><code>final</code>和<code>const</code></p>
<p><code>const</code> 变量是一个编译时常量（<strong>编译时直接替换为常量值</strong>），<code>final</code>变量在第一次使用时被初始化。</p></li>
<li><p>空安全</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">int i &#x3D; 8; &#x2F;&#x2F;默认为不可空，必须在定义时初始化。
int? j; &#x2F;&#x2F; 定义为可空类型，对于可空变量，我们在使用前必须判空。

&#x2F;&#x2F; 如果我们预期变量不能为空，但在定义时不能确定其初始值，则可以加上late关键字，
&#x2F;&#x2F; 表示会稍后初始化，但是在正式使用它之前必须得保证初始化过了，否则会报错
late int k;
k&#x3D;9;</code></pre></div>
<p>如果一个变量我们定义为可空类型，在某些情况下即使我们给它赋值过了，但是预处理器仍然有可能识别不出，这时我们就要显式（通过在变量后面加一个”!“符号）告诉预处理器它已经不是null</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Test&#123;
  int? i;
  Function? fun;
  say()&#123;
    if(i!&#x3D;null) &#123;
      print(i! * 8); &#x2F;&#x2F;因为已经判过空，所以能走到这 i 必不为null，如果没有显式申明，则 IDE 会报错
    &#125;
    if(fun!&#x3D;null)&#123;
      fun!(); &#x2F;&#x2F; 同上
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 这是个针对函数变量的语法糖
fun?.call() &#x2F;&#x2F; fun 不为空时则会被调用</code></pre></div></li>
</ol>
<p>Dart同时提供了一些运算用于Null的处理，例如</p>
<ul>
<li><code>?.</code>：若为Null，则略过这一行</li>
<li><code>??</code>：如果为Null，则返回右值，否则返回左值</li>
<li><code>??=</code>：如果左边为Null，则给左值赋予右值</li>
</ul>
<h3 id="函数声明">函数声明</h3>
<blockquote>
<p>Dart是一种真正的面向对象的语言，所以<strong>即使是函数也是对象</strong>，并且有一个类型<strong>Function</strong>。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。</p>
</blockquote>
<p>Dart函数声明如果没有显式声明返回值类型时会默认当做<code>dynamic</code>处理</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">bool isNoble(int atomicNumber) &#123;
  return _nobleGases[atomicNumber] !&#x3D; null;
&#125;</code></pre></div>
<p>函数可以被作为变量使用</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">var say &#x3D; (str)&#123;
  print(str);
&#125;;
say(&quot;hi world&quot;);</code></pre></div>
<p>可变参数的声明</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">String say(String from, String msg, [String device]) &#123;
  var result &#x3D; &#39;$from says $msg&#39;;
  if (device !&#x3D; null) &#123;
    result &#x3D; &#39;$result with a $device&#39;;
  &#125;
  return result;
&#125;</code></pre></div>
<p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数</p>
<p><strong>不能同时使用可选的位置参数和可选的命名参数</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F;设置[bold]和[hidden]标志
void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;
    &#x2F;&#x2F; ... 
&#125;</code></pre></div>
<h3 id="mixin相当于对多继承的一种实现">mixin(相当于对多继承的一种实现)</h3>
<blockquote>
<p>Dart 是不支持多继承的，但是它支持 mixin，简单来讲 mixin 可以 “组合” 多个类</p>
</blockquote>
<p>我们定义了几个 mixin，然后通过 with 关键字将它们组合成不同的类</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;
  say() &#123;
    print(&#39;say&#39;);
  &#125;
&#125;

mixin Eat &#123;
  eat() &#123;
    print(&#39;eat&#39;);
  &#125;
&#125;

mixin Walk &#123;
  walk() &#123;
    print(&#39;walk&#39;);
  &#125;
&#125;

mixin Code &#123;
  code() &#123;
    print(&#39;key&#39;);
  &#125;
&#125;

class Dog with Eat, Walk&#123;&#125;
class Man extends Person with Eat, Walk, Code&#123;&#125;</code></pre></div>
<h3 id="异步">异步</h3>
<blockquote>
<p>Dart类库有非常多的返回<code>Future</code>或者<code>Stream</code>对象的函数。 这些函数被称为<strong>异步函数</strong>：它们只会在设置好一些耗时操作之后返回，比如像 IO操作，而不是等到这个操作完成。</p>
</blockquote>
<h4 id="future">Future</h4>
<p><code>Future</code>与JavaScript中的<code>Promise</code>非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示</p>
<p><code>Future</code> 的所有API的返回值仍然是一个<code>Future</code>对象，所以可以很方便的进行链式调用</p>
<p>使用Future.delayed 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串"hi world!"，然后我们在then中接收异步结果并打印结果</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Future.delayed(Duration(seconds: 2),()&#123;
   return &quot;hi world!&quot;;
&#125;).then((data)&#123;
   print(data);
&#125;);</code></pre></div>
<p>如果异步任务发生错误，我们可以在<code>catchError</code>中捕获错误</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Future.delayed(Duration(seconds: 2),()&#123;
   &#x2F;&#x2F;return &quot;hi world!&quot;;
   throw AssertionError(&quot;Error&quot;);  
&#125;).then((data)&#123;
   &#x2F;&#x2F;执行成功会走到这里  
   print(&quot;success&quot;);
&#125;).catchError((e)&#123;
   &#x2F;&#x2F;执行失败会走到这里  
   print(e);
&#125;);</code></pre></div>
<p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在<code>then</code>或<code>catch</code>中关闭一下对话框，第二种就是使用<code>Future</code>的<code>whenComplete</code>回调</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Future.delayed(Duration(seconds: 2),()&#123;
   &#x2F;&#x2F;return &quot;hi world!&quot;;
   throw AssertionError(&quot;Error&quot;);
&#125;).then((data)&#123;
   &#x2F;&#x2F;执行成功会走到这里 
   print(data);
&#125;).catchError((e)&#123;
   &#x2F;&#x2F;执行失败会走到这里   
   print(e);
&#125;).whenComplete(()&#123;
   &#x2F;&#x2F;无论成功或失败都会走到这里
&#125;);</code></pre></div>
<p>总的来说，使用<code>Future</code>执行一段异步调用的语句包含四个部分，一是<code>.delayed(&#123;&#125;)</code>，要执行的语句；二是<code>.then((data)&#123;&#125;)</code>执行成功要执行的语句；三是失败时执行的<code>.catchError((e)&#123;&#125;)</code>；四是总是执行的<code>.whenComplete(()&#123;&#125;)</code></p>
<p>记得在执行时抛出<code>AssertionError("Error")</code>异常！</p>
<p>对于一组要执行的异步操作，我们使用<code>Future.wait</code>，它接受一个<code>Future</code>数组参数，只有数组中所有<code>Future</code>都执行成功后，才会触发<code>then</code>的成功回调，只要有一个<code>Future</code>执行失败，就会触发错误回调</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Future.wait([
  &#x2F;&#x2F; 2秒后返回结果  
  Future.delayed(Duration(seconds: 2), () &#123;
    return &quot;hello&quot;;
  &#125;),
  &#x2F;&#x2F; 4秒后返回结果  
  Future.delayed(Duration(seconds: 4), () &#123;
    return &quot; world&quot;;
  &#125;)
]).then((results)&#123;
  print(results[0]+results[1]);
&#125;).catchError((e)&#123;
  print(e);
&#125;);</code></pre></div>
<h4 id="asyncawait">Async/Await</h4>
<blockquote>
<p>Dart中的<code>async/await</code> 和JavaScript中的<code>async/await</code>功能和用法是一模一样的</p>
</blockquote>
<h4 id="回调的整体解决思路">回调的整体解决思路</h4>
<p>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现<code>Future.then</code>回调中套回调情况。因此我们可以将调用的结果缓存在本地文件系统，再统一进行调用</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F;先分别定义各个异步任务
Future&lt;String&gt; login(String userName, String pwd)&#123;
	...
    &#x2F;&#x2F;用户登录
&#125;;
Future&lt;String&gt; getUserInfo(String id)&#123;
	...
    &#x2F;&#x2F;获取用户信息 
&#125;;
Future saveUserInfo(String userInfo)&#123;
	...
	&#x2F;&#x2F; 保存用户信息 
&#125;; 

login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;
 &#x2F;&#x2F;登录成功后通过，id获取用户信息    
 getUserInfo(id).then((userInfo)&#123;
    &#x2F;&#x2F;获取用户信息后保存 
    saveUserInfo(userInfo).then(()&#123;
       &#x2F;&#x2F;保存用户信息，接下来执行其它操作
        ...
    &#125;);
  &#125;);
&#125;)</code></pre></div>
<p>这个问题被形象的称为<strong>回调地狱（Callback Hell）</strong></p>
<p><code>Dart</code>语言提供两种方案，第一个是<code>Future</code>。利用其始终返回一个<code>Future</code>对象的特性，我们可以进行如下格式的调用</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;
  	return getUserInfo(id);
&#125;).then((userInfo)&#123;
    return saveUserInfo(userInfo);
&#125;).then((e)&#123;
   &#x2F;&#x2F;执行接下来的操作 
&#125;).catchError((e)&#123;
  &#x2F;&#x2F;错误处理  
  print(e);
&#125;);</code></pre></div>
<p>使用async/await也可以实现，例如</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">task() async &#123;
   try&#123;
    String id &#x3D; await login(&quot;alice&quot;,&quot;******&quot;);
    String userInfo &#x3D; await getUserInfo(id);
    await saveUserInfo(userInfo);
    &#x2F;&#x2F;执行接下来的操作   
   &#125; catch(e)&#123;
    &#x2F;&#x2F;错误处理   
    print(e);   
   &#125;  
&#125;</code></pre></div>
<h4 id="stream">Stream</h4>
<p><code>Stream</code> 也是用于接收异步事件数据，和 <code>Future</code> 不同的是，它可以接收多个异步操作的结果（成功或失败）。</p>
<p>也就是说，在执行异步任务时，可以通过<strong>多次触发成功或失败事件来传递结果数据或错误异常。</strong></p>
<p><code>Stream</code> 常用于会<strong>多次读取数据的异步任务场景</strong>，如网络内容下载、文件读写等</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Stream.fromFutures([
  &#x2F;&#x2F; 1秒后返回结果
  Future.delayed(Duration(seconds: 1), () &#123;
    return &quot;hello 1&quot;;
  &#125;),
  &#x2F;&#x2F; 抛出一个异常
  Future.delayed(Duration(seconds: 2),()&#123;
    throw AssertionError(&quot;Error&quot;);
  &#125;),
  &#x2F;&#x2F; 3秒后返回结果
  Future.delayed(Duration(seconds: 3), () &#123;
    return &quot;hello 3&quot;;
  &#125;)
]).listen((data)&#123;
   print(data);
&#125;, onError: (e)&#123;
   print(e.message);
&#125;,onDone: ()&#123;

&#125;);</code></pre></div>
<h3 id="dart和其他主流语言">Dart和其他主流语言</h3>
<h2 id="widget简介">Widget简介</h2>
<p>在 Flutter 中，Widget 采用由父到子、自顶向下的方式进行构建，父 Widget 控制着子 Widget 的显示样式，其样式配置由父 Widget 在构建时提供。</p>
<h3 id="statelesswidget">StatelessWidget</h3>
<figure>
<img src="https://img.kancloud.cn/3e/c9/3ec97a9f584132c2bcdbca60fd2888cc_442x422.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<p>第一个小例子是，我需要创建一个自定义的弹窗控件，把使用 App 过程中出现的一些错误信息提示给用户。这个组件的父 Widget，能够完全在子 Widget 初始化时将组件所需要的样式信息和错误提示信息传递给它，也就意味着父 Widget 通过初始化参数就能完全控制其展示效果。所以，我可以采用继承 StatelessWidget 的方式，来进行组件自定义。</p>
<p>第二个小例子是，我需要定义一个计数器按钮，用户每次点击按钮后，按钮颜色都会随之加深。可以看到，这个组件的父 Widget 只能控制子 Widget 初始的样式展示效果，而无法控制在交互过程中发生的颜色变化。所以，我无法通过继承 StatelessWidget 的方式来自定义组件。那么，这个时候就轮到 StatefulWidget 出场了。</p>
</blockquote>
<h3 id="statefulwidget">StatefulWidget</h3>
<figure>
<img src="https://img.kancloud.cn/8a/e7/8ae7bf36f618a999da8847cbb4da4bf6_762x502.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>与 StatelessWidget 相对应的，有一些 Widget（比如 Image、Checkbox）的展示，除了父 Widget 初始化时传入的静态配置之外，还需要处理用户的交互（比如，用户点击按钮）或其内部数据的变化（比如，网络数据回包），并体现在 UI 上。</p>
<h2 id="flutter简介">Flutter简介</h2>
<h3 id="如何理解flutter">如何理解Flutter</h3>
<p>Flutter可以被看作是一个UI框架，它的存在有效提高了跨平台开发的效率和UI的美观。</p>
<p>Flutter使用Dart语言开发，支持<strong>空安全(Null Safety)</strong>、单行函数之类的语法特性；能够实现很多业务逻辑的处理；可以调用原生平台的代码进行开发；大量的包也已经实现了如调用摄像头这样的操作。</p>
<h3 id="flutter原理">Flutter原理</h3>
<p>Flutter框架示意图</p>
<figure>
<img src="https://book.flutterchina.club/assets/img/1-1.82c25693.png" alt="图1-1" /><figcaption aria-hidden="true">图1-1</figcaption>
</figure>
<h3 id="flutter项目的结构">Flutter项目的结构</h3>
<h4 id="开发习惯">开发习惯</h4>
<blockquote>
<p>目前为止这些都是观察到的规律，并不一定是合适的</p>
</blockquote>
<ul>
<li><p>与Java不同，Dart一般不会按照类来组织文件，一个文件一般会包含一整个业务逻辑</p></li>
<li><p>Dart语言不存在接口等概念，一般也不会考虑设计模式（据说设计模式主要是为了弥补Java的一些乱七八糟的小问题才被提出）。分包的依据主要考虑组件功能，例如:</p>
<ul>
<li>widgets：用于存放自定义的组件</li>
<li>routes：存放导航页面，或者仅为一个用于注册命名路由的文件</li>
<li>models：存放实体类，一般只放一个文件</li>
<li>common/data：存放常量</li>
<li>l10n：国际化</li>
<li>pages</li>
<li>themes</li>
</ul>
<blockquote>
<p>官方示例Gallery</p>
<p>https://github.com/flutter/gallery/tree/master/lib</p>
<p>组件化和平台化，该如何组织合理稳定的Flutter工程结构？——Flutter核心技术与实践</p>
<p>https://www.kancloud.cn/alex_wsc/flutter_demo/1572034</p>
</blockquote></li>
</ul>
<h3 id="基本元素">基本元素</h3>
<p>一个Flutter项目同样是从<code>main</code>方法开始执行的，然后调用<code>MyApp</code>方法开始build一个Widget树</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void main() &#x3D;&gt; runApp(const MyApp());</code></pre></div>
<p>Flutter中，万物皆为Widget，甚至连居中这样的排版元素也是Widget，整个App也是一个MaterialApp</p>
<p>所有的Widget，不管是StatefulWidget还是StatelessWidget都有一个build方法构建，除此以外涉及到的还有Flutter中Widget的生命周期问题</p>
<figure>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a53f87642e44a2ae19d3dd42787005~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="State生命周期方法" /><figcaption aria-hidden="true">State生命周期方法</figcaption>
</figure>
<p>Flutter中采用的是和Vue、React类似的响应式布局，通过声明Widget、State双向绑定数据实现数据和UI的更新。当数据更新时，State状态改变，触发build方法，依次向下逐个触发build方法更新视图。</p>
<h1 id="基本概念和一些原理">基本概念和一些原理</h1>
<h2 id="context">Context</h2>
<p>context是BuildContext的一个示例，它是对该组件再Widget树中位置的描述，提供了一些方法。</p>
<blockquote>
<p>如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个of 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供of方法。</p>
</blockquote>
<h2 id="调试">调试</h2>
<ol type="1">
<li><code>debugger()</code>语句采用一个可选<code>when</code>参数，我们可以指定该参数仅在特定条件为真时中断</li>
<li><code>print()</code>功能将输出到系统控制台，我们可以使用<code>flutter logs</code>来查看它（基本上是一个包装<code>adb logcat</code>）</li>
<li><code>debugPrint()</code>是一个封装print，它将输出限制在一个级别，避免被Android内核丢弃</li>
</ol>
<h2 id="异常">异常</h2>
<blockquote>
<p><code>debugPrint()</code>是一个封装print，它将输出限制在一个级别，避免被Android内核丢弃</p>
</blockquote>
<h1 id="基本组件和布局">基本组件和布局</h1>
<h2 id="文本和按钮">文本和按钮</h2>
<h3 id="text">Text</h3>
<p>Text是最基本的一个组件，用来显示单一文本</p>
<p>Text组件由三部分组成，一是显示的内容，二是和显示格式有关的一系列参数，三是style参数，一般传入一个TextStyle对象控制字体格式</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Text(
  &#39;文本是视图系统中的常见控件，用来显示一段特定样式的字符串，就比如 Android 里的 TextView，或是 iOS 中的 UILabel。&#39;,
  textAlign: TextAlign.center,&#x2F;&#x2F; 居中显示
  style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20, color: Colors.red),&#x2F;&#x2F;20 号红色粗体展示
);</code></pre></div>
<h3 id="text.rich和textspan">Text.rich和TextSpan</h3>
<p>TextSpan主要用来解决切片显示的问题</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">TextStyle blackStyle &#x3D; TextStyle(fontWeight: FontWeight.normal, fontSize: 20, color: Colors.black); &#x2F;&#x2F; 黑色样式
 
TextStyle redStyle &#x3D; TextStyle(fontWeight: FontWeight.bold, fontSize: 20, color: Colors.red); &#x2F;&#x2F; 红色样式
 
Text.rich(
    TextSpan(
        children: &lt;TextSpan&gt;[
          TextSpan(text:&#39;文本是视图系统中常见的控件，它用来显示一段特定样式的字符串，类似&#39;, style: redStyle), &#x2F;&#x2F; 第 1 个片段，红色样式 
          TextSpan(text:&#39;Android&#39;, style: blackStyle), &#x2F;&#x2F; 第 1 个片段，黑色样式 
          TextSpan(text:&#39;中的&#39;, style:redStyle), &#x2F;&#x2F; 第 1 个片段，红色样式 
          TextSpan(text:&#39;TextView&#39;, style: blackStyle) &#x2F;&#x2F; 第 1 个片段，黑色样式 
        ]),
  textAlign: TextAlign.center,
);</code></pre></div>
<h3 id="button">Button</h3>
<p>Button有很多种，包括FloatingActionButton、ElevatedButton、RaisedButton和FlatButton等</p>
<p>一个Button组件主要包括两个属性，onPressed和child</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">FlatButton(
    color: Colors.yellow, &#x2F;&#x2F; 设置背景色为黄色
    shape:BeveledRectangleBorder(borderRadius: BorderRadius.circular(20.0)), &#x2F;&#x2F; 设置斜角矩形边框
    colorBrightness: Brightness.light, &#x2F;&#x2F; 确保文字按钮为深色
    onPressed: () &#x3D;&gt; print(&#39;FlatButton pressed&#39;), 
    child: Row(children: &lt;Widget&gt;[Icon(Icons.add), Text(&quot;Add&quot;)],)
)；</code></pre></div>
<p>除此之外，还有一个icon参数，能够方便的制作带图标的按钮</p>
<h2 id="图片和图标">图片和图标</h2>
<h3 id="image">Image</h3>
<p>Image控件有三个主要方式，分别是加载Asset资源<code>Image.asset('path')</code>、加载file资源<code>Image.file(new File('path'))</code>和网络图片<code>Image.network('URL')</code></p>
<p>除了可以根据图片的显示方式设置不同的图片源之外，图片的构造方法还提供了填充模式 fit、拉伸模式 centerSlice、重复模式 repeat 等属性，可以针对图片与目标区域的宽高比差异制定排版模式</p>
<h3 id="fadeinimage">FadeInImage</h3>
<p>FadeInImage 控件提供了图片占位的功能，并且支持在图片加载完成时淡入淡出的视觉效果。此外，由于 Image 支持 gif 格式，我们甚至还可以将一些炫酷的加载动画作为占位图。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">FadeInImage.assetNetwork(
  placeholder: &#39;assets&#x2F;loading.gif&#39;, &#x2F;&#x2F;gif 占位
  image: &#39;https:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;xxx.jpg&#39;,
  fit: BoxFit.cover, &#x2F;&#x2F; 图片拉伸模式
  width: 200,
  height: 200,
)</code></pre></div>
<h3 id="cachednetworkimage">CachedNetworkImage</h3>
<p>ImageCache 使用 LRU（Least Recently Used，最近最少使用）算法进行缓存更新策略，并且默认最多存储 1000 张图片，最大缓存限制为 100MB，当限定的空间已存满数据时，把最久没有被访问到的图片清除。图片<strong>缓存只会在运行期间生效，也就是只缓存在内存中</strong>。</p>
<p>如果想要支持缓存到文件系统，可以使用第三方的<a href="https://pub.dev/packages/cached_network_image/">CachedNetworkImage</a>控件。</p>
<p>CachedNetworkImage 的使用方法与 Image 类似，除了支持图片缓存外，还提供了比 FadeInImage 更为强大的加载过程占位与加载错误占位，可以支持比用图片占位更灵活的自定义控件占位。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">CachedNetworkImage(
        imageUrl: &quot;http:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;jpg&quot;,
        placeholder: (context, url) &#x3D;&gt; CircularProgressIndicator(),
        errorWidget: (context, url, error) &#x3D;&gt; Icon(Icons.error),
     )</code></pre></div>
<h2 id="对齐和定位">对齐和定位</h2>
<h2 id="可滚动组件">可滚动组件</h2>
<h3 id="listview">ListView</h3>
<p><strong>ListView 提供了一个默认构造函数 ListView</strong>，我们可以通过设置它的 children 参数，很方便地将所有的子 Widget 包含到 ListView 中。</p>
<p>ListTile 是 Flutter 提供的用于快速构建列表项元素的一个小组件单元，用于 1~3 行（leading、title、subtitle）展示文本、图标等视图元素的场景，通常与 ListView 配合使用。</p>
<p><strong>ListView 的另一个构造函数 ListView.builder，则适用于子 Widget 比较多的场景</strong>。这个构造函数有两个关键参数：</p>
<ul>
<li>itemBuilder，是列表项的创建方法。当列表滚动到相应位置时，ListView 会调用该方法创建对应的子 Widget。</li>
<li>itemCount，表示列表项的数量，如果为空，则表示 ListView 为无限列表。</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">ListView.builder(
    itemCount: 100, &#x2F;&#x2F; 元素个数
    itemExtent: 50.0, &#x2F;&#x2F; 列表项高度
    itemBuilder: (BuildContext context, int index) &#x3D;&gt; ListTile(title: Text(&quot;title $index&quot;), subtitle: Text(&quot;body $index&quot;))
);</code></pre></div>
<p>与 ListView.builder 抽离出了子 Widget 的构建方法类似，ListView.separated 抽离出了分割线的创建方法 separatorBuilder，以便根据 index 设置不同样式的分割线。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 使用 ListView.separated 设置分割线
ListView.separated(
    itemCount: 100,
    separatorBuilder: (BuildContext context, int index) &#x3D;&gt; index %2 &#x3D;&#x3D;0? Divider(color: Colors.green) : Divider(color: Colors.red),&#x2F;&#x2F;index 为偶数，创建绿色分割线；index 为奇数，则创建红色分割线
    itemBuilder: (BuildContext context, int index) &#x3D;&gt; ListTile(title: Text(&quot;title $index&quot;), subtitle: Text(&quot;body $index&quot;))&#x2F;&#x2F; 创建子 Widget
)</code></pre></div>
<h3 id="滚动嵌套">滚动嵌套</h3>
<p>Flutter 中有一个专门的控件 CustomScrollView，用来处理多个需要自定义滚动效果的 Widget。在 CustomScrollView 中，<strong>这些彼此独立的、可滚动的 Widget 被统称为 Sliver</strong>。</p>
<h2 id="线性布局使用row和column">线性布局——使用Row和Column</h2>
<h2 id="弹性布局源于web的flex">弹性布局——源于Web的Flex</h2>
<h2 id="流式布局不太清楚">流式布局——不太清楚</h2>
<h2 id="层叠布局不了解">层叠布局——不了解</h2>
<h1 id="功能性组件">功能性组件</h1>
<h2 id="进度指示器">进度指示器</h2>
<h2 id="输入框表单单选开关和复选框">输入框、表单、单选开关和复选框</h2>
<h3 id="textfiled组件">TextFiled组件</h3>
<p><code>TextField</code>组件提供了一个输入框，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Column(
  children: &lt;Widget&gt;[
    TextField(
      autofocus: true,
      decoration: InputDecoration(
        labelText: &quot;用户名&quot;,
        hintText: &quot;用户名或邮箱&quot;,
        prefixIcon: Icon(Icons.person)
      ),
    ),
    TextField(
      decoration: InputDecoration(
        labelText: &quot;密码&quot;,
        hintText: &quot;您的登录密码&quot;,
        prefixIcon: Icon(Icons.lock)
      ),
      obscureText: true,
    ),
  ],
);</code></pre></div>
<p>其具有的controller属性可以配置一个controller，用于文本的获取或控制光标位置、选择状态等。</p>
<p>controller可以用来直接获取输入内容，调用<code>.text()</code>方法即可。</p>
<p>可以对一个controller配置监听,当然，也可以通过<code>onChanged()</code>实现，例如</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@override
void initState() &#123;
  &#x2F;&#x2F;监听输入改变  
  _unameController.addListener(()&#123;
    print(_unameController.text);
  &#125;);
&#125;</code></pre></div>
<p><code>onChanged</code>是专门用于监听文本变化，而<code>controller</code>的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本，例如</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">_selectionController.text&#x3D;&quot;hello world!&quot;;
_selectionController.selection&#x3D;TextSelection(
    baseOffset: 2,
    extentOffset: _selectionController.text.length
);</code></pre></div>
<p>文本输入时的焦点可以通过<code>FocusNode</code>和<code>FocusScopeNode</code>来控制，<strong>默认情况下，焦点由<code>FocusScope</code>来管理</strong>，它代表焦点控制范围，可以在这个范围内可以通过<code>FocusScopeNode</code>在输入框之间移动焦点、设置默认焦点等。</p>
<p>我们可以通过<code>FocusScope.of(context)</code> 来获取Widget树中默认的<code>FocusScopeNode</code>。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class FocusTestRoute extends StatefulWidget &#123;
  @override
  _FocusTestRouteState createState() &#x3D;&gt; _FocusTestRouteState();
&#125;

class _FocusTestRouteState extends State&lt;FocusTestRoute&gt; &#123;
  FocusNode focusNode1 &#x3D; FocusNode();
  FocusNode focusNode2 &#x3D; FocusNode();
  FocusScopeNode? focusScopeNode;

  @override
  Widget build(BuildContext context) &#123;
    return Padding(
      padding: EdgeInsets.all(16.0),
      child: Column(
        children: &lt;Widget&gt;[
          TextField(
            autofocus: true, 
            focusNode: focusNode1,&#x2F;&#x2F;关联focusNode1
            decoration: InputDecoration(
                labelText: &quot;input1&quot;
            ),
          ),
          TextField(
            focusNode: focusNode2,&#x2F;&#x2F;关联focusNode2
            decoration: InputDecoration(
                labelText: &quot;input2&quot;
            ),
          ),
          Builder(builder: (ctx) &#123;
            return Column(
              children: &lt;Widget&gt;[
                ElevatedButton(
                  child: Text(&quot;移动焦点&quot;),
                  onPressed: () &#123;
                    &#x2F;&#x2F;将焦点从第一个TextField移到第二个TextField
                    &#x2F;&#x2F; 这是一种写法 FocusScope.of(context).requestFocus(focusNode2);
                    &#x2F;&#x2F; 这是第二种写法
                    if(null &#x3D;&#x3D; focusScopeNode)&#123;
                      focusScopeNode &#x3D; FocusScope.of(context);
                    &#125;
                    focusScopeNode.requestFocus(focusNode2);
                  &#125;,
                ),
                ElevatedButton(
                  child: Text(&quot;隐藏键盘&quot;),
                  onPressed: () &#123;
                    &#x2F;&#x2F; 当所有编辑框都失去焦点时键盘就会收起  
                    focusNode1.unfocus();
                    focusNode2.unfocus();
                  &#125;,
                ),
              ],
            );
          &#125;,
          ),
        ],
      ),
    );
  &#125;</code></pre></div>
<p>同样的，我们可以为<code>FocusNode</code>创建一个监听</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">...
&#x2F;&#x2F; 创建 focusNode   
FocusNode focusNode &#x3D; FocusNode();
...
&#x2F;&#x2F; focusNode绑定输入框   
TextField(focusNode: focusNode);
...
&#x2F;&#x2F; 监听焦点变化    
focusNode.addListener(()&#123;
   print(focusNode.hasFocus);
&#125;);</code></pre></div>
<h3 id="form组件">Form组件</h3>
<p>Flutter提供了一个<code>Form</code> 组件，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存</p>
<p><code>Form</code>的子孙元素必须是<code>FormField</code>类型，为了方便使用，Flutter 提供了一个<code>TextFormField</code>组件，它继承自<code>FormField</code>类，也是<code>TextField</code>的一个包装类，所以除了<code>FormField</code>定义的属性之外，它还包括<code>TextField</code>的属性</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:flutter&#x2F;material.dart&#39;;

class FormTestRoute extends StatefulWidget &#123;
  @override
  _FormTestRouteState createState() &#x3D;&gt; _FormTestRouteState();
&#125;

class _FormTestRouteState extends State&lt;FormTestRoute&gt; &#123;
  TextEditingController _unameController &#x3D; TextEditingController();
  TextEditingController _pwdController &#x3D; TextEditingController();
  GlobalKey _formKey &#x3D; GlobalKey&lt;FormState&gt;();

  @override
  Widget build(BuildContext context) &#123;
    return Form(
      key: _formKey, &#x2F;&#x2F;设置globalKey，用于后面获取FormState
      autovalidateMode: AutovalidateMode.onUserInteraction,
      child: Column(
        children: &lt;Widget&gt;[
          TextFormField(
            autofocus: true,
            controller: _unameController,
            decoration: InputDecoration(
              labelText: &quot;用户名&quot;,
              hintText: &quot;用户名或邮箱&quot;,
              icon: Icon(Icons.person),
            ),
            &#x2F;&#x2F; 校验用户名
            validator: (v) &#123;
              return v!.trim().isNotEmpty ? null : &quot;用户名不能为空&quot;;
            &#125;,
          ),
          TextFormField(
            controller: _pwdController,
            decoration: InputDecoration(
              labelText: &quot;密码&quot;,
              hintText: &quot;您的登录密码&quot;,
              icon: Icon(Icons.lock),
            ),
            obscureText: true,
            &#x2F;&#x2F;校验密码
            validator: (v) &#123;
              return v!.trim().length &gt; 5 ? null : &quot;密码不能少于6位&quot;;
            &#125;,
          ),
          &#x2F;&#x2F; 登录按钮
          Padding(
            padding: const EdgeInsets.only(top: 28.0),
            child: Row(
              children: &lt;Widget&gt;[
                Expanded(
                  child: ElevatedButton(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text(&quot;登录&quot;),
                    ),
                    onPressed: () &#123;
                      &#x2F;&#x2F; 通过_formKey.currentState 获取FormState后，
                      &#x2F;&#x2F; 调用validate()方法校验用户名密码是否合法，校验
                      &#x2F;&#x2F; 通过后再提交数据。
                      if ((_formKey.currentState as FormState).validate()) &#123;
                        &#x2F;&#x2F;验证通过提交数据
                      &#125;
                    &#125;,
                  ),
                ),
              ],
            ),
          )
        ],
      ),
    );
  &#125;
&#125;</code></pre></div>
<h3 id="switch组件">Switch组件</h3>
<p><code>Switch</code>组件提供了一个Material风格的单选开关。</p>
<p>他的状态由父组件进行管理</p>
<p>当<code>Switch</code>或<code>Checkbox</code>被点击时，会触发它们的<code>onChanged</code>回调，我们可以在此回调中处理选中状态改变逻辑</p>
<p>有一个<code>activeColor</code>属性，用于设置激活态的颜色</p>
<h3 id="checkbox组件">CheckBox组件</h3>
<p><code>CheckBox</code>大部分属性与<code>Switch</code>相同。</p>
<p><code>Checkbox</code>有一个属性<code>tristate</code> ，表示是否为<strong>三态</strong>，其默认值为<code>false</code> ，这时 Checkbox 有两种状态即“选中”和“不选中”，对应的 value 值为<code>true</code>和<code>false</code> ；如果<code>tristate</code>值为<code>true</code>时，value 的值会增加一个状态<code>null</code></p>
<h2 id="装饰相关的组件">装饰相关的组件</h2>
<h2 id="scaffold组件">Scaffold组件</h2>
<h2 id="大小适配相关的组件">大小适配相关的组件</h2>
<h1 id="路由和状态管理">路由和状态管理</h1>
<h2 id="数据共享和跨组件状态共享">数据共享和跨组件状态共享</h2>
<h2 id="路由管理">路由管理</h2>
<p>路由管理主要涉及到Route和Navigator两个类，Route是对页面的抽象，主要使用MaterialPageRoute建立路由模板。</p>
<p>MaterialPageRoute 是一种路由模板，定义了路由创建及切换过渡动画的相关配置，可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画。</p>
<p>Navigator负责维护一个Route栈。</p>
<h3 id="基本操作">基本操作</h3>
<p>使用<code>Navigator.push(context, NewRoute)</code>转到新page</p>
<p>使用<code>Navigator.pop()</code>移去栈顶的page</p>
<h3 id="命名路由">命名路由</h3>
<p>要想通过名字来指定页面切换，我们必须先给应用程序 MaterialApp 提供一个页面名称映射规则，即路由表 routes，这样 Flutter 才知道名字与页面 Widget 的对应关系。</p>
<p>路由表实际上是一个 Map，其中 key 值对应页面名字，而 value 值则是一个 WidgetBuilder 回调函数，我们需要在这个函数中创建对应的页面。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">MaterialApp(
    ...
    &#x2F;&#x2F; 注册路由
    routes:&#123;
      &quot;second_page&quot;:(context)&#x3D;&gt;SecondPage(),
    &#125;,
);
&#x2F;&#x2F; 使用名字打开页面
Navigator.pushNamed(context,&quot;second_page&quot;);</code></pre></div>
<p>对于一个潜在的空路由，我们考虑对用户进行友好的错误提示，比如跳转到一个统一的 NotFoundScreen 页面，也方便我们对这类错误进行统一收集、上报。因此，在注册路由表时，Flutter 提供了 UnknownRoute 属性，我们可以对未知的路由标识符进行统一的页面跳转处理。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">MaterialApp(
    ...
    &#x2F;&#x2F; 注册路由
    routes:&#123;
      &quot;second_page&quot;:(context)&#x3D;&gt;SecondPage(),
    &#125;,
    &#x2F;&#x2F; 错误路由处理，统一返回 UnknownPage
    onUnknownRoute: (RouteSettings setting) &#x3D;&gt; MaterialPageRoute(builder: (context) &#x3D;&gt; UnknownPage()),
);
 
&#x2F;&#x2F; 使用错误名字打开页面
Navigator.pushNamed(context,&quot;unknown_page&quot;);</code></pre></div>
<h3 id="页面参数的传递">页面参数的传递</h3>
<p>Flutter 提供了<strong>路由参数</strong>的机制，可以在打开路由时传递相关参数，在目标页面通过 RouteSettings 来获取页面参数</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 打开页面时传递字符串参数
Navigator.of(context).pushNamed(&quot;second_page&quot;, arguments: &quot;Hey&quot;);
 
class SecondPage extends StatelessWidget &#123;
  @override
  Widget build(BuildContext context) &#123;
    &#x2F;&#x2F; 取出路由参数
    String msg &#x3D; ModalRoute.of(context).settings.arguments as String;
    return Text(msg);
  &#125;
&#125;</code></pre></div>
<p>Flutter 也提供了<strong>返回参数</strong>的机制。在 push 目标页面时，可以设置目标页面关闭时监听函数，以获取返回参数；而目标页面可以在关闭路由时传递相关参数。</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class SecondPage extends StatelessWidget &#123;
  @override
  Widget build(BuildContext context) &#123;
    return Scaffold(
      body: Column(
        children: &lt;Widget&gt;[
          Text(&#39;Message from first screen: $msg&#39;),
          RaisedButton(
            child: Text(&#39;back&#39;),
            &#x2F;&#x2F; 页面关闭时传递参数
            onPressed: ()&#x3D;&gt; Navigator.pop(context,&quot;Hi&quot;)
          )
        ]
      ));
  &#125;
&#125;
 
class _FirstPageState extends State&lt;FirstPage&gt; &#123;
  String _msg&#x3D;&#39;&#39;;
  @override
  Widget build(BuildContext context) &#123;
    return new Scaffold(
      body: Column(children: &lt;Widget&gt;[
        RaisedButton(
            child: Text(&#39;命名路由（参数 &amp; 回调）&#39;),
            &#x2F;&#x2F; 打开页面，并监听页面关闭时传递的参数
            onPressed: ()&#x3D;&gt; Navigator.pushNamed(context, &quot;third_page&quot;,arguments: &quot;Hey&quot;).then((msg)&#x3D;&gt;setState(()&#x3D;&gt;_msg&#x3D;msg)),
        ),
        Text(&#39;Message from Second screen: $_msg&#39;),
 
      ],),
    );
  &#125;
&#125;</code></pre></div>
<h2 id="导航返回拦截">导航返回拦截</h2>
<h1 id="手势通知和动画">手势、通知和动画</h1>
<h2 id="手势的识别">手势的识别</h2>
<h2 id="通知">通知</h2>
<h1 id="网络">网络</h1>
<h2 id="http-client">HTTP Client</h2>
<h2 id="dio">Dio</h2>
<p>get方法示例</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void getRequest() async &#123;
  &#x2F;&#x2F; 创建网络调用示例
  Dio dio &#x3D; new Dio();
  
  &#x2F;&#x2F; 设置 URI 及请求 user-agent 后发起请求
  var response &#x3D; await dio.get(&quot;https:&#x2F;&#x2F;flutter.dev&quot;, options:Options(headers: &#123;&quot;user-agent&quot; : &quot;Custom-UA&quot;&#125;));
  
 &#x2F;&#x2F; 打印请求结果
  if(response.statusCode &#x3D;&#x3D; HttpStatus.ok) &#123;
    print(response.data.toString());
  &#125; else &#123;
    print(&quot;Error: $&#123;response.statusCode&#125;&quot;);
  &#125;
&#125;</code></pre></div>
<p>文件的上传下载</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 使用 FormData 表单构建待上传文件
FormData formData &#x3D; FormData.from(&#123;
  &quot;file1&quot;: UploadFileInfo(File(&quot;.&#x2F;file1.txt&quot;), &quot;file1.txt&quot;),
  &quot;file2&quot;: UploadFileInfo(File(&quot;.&#x2F;file2.txt&quot;), &quot;file1.txt&quot;),
 
&#125;);
&#x2F;&#x2F; 通过 post 方法发送至服务端
var responseY &#x3D; await dio.post(&quot;https:&#x2F;&#x2F;xxx.com&#x2F;upload&quot;, data: formData);
print(responseY.toString());
 
&#x2F;&#x2F; 使用 download 方法下载文件
dio.download(&quot;https:&#x2F;&#x2F;xxx.com&#x2F;file1&quot;, &quot;xx1.zip&quot;);
 
&#x2F;&#x2F; 增加下载进度回调函数
dio.download(&quot;https:&#x2F;&#x2F;xxx.com&#x2F;file1&quot;, &quot;xx2.zip&quot;, onReceiveProgress: (count, total) &#123;
	&#x2F;&#x2F;do something      
&#125;);</code></pre></div>
<p>使用拦截器添加Token、User-Agent等参数</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 增加拦截器
dio.interceptors.add(InterceptorsWrapper(
    onRequest: (RequestOptions options)&#123;
      &#x2F;&#x2F; 为每个请求头都增加 user-agent
      options.headers[&quot;user-agent&quot;] &#x3D; &quot;Custom-UA&quot;;
      &#x2F;&#x2F; 检查是否有 token，没有则直接报错
      if(options.headers[&#39;token&#39;] &#x3D;&#x3D; null) &#123;
        return dio.reject(&quot;Error: 请先登录 &quot;);
      &#125; 
      &#x2F;&#x2F; 检查缓存是否有数据
      if(options.uri &#x3D;&#x3D; Uri.parse(&#39;http:&#x2F;&#x2F;xxx.com&#x2F;file1&#39;)) &#123;
        return dio.resolve(&quot; 返回缓存数据 &quot;);
      &#125;
      &#x2F;&#x2F; 放行请求
      return options;
    &#125;
));
 
&#x2F;&#x2F; 增加 try catch，防止请求报错
try &#123;
  var response &#x3D; await dio.get(&quot;https:&#x2F;&#x2F;xxx.com&#x2F;xxx.zip&quot;);
  print(response.data.toString());
&#125;catch(e) &#123;
  print(e);
&#125;</code></pre></div>
<h2 id="json的解析">JSON的解析</h2>
<h3 id="bean的编写">Bean的编写</h3>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class User &#123;
  final String name;
  final String email;

  User(this.name, this.email);

  User.fromJson(Map&lt;String, dynamic&gt; json)
      : name &#x3D; json[&#39;name&#39;],
        email &#x3D; json[&#39;email&#39;];

  Map&lt;String, dynamic&gt; toJson() &#x3D;&gt;
    &lt;String, dynamic&gt;&#123;
      &#39;name&#39;: name,
      &#39;email&#39;: email,
    &#125;;
&#125;</code></pre></div>
<p>需要关注的有两个方法，<code>.fromJson</code>和<code>.toJson()</code></p>
<h3 id="jsonserializable自动生成model">JsonSerializable自动生成Model</h3>
<blockquote>
<p><code>json_serializable package</code>是一个自动化的源代码生成器，可以在开发阶段为我们生成 JSON 序列化模板，这样一来，由于序列化代码不再由我们手写和维护，我们将运行时产生 JSON 序列化异常的风险降至最低</p>
</blockquote>
<p>使用它需要调用如下两个开发依赖项</p>
<div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">dependencies:
  json_annotation: &lt;最新版本&gt;

dev_dependencies:
  build_runner: &lt;最新版本&gt;
  json_serializable: &lt;最新版本&gt;</code></pre></div>
<p>Bean文件的声明</p>
<div class="code-wrapper"><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:json_annotation&#x2F;json_annotation.dart&#39;;

&#x2F;&#x2F; user.g.dart 将在我们运行生成命令后自动生成
part &#39;user.g.dart&#39;;

&#x2F;&#x2F;&#x2F;这个标注是告诉生成器，这个类是需要生成Model类的
@JsonSerializable()

class User&#123;
  User(this.name, this.email);

  String name;
  String email;
  &#x2F;&#x2F;不同的类使用不同的mixin即可
  factory User.fromJson(Map&lt;String, dynamic&gt; json) &#x3D;&gt; _$UserFromJson(json);
  Map&lt;String, dynamic&gt; toJson() &#x3D;&gt; _$UserToJson(this);  
&#125;</code></pre></div>
<p>在配置好后，并不会得到对应的bean，一种方案是通过<code>flutter packages pub run build_runner watch</code>在项目根目录下运行来启动_watcher_。只需启动一次观察器，然后它就会在后台运行，这是安全的</p>
<h3 id="自动化脚本">自动化脚本</h3>
<h2 id="网络的封装">网络的封装</h2>
<h1 id="数据存储">数据存储</h1>
<h2 id="文件存储">文件存储</h2>
<h2 id="shared-preference">Shared Preference</h2>
<h2 id="本地数据库">本地数据库</h2>
<h1 id="多平台适配">多平台适配</h1>
<h2 id="platformchannel">PlatformChannel</h2>
<h2 id="windows">Windows</h2>
<h2 id="android">Android</h2>
<h1 id="常用功能的实现">常用功能的实现</h1>
<h2 id="摄像头和相册的调用">摄像头和相册的调用</h2>
<h2 id="主题系统">主题系统</h2>
<h2 id="多语言">多语言</h2>
<h2 id="自动登录">自动登录</h2>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用记录</title>
    <url>/blog/posts/472738e0/</url>
    <content><![CDATA[<h2 id="文章加密">文章加密</h2>
<blockquote>
<p>https://github.com/edolphin-ydf/hexo-encrypt</p>
<p>https://blog.bill.moe/encrypt/</p>
</blockquote>
<h2 id="数学公式的支持">数学公式的支持</h2>
<blockquote>
<p>https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md</p>
</blockquote>
<h2 id="不能兼容双大括号">不能兼容双大括号</h2>
<blockquote>
<p>http://xcoding.tech/2020/01/18/hexo/如何从根本解决hexo不兼容%7B%7B%7D%7D标签问题/</p>
</blockquote>
<h2 id="next主题开启文章目录">NEXT主题开启文章目录</h2>
<blockquote>
<p>https://wugenqiang.github.io/articles/hexo-do-catalog.html</p>
</blockquote>
<h2 id="插入文档链接hexo-addlink">插入文档链接(hexo-addlink)</h2>
<blockquote>
<p>https://www.mdslq.cn/archives/fcf53e2f.html</p>
</blockquote>
<h2 id="搜索">搜索</h2>
<blockquote>
<p>https://www.barretlee.com/blog/2017/06/04/hexo-search-insite/</p>
<p>https://cloud.tencent.com/developer/article/1381382?from=article.detail.1624646</p>
</blockquote>
<h2 id="萌妹">萌妹</h2>
<blockquote>
<p>https://github.com/EYHN/hexo-helper-live2d</p>
</blockquote>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Java知识点总结</title>
    <url>/blog/posts/d842f132/</url>
    <content><![CDATA[<h2 id="特点">特点</h2>
<ol type="1">
<li><p>Java源程序和源文件中的字母都大小写敏感</p></li>
<li><p>Unicode编码每个Unicode码占用16bits(2bytes)</p></li>
<li><p><strong>数组也是对象</strong></p></li>
<li><p>如果Java源文件中包含了多个类，那么用编译器javac编译完源文件后将生成多个扩展名为.class的文件。</p></li>
<li><p>一个Java源文件中可以有多个类，但只能有一个类是public的</p></li>
</ol>
<blockquote>
<p>1.每个编译单元（文件）都只能有一个public类，这表示，每个编译单元都有<strong>单一的公共接口</strong>，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出错误信息。 2.public类的名称必须完全<strong>与含有该编译单元的文件名相同</strong>，包含大小写。如果不匹配，同样将得到编译错误。 3.虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。</p>
</blockquote>
<ol start="6" type="1">
<li>类（如：System、Scanner、String），它们都是一种数据类型。</li>
<li>在Java中，负责对字节代码解释执行的是JVM</li>
<li>Java有三种注释形式，其中/**content/形式可以使用javadoc直接生成外部的注释文档</li>
<li>If this source code is contained in a file called SmallProg.java, what command should be used to compile it using the JDK?：<strong>javac SmallProg</strong></li>
</ol>
<h3 id="java关键字">Java关键字</h3>
<ol type="1">
<li><p>两个关键字</p>
<table>
<thead>
<tr class="header">
<th>保留字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>goto</td>
<td>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令。</td>
</tr>
<tr class="even">
<td>const</td>
<td>用于修改字段或局部变量的声明。它指定字段或局部变量的值是常数，不能被修改</td>
</tr>
</tbody>
</table></li>
<li><p>权限控制</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public</td>
<td></td>
</tr>
<tr class="even">
<td>protected</td>
<td></td>
</tr>
<tr class="odd">
<td>private</td>
<td>不能用来声明类</td>
</tr>
<tr class="even">
<td>default</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>https://stackoverflow.com/questions/2534733/java-protected-classes https://www.codenong.com/3869556/</p>
</blockquote></li>
<li><p>定义与实例化</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>class</td>
<td>包含方法体和具体实现，public类名要和文件名保持一致</td>
</tr>
<tr class="even">
<td>interface</td>
<td>仅含有方法体，没有具体实现</td>
</tr>
<tr class="odd">
<td>abstract</td>
<td></td>
</tr>
<tr class="even">
<td>implements</td>
<td>对接interface实现方法体</td>
</tr>
<tr class="odd">
<td>extends</td>
<td></td>
</tr>
<tr class="even">
<td>new</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>包</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>import</td>
<td></td>
</tr>
<tr class="even">
<td>package</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>数据类型</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte</td>
<td>8bit</td>
</tr>
<tr class="even">
<td>char</td>
<td>16bit（Unicode）</td>
</tr>
<tr class="odd">
<td>boolean</td>
<td></td>
</tr>
<tr class="even">
<td>short</td>
<td>16bit</td>
</tr>
<tr class="odd">
<td>int</td>
<td>32bit</td>
</tr>
<tr class="even">
<td>float</td>
<td>32bit（注意声明时附加f/F）</td>
</tr>
<tr class="odd">
<td>long</td>
<td>64bit</td>
</tr>
<tr class="even">
<td>double</td>
<td>64bit</td>
</tr>
<tr class="odd">
<td>void</td>
<td></td>
</tr>
<tr class="even">
<td>null</td>
<td></td>
</tr>
<tr class="odd">
<td>true</td>
<td></td>
</tr>
<tr class="even">
<td>false</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>流程控制</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>if</td>
<td></td>
</tr>
<tr class="even">
<td>else</td>
<td></td>
</tr>
<tr class="odd">
<td>while</td>
<td></td>
</tr>
<tr class="even">
<td>for</td>
<td></td>
</tr>
<tr class="odd">
<td>switch</td>
<td></td>
</tr>
<tr class="even">
<td>case</td>
<td></td>
</tr>
<tr class="odd">
<td>default</td>
<td></td>
</tr>
<tr class="even">
<td>do</td>
<td></td>
</tr>
<tr class="odd">
<td>break</td>
<td></td>
</tr>
<tr class="even">
<td>continue</td>
<td></td>
</tr>
<tr class="odd">
<td>return</td>
<td></td>
</tr>
<tr class="even">
<td>instanceof</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>修饰符</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>static</td>
<td>只有内部类可以使用static关键字修饰，调用直接使用类名.内部类类名进行调用。可以修饰成员变量为全局静态成员变量（class variable）</td>
</tr>
<tr class="even">
<td>final</td>
<td>final修饰的类是不能被继承的 ，final修饰的方法是不能被子类重写。</td>
</tr>
<tr class="odd">
<td>super</td>
<td>调用父类的方法</td>
</tr>
<tr class="even">
<td>this</td>
<td>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</td>
</tr>
<tr class="odd">
<td>native</td>
<td></td>
</tr>
<tr class="even">
<td>stricfp</td>
<td></td>
</tr>
<tr class="odd">
<td>synchronized</td>
<td></td>
</tr>
<tr class="even">
<td>transient</td>
<td></td>
</tr>
<tr class="odd">
<td>volatile</td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>异常处理</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>catch</td>
<td></td>
</tr>
<tr class="even">
<td>try</td>
<td>捕获异常</td>
</tr>
<tr class="odd">
<td>finally</td>
<td></td>
</tr>
<tr class="even">
<td>throw</td>
<td>执行抛出异常的动作</td>
</tr>
<tr class="odd">
<td>throws</td>
<td>将异常抛给调用者，自己不进行管理</td>
</tr>
</tbody>
</table></li>
<li><p>其他</p>
<table>
<thead>
<tr class="header">
<th>关键字</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>enum</td>
<td></td>
</tr>
<tr class="even">
<td>assert</td>
<td></td>
</tr>
</tbody>
</table></li>
</ol>
<blockquote>
<p>https://blog.csdn.net/sdujava2011/article/details/71404165</p>
</blockquote>
<h2 id="数据类型和数组">数据类型和数组</h2>
<ol type="1">
<li>程序运行中不可以改变数组的大小。</li>
<li>Java允许创建不规则数组，即Java多维数组中各行的列数可以不同。</li>
</ol>
<blockquote>
<p>https://blog.nowcoder.net/n/110dd0ea457949eab99ad0f0fe7477b5</p>
</blockquote>
<ol start="3" type="1">
<li>boolean型数据的值只有true和false</li>
<li>Java语言对语法要求严格，局部变量只有在定义、赋初值后才能访问。<strong>局部变量没有默认值</strong>，所以局部变量被声明后，必须经过初始化，才可以使用</li>
</ol>
<blockquote>
<p>https://www.runoob.com/java/java-variable-types.html</p>
</blockquote>
<ol start="5" type="1">
<li>Java中，boolean基本类型的变量不能取值为0/1</li>
<li>由低精度的数据类型向高精度的数据类型赋值时，是自动类型转换，其数值不变</li>
<li>After the declaration: char[] c = new char[100]; the value of c[50]：'032'</li>
<li><strong>boolean类型不能为null</strong>，且不能和其他基本数据类型互转</li>
<li>Java默认所有浮点型数据都是double，必须通过f/F强制声明float <em>（奢侈啊奢侈）</em></li>
<li>枚举变量必须要定义在类层次上，被认为是一个安全的类型</li>
</ol>
<blockquote>
<p>枚举型变量是一种特殊的类，枚举型变量是对象变量。每个枚举值被保存为对应的整型数 存在相关的几个方法，ordinal()返回与该枚举值关联的序数值，name()返回枚举值的名称</p>
</blockquote>
<ol start="11" type="1">
<li><p>Java中数组时引用数据类型，而String是对象，所以对于数组只需要用<strong>.length调用数据类型的length属性</strong>，但String需要调用.length()方法</p></li>
<li><p>Java提供了包装器类（wrapperClass）进行基本数据类型的包装</p></li>
<li><p>Java没有unsigned标识符</p></li>
<li><p>Why do variables declared in a class have default values, but the variables declared inside methods, said to be "local variables", don't have default values in Java?</p>
<blockquote>
<p>All <strong>member variable have to load into heap</strong> so they have to initialized with default values when an instance of class is created. In case of local variables, they don't get loaded into heap they are stored in stack until they are being used before java 7, so we need to explicitly initialize them. Now the "Java Hotspot Server Compiler" performs "escape analysis" and decides to allocate some variables on the stack instead of the heap.</p>
<p>Variables declared in methods and in blocks are called local variables. Local variable are not initialized when they are created at method invocation. Therefore, a local variable must be initialized explicitly before being used. Otherwise the compiler will flag it as error when the containing method or block is executed.</p>
</blockquote></li>
</ol>
<h2 id="运算符">运算符</h2>
<ol type="1">
<li>关于短路运算符</li>
<li>注意自增运算符的前后置，但是利用这个特性写代码会被杀</li>
<li>注意优先级上逻辑非&gt;逻辑与&gt;逻辑或</li>
<li>==是Java的一个关系运算符，它的作用是判断两者是否相等，具体的作用方式是<strong>直接判断值</strong>是否相等。</li>
</ol>
<blockquote>
<p>对于基本数据类型来说，由于基本数据类型变量存储的都是原始值，==在判断变量是否相等时也是<strong>直接比较变量的值</strong>，所以如果基本变量的原始值相同，那么这两个变量使用==判断就输出true 对于引用数据类型，也可以使用”==“来判断，由于引用数据类型变量存储的是引用对象的地址，所以使用==来比较两个引用数据类型变量，实际上是在<strong>比较这两个引用变量是否引用了同一个对象</strong></p>
</blockquote>
<ol start="3" type="1">
<li>对于private修饰符，其修饰的都是Class层次的内容，比如method和class parameter、instance parameter</li>
</ol>
<h3 id="转义序列">转义序列</h3>
<table>
<thead>
<tr class="header">
<th>转义序列</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td> 退格符</td>
<td></td>
</tr>
<tr class="even">
<td> 制表符</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>换行符</td>
</tr>
<tr class="even">
<td> 回车符</td>
<td></td>
</tr>
<tr class="odd">
<td>\'</td>
<td></td>
</tr>
<tr class="even">
<td>\"</td>
<td></td>
</tr>
<tr class="odd">
<td>\</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="流程控制">流程控制</h2>
<h2 id="类与对象">类与对象</h2>
<ol type="1">
<li>Java只支持类之间的单继承，但是可以使用接口来实现多继承</li>
<li>声明对象引用变量是在stack存储一个地址，初始值为null。在stack中查找速度快。new关键字能够在heap中开辟对应的内存空间，并将地址交给某个对象引用变量。</li>
</ol>
<blockquote>
<p>https://www.jianshu.com/p/39c6ecc1b184 https://zhuanlan.zhihu.com/p/53846258</p>
</blockquote>
<ol start="3" type="1">
<li><p>特别的，Java对String特殊处理。</p></li>
<li><p>memory space for a <strong>static variable</strong> is created when the class is first created</p></li>
<li><p>static methods can't reference the instance variables</p></li>
</ol>
<h3 id="关于static关键字">关于static关键字</h3>
<blockquote>
<p>动态是指Java程序在JVM上运行时，JVM会根据程序的需要动态创建对象并存储对象(分配内存)，对象使命结束后，对象会被垃圾回收器销毁，即内存回收由JVM统一管理并分配给其他新创建的对象；静态是指Java程序还没有运行时，<strong>JVM就会为加载的类分配空间存储被static关键字修饰的内容</strong>；如静态成员变量，Java类加载到JVM中，JVM会把类以及类的静态成员变量存储在方法区，我们知道<strong>方法区是线程共享且很少发生GC的区域</strong>，所以被<strong>static关键字修饰的内容都是全局共享</strong>的，且只会为其分配一次存储空间。</p>
</blockquote>
<ol type="1">
<li>修饰静态代码块</li>
</ol>
<ul>
<li><p>静态代码块是当Java类加载到JVM内存中而执行的代码块，由于类的加载在JVM运行期间只会发生一次，所以静态代码块也只会执行一次。</p></li>
<li><p>静态代码块的主要作用是用来进行一些<strong>复杂的初始化工作</strong>，所以静态代码块跟随类存储在方法区的表现形式是静态代码块执行的结果存储在方法区，即初始化量存储在方法区并被线程共享。</p>
<ol start="2" type="1">
<li>修饰成员变量</li>
</ol>
<ul>
<li>静态变量存储在类的信息中，且可以在线程间共享，那么它当然也属于该类的每个对象，因此可以通过对象访问静态变量，但编译器并不支持这么做，且会给出警告。</li>
<li>一个类的静态变量和该类的静态代码块的加载顺序。类会优先加载静态变量，然后加载静态代码块，但有多个静态变量和多个代码块时，会按照编写的顺序进行加载。</li>
<li>静态变量可以不用显式的初始化，JVM会默认给其相应的默认值。</li>
<li>静态变量既然是JVM内存中共享的且可以改变，那么对它的访问会引起线程安全问题。如果能确保静态变量不可变，那么可以用final关键字一起使用避免线程安全问题；否则需要采用同步的方式避免线程安全问题，如与volatile关键字一起使用等。</li>
<li>static关键不能修饰局部变量，包括实例方法和静态方法，不然就会与static关键字的初衷-共享相违背。</li>
</ul>
<ol start="3" type="1">
<li>修饰静态方法</li>
</ol>
<ul>
<li>main方法被Java规范定义成Java类的主入口。Java类的运行都由main方法开启（既然类的实例方法需要对象调用才能访问，而静态方法直接通过类名就能访问，那么在不考虑部署服务器的情况下，一个类是如何开始执行的呢？最大的可能就是通过“类名.静态方法”启动Java，而我定义那么多静态方法，JVM又是如何知道主入口呢？）</li>
<li>static关键字本身的含义就是共享，而Java类加载到JVM内存的方法区，也是线程共享的，所以没必要用static关键字修饰普通类。</li>
</ul>
<ol start="4" type="1">
<li>问题</li>
</ol>
<ul>
<li>封装是Java类的三大特性之一，也是面向对象的主要特性。因为不需要通过对象，而直接通过类就能访问类的属性和方法，这有点破坏类的封装性；所以除了Utils类，代码中应该尽量少用static关键字修饰变量和方法。 &gt; https://zhuanlan.zhihu.com/p/73704288</li>
</ul></li>
<li><p>Java类的初始化顺序</p>
<p><strong>静态变量 -&gt; 静态初始化块</strong> -&gt; 变量 -&gt; 初始化块 -&gt; <strong>构造方法</strong></p>
<blockquote>
<p>https://blog.csdn.net/caomiao2006/article/details/51533382</p>
</blockquote></li>
</ul>
<h3 id="抽象类">抽象类</h3>
<ul>
<li><p>并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p></li>
<li><p>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象 &gt; 比如，在一个图形编辑软件的分析设计过程中，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域并不是直接存在的，它就是一个抽象概念。而正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。</p></li>
<li><p>比较</p>
<ol type="1">
<li><p>与具体类比较 &gt; 抽象类不能直接实例化，并且对抽象类使用 new 运算符会导致编译时错误。虽然一些变量和值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为 null，或者含有对非抽象类的实例的引用（此非抽象类是从抽象类派生的）。 允许（但不要求）抽象类包含抽象成员。 抽象类不能被密封。</p></li>
<li><p>与接口比较 &gt; 抽象类表示该类中可能已经有一些方法的具体定义，但是接口就仅仅只能定义各个方法的界面（方法名，参数列表，返回类型），并不关心具体细节。 接口是引用类型的，和抽象类的相似之处有三点：</p></li>
<li><p>不能实例化；</p></li>
<li><p>包含未实现的方法声明；</p></li>
<li><p>派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员).</p></li>
</ol></li>
</ul>
<blockquote>
<p>抽象类与接口紧密相关。然而接口又比抽象类更抽象，这主要体现在它们的差别上：</p>
<p>类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承，从抽象类派生的类仍可实现接口，从而得出接口是用来解决多重继承问题的。</p>
<p>抽象类当中可以存在非抽象的方法，可接口不能，且它里面的方法只是一个声明必须用public来修饰没有具体实现的方法。</p>
<p>抽象类中的成员变量可以被不同的修饰符来修饰，可接口中的成员变量默认的都是静态常量（static final）。</p>
</blockquote>
<ul>
<li>抽象类是对象的抽象，然而接口是一种行为规范。</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li><p>继承的方式</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwp5rhpd7ej30id0ingmy.jpg" alt="java-extends-2020-12-08" /><figcaption aria-hidden="true">java-extends-2020-12-08</figcaption>
</figure>
<ul>
<li><p>两种继承关键字</p>
<ol type="1">
<li><p>Extends：在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p></li>
<li><p>implements：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p></li>
</ol></li>
</ul></li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface A &#123;
  public void eat();    
  public void sleep(); 
&#125;  

public interface B &#123;    
  public void show(); 
&#125;  

public class C implements A,B &#123; 
&#125;</code></pre></div>
<ul>
<li>构造方法
<ul>
<li>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</li>
<li>如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中<strong>显式地通过 super 关键字调用父类的构造器并配以适当的参数列表</strong>。</li>
<li>如果父类构造器没有参数，则在子类的构造器中<strong>不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器</strong>。</li>
</ul></li>
</ul>
<h3 id="重载overload">重载OverLoad</h3>
<p>重载（Overload）是让类以统一的方式处理不同类型数据的一种手段，实质表现就是<strong>多个具有不同的参数个数或者类型的同名函数</strong>（返回值类型可随意，<strong>不能以返回类型作为重载函数的区分标准</strong>）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时通过传递不同参数个数和参数类型来决定具体使用哪个方法的多态性）</p>
<h3 id="重写override">重写OverRide</h3>
<p>重写（Override）是父类与子类之间的多态性，实质是<strong>对父类的函数进行重新定义</strong>，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，不过子类函数的访问修饰权限不能小于父类的；若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。</p>
<h2 id="oop">OOP</h2>
<h3 id="接口interface">(接口)Interface</h3>
<ol type="1">
<li>实现接口的类需要对接口中所有方法进行定义</li>
</ol>
<h3 id="多态">多态</h3>
<h3 id="封装">封装</h3>
<h2 id="多线程">多线程</h2>
<ol type="1">
<li>Java是多线程的，它必须由Thread类或它的子类来创建</li>
</ol>
<h2 id="异常处理">异常处理</h2>
<h2 id="递归">递归</h2>
<h2 id="应试">应试</h2>
<h3 id="计算机系统概述">计算机系统概述</h3>
<ul>
<li>java编译过程：.java(raw code) -&gt; .class(byte code,run on JVM) -&gt; Runing</li>
<li>三种错误类型
<ul>
<li>编译错误(Syntax error)</li>
<li>运行错误(Run-time errror)</li>
<li>逻辑错误(Logic error)</li>
</ul></li>
<li>JDK(Java Development Kit)是oracle提供的Java开发工具，运行Java程序只需要JRE(Java Running Environment)</li>
</ul>
<h3 id="数据与表达式">数据与表达式</h3>
<ul>
<li>命名规则</li>
<li>保留关键字</li>
<li>省略赋值运算符和自增自减运算符</li>
<li>常用进制的写法</li>
<li>类型转换</li>
<li>运算符和优先级</li>
</ul>
<h3 id="使用类和对象">使用类和对象</h3>
<h2 id="常用类库及方法表">常用类库及方法表</h2>
<h3 id="scanner">Scanner</h3>
<ul>
<li>属于Java API</li>
<li>有三种构造方法，分别用于IOStream、File&amp;String Resource</li>
<li>.next()和.nextLine()</li>
<li>读取输入数</li>
<li>迭代器</li>
<li></li>
</ul>
<blockquote>
<p>https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html</p>
</blockquote>
<h3 id="string">String</h3>
<h3 id="random">Random</h3>
<h3 id="math">Math</h3>
<ul>
<li>所有方法都是静态方法</li>
</ul>
<h3 id="numberformat">NumberFormat</h3>
<h3 id="decimalformat">DecimalFormat</h3>
<h3 id="integerwrapper">Integer（Wrapper）</h3>
<blockquote>
<p>https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java课程设计实验报告</title>
    <url>/blog/posts/38741/</url>
    <content><![CDATA[<h1 id="java课程设计实验报告">Java课程设计实验报告</h1>
<h2 id="系统总体要求">系统总体要求</h2>
<h3 id="实验目的">实验目的</h3>
<p>锻炼学生使用高级程序设计语言进行面向对象的分析、设计和应用开发能力，结合JavaIO流技术、Spring相关框架、数据库技术、网络技术与Web前端开发技术等实现一个综合性的应用框架。</p>
<h3 id="硬件环境">硬件环境</h3>
<ul>
<li>PC：Ryzen7 5800H，16G</li>
<li>Mac：M1 Silicon</li>
<li>阿里ECS</li>
<li>阿里云RDS MySQL</li>
<li>阿里云Redis</li>
</ul>
<h3 id="软件环境">软件环境</h3>
<ul>
<li>操作系统：Windows10 Professional，Windows11，Ubuntu 18.04，MacOS Monterey</li>
<li>开发工具：IDEA，VIsual Studio Code，OpenJDK，WebStorm，npm，nrm，Maven，[Android Studio，Flutter SDK]</li>
<li>数据服务：MySQL，SQLite，Redis</li>
<li>数据设计：Navicat，DataGrip，Another Redis Desktop Manager</li>
<li>版本控制：Git</li>
<li>后端框架：Spring，Spring Boot，Spring Data JPA</li>
<li>Web服务：Nginx</li>
</ul>
<h2 id="系统总体要求-1">系统总体要求</h2>
<h3 id="系统总功能要求">系统总功能要求</h3>
<p>本次设计要求利用Java实现一个学生信息管理平台（PC版，应用于校内网有线网络访问，暂不开发移动端）。主要功能为</p>
<ol type="1">
<li>学生基本信息、联系方式、入学前信息、家庭信息、社会关系等基本信息的管理。</li>
<li>学习信息管理，包括课程基本信息，课程中心（教材、课件、参考资料等）选课信息、考勤信息、作业信息、成绩信息等。</li>
<li>学生社会实践、学科竞赛、科技成果、培训讲座、创新项目、校外实习等创新实践信息管理。</li>
<li>学生荣誉信息管理，包括获得的各种称号奖励等。</li>
<li>学生体育活动、外出旅游、文艺演出、聚会、等日常活动管理。</li>
<li>学生外出请假信息和生活学习消费等日志信息管理。</li>
<li>学生个人信息的统计汇入统计数据库。</li>
<li>学生各种信息的查询统计、综合绩分的计算（可自行设计公式）和学生个人画像、个人简历的生成打印。</li>
</ol>
<p>（所谓信息管理就是信息的CRUD——创建添加，读取查询，更新修改，删除）</p>
<h3 id="开发平台介绍">开发平台介绍</h3>
<h4 id="idea">IDEA</h4>
<h4 id="visual-studio-code">Visual Studio Code</h4>
<h3 id="开发进度表">开发进度表</h3>
<h3 id="小组成员分工表">小组成员分工表</h3>
<blockquote>
<p>以下按照姓名首字母排序</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>姓名</th>
<th>工作内容</th>
<th>成绩比重</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>郭苏睿</td>
<td>编写选课功能</br>实现各个科目的成绩计算、绩点计算和排名业务</br>设计系统架构，提供实现思路，规范编码风格</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>何硕</td>
<td>编写日常信息和部分选课信息模块，实现增删改查功能</br>维护版本库，编写开发文档和版本修改记录</br>实现简历功能</td>
<td>1.0</td>
</tr>
<tr class="odd">
<td>胡钊</td>
<td>编写学生基本信息和课程信息模块，实现增删改查功能</br>设计接口，编写开发文档</br>优化编码风格，添加部分异常的捕获</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>吕俊安</td>
<td>调整业务细节，优化算法提高运算速度降低资源占用</br>编写单元测试、集成测试，排查系统漏洞和逻辑缺陷</br>测试系统性能。添加部分异常的捕获</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<h2 id="需求分析">需求分析</h2>
<h3 id="需求简述">需求简述</h3>
<p>对于山东大学来讲，现有在校教职工数量众多，其中学生的学习、生活会产生大量信息，对于学生方和校方都存在学生信息管理系统的迫切需求。</p>
<h4 id="价值评估">价值评估</h4>
<p>该需求有较大的现实意义，能够有效简化教师、学生获取相关信息的效率，同时可以提供大量数据供后期分析，帮助学校改善提高教学质量，更好服务学生；协助同学们更清晰的了解自己学习和生活状况。</p>
<p>从技术角度来讲，本需求实现难度尚可，在前后端分离的条件下基本符合现代主流Web开发模式。且其子需求的实现均属于常见功能，并无太多需要集中研究的开发问题。</p>
<p>综合评估，本需求的价值满足产品上线条件。</p>
<h3 id="作品说明">作品说明</h3>
<ul>
<li>作品定位：面向所有山东大学师生</li>
<li>作品综述</li>
</ul>
<table>
<thead>
<tr class="header">
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作品名称</td>
<td>学生信息管理系统</td>
</tr>
<tr class="even">
<td>作品定位</td>
<td>提高师生在校学习生活便利性</td>
</tr>
<tr class="odd">
<td>作品特色</td>
<td>1. 内容覆盖全面<br>2.系统运行稳定性良好<br>3.具有较高的工作效率和性能<br>4.可拓展性良好</td>
</tr>
<tr class="even">
<td>目标人群</td>
<td>山东大学全体师生</td>
</tr>
</tbody>
</table>
<h3 id="需求描述">需求描述</h3>
<h4 id="功能性需求">功能性需求</h4>
<ol type="1">
<li>作品设计的内容应当覆盖学生日常生活的方方面面，充分反映学习生活</li>
<li>部分功能对教师和学生两类用户进行分离</li>
<li>作品可以提供所有信息的增删改查</li>
<li>提供检索和快速筛选的功能，方便快速找到目标条目</li>
<li>作品基于部分数据可以描绘学生的画像</li>
<li>提供对系统运行状况的监控，对数据空间告急等情况及时警告提示</li>
</ol>
<h4 id="非功能性需求">非功能性需求</h4>
<ol type="1">
<li>作品应当有良好的UI，并提供多端入口，包括但不限于Web、桌面客户端、Android和iOS等</li>
<li>作品对数据有分析统计的能力</li>
<li>作品对部分频繁读取数据提供缓存缓解服务器运算和数据库读写压力</li>
</ol>
<h4 id="功能权限">功能权限</h4>
<ol type="1">
<li>系统提供对学生和教师的权限分离</li>
<li>系统保留对权限的延伸能力</li>
</ol>
<h4 id="数据维护需求">数据维护需求</h4>
<ol type="1">
<li>系统保证关联数据的正确删除，避免残留数据</li>
<li>维护数据表关系</li>
</ol>
<h3 id="需求视图">需求视图</h3>
<h4 id="功能流程图">功能流程图</h4>
<p>此处为登录页</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2802p95bij21kg0u0wfd.jpg" alt="image-20220514161222178" /><figcaption aria-hidden="true">image-20220514161222178</figcaption>
</figure>
<p>这里展示对于学生新的增删改查，首先是入口页面，提供了滑动浏览的能力；一般展示模块摘要、检索功能和数据三个卡片</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2803dbi0qj21kq0u0af2.jpg" alt="image-20220514161303192" /><figcaption aria-hidden="true">image-20220514161303192</figcaption>
</figure>
<p>检索功能支持分类型搜索，可以通过下拉菜单选择，有模糊匹配能力</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2804tn8koj20v408274q.jpg" alt="image-20220514161427104" /><figcaption aria-hidden="true">image-20220514161427104</figcaption>
</figure>
<p>对于超出长度的数据，可以通过翻页快速浏览；部分操作按钮被收纳在单元格内</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2805xjlv9j21f70u044e.jpg" alt="image-20220514161530381" /><figcaption aria-hidden="true">image-20220514161530381</figcaption>
</figure>
<p>点击添加即可进入添加页面，部分元素提供了下拉选择的能力；通过左上角返回可以回到原界面</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h28079ss9lj21gv0u0gnv.jpg" alt="image-20220514161648297" /><figcaption aria-hidden="true">image-20220514161648297</figcaption>
</figure>
<p>以下三个按钮分别对应编辑、删除和查看详情操作</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h28082953aj207e02ma9x.jpg" alt="image-20220514161733438" /><figcaption aria-hidden="true">image-20220514161733438</figcaption>
</figure>
<p>部分模块提供二级链接，点击蓝色字体即可跳到子页面</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280a4dqhcj21ok0u0n23.jpg" alt="image-20220514161932513" /><figcaption aria-hidden="true">image-20220514161932513</figcaption>
</figure>
<p>在学生管理页面点击学生姓名，应当跳转到个人简历页面</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280d0rlq3j21h20u0taq.jpg" alt="image-20220514162219306" /><figcaption aria-hidden="true">image-20220514162219306</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280dbhh10j21h40u0myv.jpg" alt="image-20220514162236504" /><figcaption aria-hidden="true">image-20220514162236504</figcaption>
</figure>
<p>点击按钮获得pdf版本的简历文件</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280en5efij2154044dft.jpg" alt="image-20220514162353023" /><figcaption aria-hidden="true">image-20220514162353023</figcaption>
</figure>
<h2 id="系统设计">系统设计</h2>
<h3 id="系统概要设计">系统概要设计</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280g16iskj21yw0u0aha.jpg" alt="aedas" /><figcaption aria-hidden="true">aedas</figcaption>
</figure>
<h4 id="总体架构">总体架构</h4>
<p>本系统架构基本基于MVC，在数据访问层进行进一步分离</p>
<p>以下给出系统架构图</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h285qzql70j20o20r7dhw.jpg" alt="8CCDD3D95FDD4B60736922F30ABF5952" /><figcaption aria-hidden="true">8CCDD3D95FDD4B60736922F30ABF5952</figcaption>
</figure>
<p>其中，</p>
<ol type="1">
<li>Web层(C)：位于<code>controller</code>包下，负责对http请求的分发和<code>@Validation</code>校验异常的捕获及处理</li>
<li>服务层(C)：由于本系统初版直接进行了响应数据的处理，本系统此处并未将本层设计为接口，而是使用普通类的形式；主要负责对请求体的解包，包装成实体类对象参与传递，以及提供服务实现层状态的维护。</li>
<li>服务实现层(C)，本层用于业务的实现，严格杜绝对上层的访问操作，仅提供本层和对数据访问层的权限。</li>
<li>数据访问层(M)：本次用于维护实体关系和封装对数据库表的直接操作</li>
</ol>
<p>本系统总体架构具有良好的鲁棒性，符合高内聚低耦合的要求</p>
<p>Web层与其下的服务层、服务实现层有一一对应关系，Web层仅负责请求的解析、远程方法的调用、异常捕获以及请求体和参数的传递；在服务层，主要将请求体封装为合适的PO或者DTO传递给服务实现层并维护服务实现层对象的状态；服务实现层主要用于实现对应实体增删改查业务，部分类参与对非实体类对象的计算和维护；数据访问层实现了对所有数据库操作的封装，避免对数据库的直接访问操作。</p>
<p>在实际业务过程中，类的分类被进一步细化。</p>
<p>本系统参考阿里巴巴开发手册，规定以下集中：</p>
<ul>
<li>POJO: 位于<code>models</code>包下，具有现实世界对应关系的实体类，一定有上述四层结构</li>
<li>VO：使用较少，未定义类文件，在服务层和服务实现层直接组合，强制要求服务层和服务实现层命名包含<code>VO</code></li>
<li>DTO：位于<code>dto</code>包下，用于数据流转，本系统内主要负责包装成绩计算相关的数据，便于数据流转，降低系统耦合性</li>
<li>BO：仅包含对简历信息的封装，具有实际业务意义</li>
</ul>
<h4 id="工作流程">工作流程</h4>
<p>本报告将系统的工作划分为如下几个阶段</p>
<ol type="1">
<li>接受http请求。</li>
<li>处理数据，封装对象。</li>
<li>操作数据库。</li>
<li>后台定时工作。</li>
<li>生成简历和个人画像。</li>
</ol>
<h4 id="功能模块划分">功能模块划分</h4>
<h5 id="四个基本模块">四个基本模块</h5>
<p>学生基本信息模块用于记录学生的基本信息，包括性别、年龄、学院、年级等等。 配备了基本的增删改查能力，查询可以使用两种模式选择； 点击每个学生的姓名可以跳转到该学生的个人简历页面； 个人简历将会根据该学生的信息生成两个图表便于展示。</p>
<p>学生课程信息模块用于记录学生与课程相关的信息，比如选课、作业完成情况等等。 配备了基本的增删改查能力，查询可以使用两种模式选择。</p>
<p>教研活动模块用于记录学生与各种教学活动，包含课内课外的相关的信息。 配备了基本的增删改查能力，查询可以使用两种模式选择。</p>
<p>日常信息模块用于记录学生的日常活动，如支出、消费等等。 配备了基本的增删改查能力，查询可以使用两种模式选择。</p>
<h5 id="成绩计算和排名模块">成绩计算和排名模块</h5>
<p>基于Redis和Spring Boot定时事务，主动计算成绩。</p>
<p>本作品将会定时计算所有同学的成绩并进行排名，学生在查询时只需查找对应的成绩即可，能够有效降低服务器的读写压力，保护数据安全。</p>
<p>考虑到AOP设计理念，此处业务架构示例图如下</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h285qox87bj218p0ptdjp.jpg" alt="7C72482DAA62F63FB194123660FD6841" /><figcaption aria-hidden="true">7C72482DAA62F63FB194123660FD6841</figcaption>
</figure>
<h5 id="简历信息模块">简历信息模块</h5>
<p>利用<code>echarts.js</code>绘制动态图表，生动展示学生的形象。</p>
<p>展示学生的各项基本信息。</p>
<h3 id="系统详细设计">系统详细设计</h3>
<h4 id="包结构">包结构</h4>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">main
|-- java.org.fatchmansoft.teach
|   |-- java
|   |   |-- config
|   |   |   |-- ...
|   |   |-- controllers
|   |   |   |-- ...
|   |   |-- dto
|   |   |   |-- ...
|   |   |-- models
|   |   |   |-- ...
|   |   |-- payload
|   |   |   |-- ...
|   |   |-- repository
|   |   |   |-- ...
|   |   |-- security
|   |   |   |-- ...
|   |   |-- service
|   |   |   |-- ...
|   |   |-- sqlite
|   |   |   |-- ...
|   |   |-- util
|   |   |   |-- ...
|   |   |-- RunJApplet
|   |   |-- SpringBootSecurityJwtApplication
|   |   |-- SystemApplicationListener
|   |-- resources
|-- test
|   |-- java
|   |   |--- models
|   |   |--- redis</code></pre></div>
<p>其中，<code>controllers</code>用于存放Web控制器进行请求分发</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- acdemic
|   |-- ...
|-- acdemic_activity
|   |-- ...
|-- daily
|   |-- ...
|-- student_basic
|   |-- ...
|-- system
|   |-- ...
|-- IntroduceController</code></pre></div>
<p><code>dto</code>用于存放DTO对象及其相关的工具类</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- AverageScoreDTO
|-- ChartInformationDTO
|-- CourseRankDTO
|-- COurseRankComparator
|-- CourseRankDTOSerializator
|-- TotalRankDTO
|-- TotalRankDTOComparator
|-- TotalRankDTOSerializator
|-- TotalScoreDTO</code></pre></div>
<p><code>models</code>包下包含所有的实体类，此处不再斤西瓜展开</p>
<p><code>service</code>包包含业务逻辑部分</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- academic
|   |-- ...
|-- acdemic_activity
|   |-- ...
|-- daily
|   |-- ...
|-- student_basic
|   |-- EducationExperienceImpl
|   |-- EducationExperienceService
|   |-- FamilyImpl
|   |-- FamilyService
|   |-- SocialRelationImpl
|   |-- SocialRelationService
|   |-- StudentImpl
|   |-- StudentService
|-- vo_service
|   |-- AcademicActivityVOService
|   |-- AcademicActivityVOImpl
|   |-- DailyVOService
|   |-- DailyVOImpl
|   |-- StudentAcademicService
|   |-- StudentAcademicImpl
|-- GlobalScoreService
|-- IntroduceService
|-- IntroduceServiceImpl
|-- SystemService
|-- TestService</code></pre></div>
<h4 id="实体关系展示">实体关系展示</h4>
<p>以下展示几个模块的类图</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283rpvm2nj20rd0tywiq.jpg" alt="67F51931BEF301D17FD04FF14071DBC7" /><figcaption aria-hidden="true">67F51931BEF301D17FD04FF14071DBC7</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283s3f9lhj20sd0k7dkf.jpg" alt="155A68AF6CDF1DC525CF93A92405278F" /><figcaption aria-hidden="true">155A68AF6CDF1DC525CF93A92405278F</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283rz61rgj20rh0qate2.jpg" alt="D6CF655E21EA2156082FFF28674E49A1" /><figcaption aria-hidden="true">D6CF655E21EA2156082FFF28674E49A1</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283sae77wj20tz0k842q.jpg" alt="60CCCAF20310A1044A3AE73C4DC6DACC" /><figcaption aria-hidden="true">60CCCAF20310A1044A3AE73C4DC6DACC</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283se56mzj21030rp0z8.jpg" alt="EDB199DD7186AEFE1F69FC175625AFF3" /><figcaption aria-hidden="true">EDB199DD7186AEFE1F69FC175625AFF3</figcaption>
</figure>
<h4 id="工作流程展示">工作流程展示</h4>
<p>此处给出一种典型的工作模式</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h283ren9xaj20u00xj0z4.jpg" alt="BFE9333D5A663FA8FA65F81115C95C82" /><figcaption aria-hidden="true">BFE9333D5A663FA8FA65F81115C95C82</figcaption>
</figure>
<h2 id="系统实现">系统实现</h2>
<h3 id="单一对象的建立和维护">单一对象的建立和维护</h3>
<p>单一对象的建立和维护需求实现起来最为简单。</p>
<p>MVC架构最大的历史意义在于将单体应用实现了垂直分层，这使得层与层之间的耦合度降低，且有效提高了服务层的复用性，这为Spring框架的AOP思想奠定坚实基础。</p>
<p>基于课堂上的框架，本组对本作品进行了进一步分包以明确类职责。</p>
<p>其中值得一提的是控制层，即C层。在MVC提出后，应用的可维护性、可拓展性得到极大提高，但开发者也逐渐发现MVC往往会带来C层的臃肿。针对这个问题，前端开发领域提出了MVP(Model-View-Presenter)模式，后来又衍生出MVVM(Model-VIew-ViewModel)模式以解决这个现象；针对本作品，本组参考常规的业务实现与架构方法，结合项目本身情况报告后，使用服务层与服务实现层来降低耦合、提高可维护性。</p>
<p>本组的方案基本参考了Spring Boot应用的架构方式，即Service接口+ServiceImpl类实现的思路。但在此基础上，本组将服务(Service)层使用类实现，并提供一些逻辑来缓解服务实现层的压力。其任务有以下两点</p>
<ol type="1">
<li><p>解包请求体，封装实体类。</p>
<p>由于上层控制器只进行分发，服务层接收到的唯一参数认识请求体，因此，本组在此处对请求体进行解析并建立对应的POJO或DTO进行接下来的传递。</p>
<p>这种方式，一可以使得程序更加安全健壮：使用请求体或Map来传值是危险的，因为下级无法了解上级打包了多少内容，极易出现空指针或错误取值；二有效降低耦合性、提高复用性：在服务之间出现调用关系时，只要OOP构造足够合理完善，服务实现曾能覆盖对象需要进行的操作，可以只在服务层之间进行相互调用，避免了穿透到服务实现层甚至数据操作层。</p></li>
<li><p>维护服务实现层状态。</p>
<p>由于对多方对象操作，特别是建立和查询时，需要多方对象持有一个一方对象的引用，或者说句柄，所以本组在多方的服务实现层维护一个一方的主键（在多对多情况下持有多个多方的主键们）来作为这个句柄。</p>
<p>因此，本组将服务实现层的维护权移交给上层。由对应的服务层提供句柄的初始化操作。</p></li>
</ol>
<p>以下以对<code>Student</code>类的操作为例进行说明。</p>
<h4 id="实体类的建立和数据操作层封装">实体类的建立和数据操作层封装</h4>
<p>以下为<code>Student</code>类的主要内容</p>
<blockquote>
<p>如非特殊说明，以下所有代码应用均不包含导入部分</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Entity
@Table(name &#x3D; &quot;student&quot;, uniqueConstraints &#x3D; &#123;
        @UniqueConstraint(columnNames &#x3D; &#123;&quot;student_id&quot;, &quot;student_num&quot;&#125;)
&#125;)
@NoArgsConstructor
@Getter
@Setter
@AllArgsConstructor
public class Student &#123;
    @Id
    @Column(name &#x3D; &quot;student_id&quot;)
    private Integer studentId;
    @Column(name &#x3D; &quot;student_num&quot;)
    @NotBlank(message &#x3D; &quot;学号不能为空！&quot;)
    private String studentNum;
    &#x2F;&#x2F; 此处省略一部分代码
    @Column(name &#x3D; &quot;email&quot;)
    @Email
    private String email;

    @OneToMany(mappedBy &#x3D; &quot;student&quot;, cascade &#x3D; CascadeType.ALL, fetch &#x3D; FetchType.LAZY)
    private Set&lt;Family&gt; families;
    &#x2F;&#x2F; 此处省略一部分代码
    @OneToMany(mappedBy &#x3D; &quot;student&quot;, cascade &#x3D; CascadeType.ALL, fetch &#x3D; FetchType.LAZY)
    private Set&lt;Achievement&gt; achievements;

    @Override
    public boolean equals(Object o) &#123;
                &#x2F;&#x2F; 省略部分代码
        return studentId !&#x3D; null &amp;&amp; Objects.equals(studentId, student.studentId);
    &#125;

    @Override
    public int hashCode() &#123;
        return getClass().hashCode();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;studentId&#x3D;&quot; + studentId +
                &#x2F;&#x2F; 省略部分代码
                &quot;, email&#x3D;&#39;&quot; + email + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;</code></pre></div>
<blockquote>
<p>此处省略内容与一对多、多对多相关，将在下面进一步展示。</p>
</blockquote>
<p>实体类的编写，有以下几点值得一提</p>
<ul>
<li><p>使用<code>Lombok</code>。众所周知，实体类的编写有大量Setter与Getter，使用<code>Lombok</code>注解可以极大减少代码量，提高代码可读性</p></li>
<li><p><code>override</code>三个基本方法。对实体类来讲，<code>hashCode()</code>，<code>equals()</code>和<code>toString</code>都是非常重要的方法。其中<code>equals()</code>基于<code>hasCoode()</code>。</p>
<blockquote>
<p>值得一提的是，对于直接连接的多对多关系并没有包含到<code>toString()</code>方法里。这是由于在多方A对多方B调用时，由于B也持有一个A的集合，就会带来递归调用进而导致stack overflow。</p>
</blockquote></li>
<li><p>使用注解进行校验。该类使用了<code>@NotBlank</code>、<code>@Email</code>和<code>@Min</code>等注解，可以帮助实现参数的校验。</p></li>
<li><p>对每个参数使用<code>@Column</code>注解。使用该注解与数据库表字段的映射关系，可以在必要时手动进行数据库的迁移，同时配合IDEA强大的辅助功能可以实时查看JPA能否保证正确映射。</p></li>
<li><p>指定<code>uniqueconstraints</code>。使用<code>@UniqueConstraints</code>注解进行约束。</p></li>
</ul>
<p>在此基础上，我们已经建立了一个内容丰富、结构良好的实体类。我们在此基础上封装他的数据操作层。</p>
<p>以下为<code>StudentRepository</code>的内容</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
public interface StudentRepository extends JpaRepository&lt;Student, Integer&gt; &#123;
    &#x2F;**
     * 获取最大id
     *
     * @return 最大id
     *&#x2F;
    @Query(value &#x3D; &quot;select max(studentId) from Student  &quot;)
    Integer getMaxId();

    &#x2F;**
     * 根据学号或姓名查询对象
     * 
     * @param numName 学号或者姓名
     * @return 对象数组
     *&#x2F;
    @Query(value &#x3D; &quot;from Student where ?1&#x3D;&#39;&#39; or studentNum like %?1% or studentName like %?1% &quot;)
    List&lt;Student&gt; findStudentListByNumName(String numName);

&#125;</code></pre></div>
<p>在这里，本组做的工作有</p>
<ul>
<li>使用javadoc形式注释。javadoc形式的注释覆盖了本作品中大部分的服务层和数据操作层方法，其最大的特点是方便，能够在调用时提示需要的参数、参数简介和返回值的简介。</li>
<li>使用<code>@Query</code>注解。尽管JPA具有一个强大的根据方法名实现功能的机制，在一些情况下指定SQL语句会有更好的效果。本作品暂不考虑对搜索的优化，所以其他多数地方均使用命名方式声明方法。</li>
</ul>
<h4 id="web层对请求分发">Web层对请求分发</h4>
<p>让我们将目光转向控制器，此处以添加为例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@CrossOrigin(origins &#x3D; &quot;*&quot;, maxAge &#x3D; 3600)
@RestController
@RequestMapping(&quot;&#x2F;api&#x2F;teach&quot;)
public class StudentController &#123;
    @Resource
    private StudentService studentService;

    @PostMapping(&quot;&#x2F;studentInit&quot;)
    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    public DataResponse studentInit(@Valid @RequestBody DataRequest dataRequest) &#123;
        SystemApplicationListener.logger.info(&quot;studentInitStart&quot;);
        List&lt;Object&gt; result &#x3D; studentService.getAllStudent(dataRequest);
        SystemApplicationListener.logger.info(&quot;studentInitEnd&quot;);
        return CommonMethod.getReturnData(result);
    &#125;

    @PostMapping(&quot;&#x2F;studentEditSubmit&quot;)
    @PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)
    public DataResponse studentEditSubmit(@Valid @RequestBody DataRequest dataRequest) &#123;
        &#x2F;&#x2F; 捕获校验错误异常
        try &#123;
            Integer result &#x3D; studentService.saveStudent(dataRequest);
            return CommonMethod.getReturnData(result);
        &#125; catch (ValidationException validationException) &#123;
            String temp &#x3D; validationException.getLocalizedMessage();
            &#x2F;&#x2F; 通过拼接字符串返回更易读的错误信息
            return CommonMethod.getReturnMessage(&quot;400&quot;, temp.substring(temp.substring(0, temp.indexOf(&quot;:&quot;)).length() + 2));
        &#125;
    &#125;
    &#x2F;&#x2F;  此处省略部分代码
&#125;</code></pre></div>
<p>上面展示的代码，主要作用是通过类和方法的两次分发对http请求进行映射，调用对应的方法，并捕获一些异常。</p>
<p>如上面所说，Web层最重要的任务是进行请求分发，在这一原则下每个<code>controller</code>文件在100行左右，具有良好的可读性，可以快速定位到分发时出现的问题；使用<code>@PreAuthorize</code>注解进行权限控制；使用<code>@Valid</code>注解进行参数校验，不满足实体类定义的字段将会抛出对应的异常并携带message信息返回前端。</p>
<p>值得一题的是，本项目大部分地方使用<code>@Resource</code>注解注入资源，主要有两个考虑</p>
<ol type="1">
<li><code>@Autowired</code>不被建议进行<code>field injection</code>。最近几个版本Spring官方都在建议使用构造方法或<code>setter</code>的方式注入资源，而不是直接对属性注入1⃣️提高安全性，本项目懒得使用其他注入方式。</li>
<li><code>@Resource</code>注解默认<code>byName</code>注入，<code>@Autowired</code>则是<code>byType</code>注入，有时需要指定<code>name</code>时要配合<code>@Qualifier</code>注解，略微麻烦一些，<code>@Resource</code>注解啧默认通过反射机制使用<code>byName</code>自动注入</li>
</ol>
<p>经过分发后，我们的请求体内数据将来到下一层，服务层。</p>
<h4 id="服务层解包封装对象">服务层解包封装对象</h4>
<p>服务层的实现方式给有区别，此处逐一给出展示</p>
<p>此处注入的只有对应服务实现层对象</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class StudentService &#123;
    @Resource
    private StudentImpl student;
&#x2F;&#x2F; 略去
&#125;</code></pre></div>
<p>首先,展示用于页面初始化以及选择时调用的两个方法</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;**
 * 获取所有学生的信息
 *
 * @param dataRequest 接受请求内容
 * @return 学生数组
 *&#x2F;
public List&lt;T&gt; getAllStudent(DataRequest dataRequest) &#123;
    return student.queryStudentMapList(&quot;&quot;);
&#125;
&#x2F;&#x2F; 省略部分代码
&#x2F;**
 * 传回某个学生的详细信息
 *
 * @param dataRequest 接受请求数据
 * @return 某个学生
 *&#x2F;
public Map&lt;String, Object&gt; getStudentDetail(DataRequest dataRequest) &#123;
    Integer studentId &#x3D; dataRequest.getInteger(&quot;id&quot;);
    return student.queryStudentDetail(studentId);
&#125;</code></pre></div>
<p>此处调用的是服务实现层的同一个方法，只是传入参数不同。在此处分离的考虑主要是本作品设计时对服务层是完全自上而下的，本组希望服务层与Web层有良好的合作关系，因此进行了分离；除此之外，这种设计可以避免取出请求体内容时出现空指针，一定程度上提高了安全性；这里javadoc形式的注解为其它类调用方法提供了一定帮助，并且在返回值时通过容器搭配泛型的方式带来良好的可复用性。</p>
<p>除此以外，可以看到第二个方法的第一行进行在请求体中取出内容的操作，者与上文所说服务层的定位是相同的——解析请求数据。服务层承担对请求体内容的解析工作，并对解析到的内容进行处理和包装后传递给下一层。当然，在上面的代码中并没有很显然的应用，下面我们以添加新学生的方法进一步观察一下。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 持久化学生信息
 *
 * @param dataRequest 接受请求内容
 * @return 返回建立的学生id
 *&#x2F;
public Integer saveStudent(DataRequest dataRequest)&#123;
    Map&lt;String,Object&gt; form &#x3D; dataRequest.getMap(&quot;form&quot;);
    Student studentData &#x3D; new Student();
    studentData.setStudentId(CommonMethod.getInteger(form,&quot;id&quot;));
    studentData.setStudentNum(CommonMethod.getString(form,&quot;studentNum&quot;));
    &#x2F;&#x2F; 省略部分代码
    studentData.setEmail(CommonMethod.getString(form,&quot;email&quot;));
    return student.insertStudent(studentData);
&#125;</code></pre></div>
<p>本例中，服务层首先取出请求体中的一个Map，之后建立一个空对象逐个取出Map中的内容。这种方式会导致代码量的增加，但好处在于可以保证后面的操作都是针对对象进行的，而对象的类对所有方法和类都是公开透明的，针对对象的操作最多最多取出一个<code>null</code>，但至少不会<code>NullPointerException</code>，具有更好的安全性和可读性，同时可以实现更好的业务抽象。</p>
<p>最后再给出一个简单的示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 删除学生信息
 *
 * @param dataRequest 请求内容
 *&#x2F;
public void deleteStudent(DataRequest dataRequest)&#123;
    Integer id &#x3D; dataRequest.getInteger(&quot;id&quot;);
    student.deleteStudent(id);
&#125;</code></pre></div>
<p>从上面的几个例子来看，这种方式还有一个好处————便于修改维护。举个例子，如果要取出的字段由<code>id</code>变更为<code>studentId</code>，且存在较多的服务之间调用，在服务层进行取出操作可以仅修改一次就能实现修改的需求。</p>
<p>总体来讲，服务层进行的是一系列预处理，将面向http的请求体数据解包、打包为面向对象的对象，其代价是更多的代码量，换来的是更好的可移植性、可维护性和安全性。考虑到本项目的规模和需求，本组采用这种方式进行程序的设计。接下来，对象将在服务实现层执行具体逻辑。</p>
<h4 id="服务实现层实现增删改查逻辑">服务实现层实现增删改查逻辑</h4>
<p>此处首先展示用于查询的方法</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Object&gt; queryStudentMapList(String numName) &#123;
    List&lt;Object&gt; result &#x3D; new ArrayList&lt;&gt;();
    List&lt;Student&gt; studentList &#x3D; studentRepository.findStudentListByNumName(numName);
    if (studentList &#x3D;&#x3D; null || studentList.size() &#x3D;&#x3D; 0) &#123;
        return result;
    &#125;
    Student student;
    Map&lt;String, Object&gt; tempMap;
    for (Student value : studentList) &#123;
        student &#x3D; value;
        tempMap &#x3D; new HashMap&lt;&gt;();
        tempMap.put(&quot;id&quot;, student.getStudentId());
        tempMap.put(&quot;studentNum&quot;, student.getStudentNum());
        &#x2F;&#x2F; 省略部分代码
        tempMap.put(&quot;age&quot;, student.getAge());
        tempMap.put(&quot;phoneNumber&quot;, student.getPhoneNumber());
        &#x2F;&#x2F; 省略部分代码
        result.add(tempMap);
    &#125;
    return result;
&#125;</code></pre></div>
<p>在设计本方法时主要考虑两点：</p>
<ol type="1">
<li><p>功能具有复用需求。上层对该方法的调用有三种情况，分别是查询所有、根据一个字段查询以及组合字段查询。</p>
<blockquote>
<p>此处所谓组合字段查询，是指前端可以通过<code>v-model</code>绑定一个或多个<code>input</code>和<code>select</code>形式的约束，此时需要在服务层对约束进行组合拼接在调用查询的方法。</p>
</blockquote>
<p>通过方法的封装，可以根据传入参数的内容调用数据操作层的同一个方法，减少代码的冗余。</p></li>
<li><p>功能具有良好的独立性。在抽离成方法时，首先要考虑的如何进行参数和返回值的抽象，对于本功能来讲，其参数只需要一个字符串即可，返回值使用<code>List</code>作为容器进行装载，如果需要进一步处理可以在调用方法里进行处理，具有非常良好的抽象能力，属于是老天爷赏饭吃，不吃不行。</p></li>
</ol>
<p>另外，如上面所示，本项目大部分使用了增强型的<code>for</code>循环，即使用<code>for (Class value : classObjectContainer)</code>的形式遍历容器内的对象，这样可以在语法层面省去手动声明对象引用变量和执行目标对象的过程，同时带来更好的可读性。</p>
<p>上面的代码实现的是对常用数据操作的一种封装，在服务实现层还有一类重要的操作：根据某些字段获取特定对象，本项目使用这种方式实现</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Student getStudent(Integer studentId) &#123;
    Student student &#x3D; null;
    Optional&lt;Student&gt; op;
    if (studentId !&#x3D; null) &#123;
        op &#x3D; studentRepository.findById(studentId);
        if (op.isPresent()) &#123;
            student &#x3D; op.get();
        &#125;
    &#125;
    return student;
&#125;</code></pre></div>
<p>因为表中的数据通过主键进行唯一标识，该方法以及下面出现的一些方法作用和目的很清晰，就是通过<code>id</code>获取对应的对象。</p>
<p>本方法在接受<code>id</code>之后，首先是建立一个对象引用变量，并尝试进行查找；查找失败的情况下会返回空指针，这可以轻易的在调用方进行捕获。进一步查询时调用服务实现层继承的JPA的<code>CrudRepository</code>接口实现的<code>findById</code>方法即可轻松实现需求。但此处并没有使用泛型进行进一步抽象，主要是希望强调服务的隔离，同时保留一定自主性给出拓展空间。</p>
<p>以上方法可以实现多数与查询有关的需求，下面讨论添加的实现</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Integer insertStudent(@Valid Student studentData) &#123;
    Student student &#x3D; getStudent(studentData.getStudentId());
    Integer maxStudentId &#x3D; null;
    if (student &#x3D;&#x3D; null) &#123;
        student &#x3D; new Student();
        maxStudentId &#x3D; studentRepository.getMaxId();
        if (maxStudentId &#x3D;&#x3D; null) &#123;
            maxStudentId &#x3D; 1;
        &#125; else &#123;
            maxStudentId +&#x3D; 1;
        &#125;
        student.setStudentId(maxStudentId);
    &#125;

    student.setStudentNum(studentData.getStudentNum());
    student.setStudentName(studentData.getStudentName());
    &#x2F;&#x2F; 省略部分代码
    studentRepository.save(student);
    return maxStudentId;
&#125;</code></pre></div>
<p>此处的方法所接受的就是服务层封装后的对象，其内部同时转载两个同类对象，一个就是调用方传入的元数据，另一方是即将持久化的目标数据，这一方式可以提供一定自由修改的空间，将会在下面进一步介绍。除此以外，本方法的核心是对<code>maxId</code>字段的查询，其用处主要在于实现手动的主键自增，这是本项目早期使用SQLite的需求，理论上切换到MySQL后可以避免其使用。</p>
<p>可以看到确定对象的状态后，只需要调用其数据操作层的<code>save()</code>方法即可保存，这也是继承的<code>CrudRepository</code>所提供的能力，算是典型的ORM框架能力，将数据库表记录的添加抽象为对象的<code>save()</code>方法。</p>
<p>相似的，我们可以看一看对象——或者说记录——的删除操作：</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void deleteStudent(Integer studentId) &#123;
    Student student &#x3D; getStudent(studentId);
    if (student !&#x3D; null) &#123;
        studentRepository.delete(student);
    &#125;
&#125;</code></pre></div>
<p>可以看到，在查询对象之后只需要调用<code>delete()</code>方法即可。</p>
<p>至此为止，单一对象的各种操作基本实现。</p>
<h3 id="一对多关系维护时的差异">一对多关系维护时的差异</h3>
<p>这一类需求在设计时，主要在于如何添加某个一方的多方。在这种情况下，核心在于为多方对象确定其链接的一方。对于CRUD来讲，主要的改动在于添加，我们需要让多方建立时持有一个一方的句柄，其次是删除时需要妥善处理级联方式，在某个多方被删除时需要考虑是否保留一方又或者相反情况</p>
<h4 id="添加多方状态的维护">添加多方状态的维护</h4>
<p>此处以<code>EducationExxperience</code>为例来展示，首先需要注意实体类的生命</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 省略部分代码
public class EducationExperience &#123;
    &#x2F;&#x2F; 省略部分代码
    @ManyToOne()
    @JoinColumn(name &#x3D; &quot;student_id&quot;)
    private Student student;
    &#x2F;&#x2F; 省略部分代码
&#125;</code></pre></div>
<p>此处我们将<code>EducationExperience</code>类称为多方类，注意到他持有一个一方对象，通过这种组合的方式实现逻辑层面与一方的关联，也就是说当我们持有一个多方对象时，可以通过访问他的<code>.getStudent()</code>方法获得他的一方对象。</p>
<p>除此以外，这样的字段还需要有两个注解。其一是<code>@ManyToOne</code>，顾名思义用于指明对于多方类来讲存在多对一的关系；重点在于<code>@JoinColumn</code>注解，可以说它指定了连接方式。</p>
<p>首先我们需要知道，JPA对一对多、多对多关系在数据库表层面是通过外键实现的，在一对多的情况下就涉及到一个问题：这样的外键应该存在哪个类中。通常来讲，由于多方只需要持有一个一方对象，我们通常会将这个外键交给多方，也就是“由多方维护关系”，其在数据库表上的表现就是会有一个<code>student_id</code>字段记录它所连接的一方对象的主键，这样我们就可以实现二者在数据库层面上的连接。当然简单来讲，<code>@ManyToOne</code>其实就是用来指明外键的字段。</p>
<p>接下来，我们来看看一方</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@OneToMany(mappedBy &#x3D; &quot;student&quot;,cascade &#x3D;CascadeType.ALL,fetch &#x3D; FetchType.LAZY)
private Set&lt;EducationExperience&gt; educationExperiences;</code></pre></div>
<p>如前面所说，一方需要持有一个多方的容器，此处使用集合实现。其重点在于<code>@OneToMany</code>注解，<code>mappedBy</code>用于放弃维护关系，这与多方类使用<code>@JoinCOlumn</code>是对应的：一方选择维护关系，另一方就要放弃。<code>cascade</code>用于声明级联，<code>fetch</code>忘了</p>
<p>通过这样的改动，就可以建立一个实体类和多个实体类之间的一对多关系。</p>
<h4 id="前期准备">前期准备</h4>
<p>此处本组的处理首先在服务实现层添加一个字段</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 保存相关studentId
 *&#x2F;
private Integer studentId;</code></pre></div>
<p>如注解所说。其作用就相当于所谓的“句柄”，使用这样一个主键保存其一方，随时可以拿来取用。至于这个id如何使用，首先要看下面的跳转</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String educationExperienceParas &#x3D; &quot;model&#x3D;educationExperience&amp;studentId&#x3D;&quot; + student.getStudentId();
Set&lt;EducationExperience&gt; educationExperiences &#x3D; student.getEducationExperiences();
tempMap.put(&quot;educationExperience&quot;, &quot;共有&quot; + educationExperiences.size() + &quot;条教育经历&quot;);
tempMap.put(&quot;educationExperienceParas&quot;, educationExperienceParas);</code></pre></div>
<p>该方法利用前端提供的<code>link</code>类型，在由一方页面跳转到多方时携带一个一方的id保存在请求体内</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 获取所有
 *
 * @param dataRequest 请求内容
 * @return List
 *&#x2F;
public List&lt;Object&gt; getAllEducationExperience(DataRequest dataRequest) &#123;
    &#x2F;&#x2F; 暂存studentId
    educationExperience.setStudentId(dataRequest.getInteger(&quot;studentId&quot;));
    return educationExperience.queryEducationExperienceMapList();
&#125;</code></pre></div>
<p>在多方的服务层，使用这样一行指令将id取出并set，即可在之后对多方的操作时保持这样一个联系</p>
<h4 id="修改多方添加逻辑">修改多方添加逻辑</h4>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Integer insertEducationExperience(EducationExperience educationExperienceData) &#123;
    EducationExperience educationExperience &#x3D; getEducationExperience(educationExperienceData.getEducationExperienceId());
    Integer maxEducationExperienceId &#x3D; null;
    if (educationExperience &#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; 省略部分代码
    educationExperience.setDescription(educationExperienceData.getDescription());

    Student relatedStudent;
    Optional&lt;Student&gt; opStudent &#x3D; studentRepository.findById(studentId);
    if (opStudent.isPresent()) &#123;
        relatedStudent &#x3D; opStudent.get();
        educationExperience.setStudent(relatedStudent);
    &#125;
    educationExperienceRepository.save(educationExperience);
    return maxEducationExperienceId;
&#125;</code></pre></div>
<p>基于前面所说的准备，我们只需要额外使用上面几个语句查找<code>studentId</code>所指向的对象，并将其赋予<code>educationExperience</code>即可，在调用<code>save()</code>方法后即可保存关联的关系。</p>
<h4 id="修改多方删除逻辑">修改多方删除逻辑</h4>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void dropEducationExperience(Integer educationExperienceId) &#123;
    EducationExperience educationExperience &#x3D; getEducationExperience(educationExperienceId);
    Student relatedStudent;
    Optional&lt;Student&gt; opStudent &#x3D; studentRepository.findById(studentId);
    if (opStudent.isPresent()) &#123;
        relatedStudent &#x3D; opStudent.get();
        relatedStudent.getEducationExperiences().remove(educationExperience);
    &#125;
    educationExperienceRepository.delete(educationExperience);
&#125;</code></pre></div>
<p>在删除时，我们所要删除的不只是多方对象本身，还需要删除“关系”。</p>
<p>也就是说尽管我们可以直接调用<code>delete()</code>方法删除，但一方所持有的集合仍然会持有这个被删除的对象，这会导致我们在获取一方持有的集合时出现空指针的问题。因此，在删除之前需要先删除关系，即调用<code>remove()</code>方法在集合内除去该对象，断开二者的联系，之后即可放心删除对象了。</p>
<h3 id="多对多关系的实现">多对多关系的实现</h3>
<p>多对多关系的维护要相对复杂一些。</p>
<blockquote>
<p>首先要明确一点，哪怕是JPA提供的<code>@ManyToMany</code>注解，在实际执行时也会建立一个名为<code>class_a_class_b</code>形式的中间表。</p>
</blockquote>
<p>总的来说，多对多关系可以解释为多对一对多关系，也就是说对与两个具有多对多关系的对象，我们可以使用一个中间对象来描述二者关系，这个中间对象不具有实际意义，仅仅是一个桥梁。</p>
<p>我们可以拿Map来类比，众所周知Map存储的时k-v数据，我们可以通过key取出对应的value，这可以作为一种一对一关系，也可以说是映射的形式；我们还可以让几个key具有相同的value，这似乎就有些多对一的意思了；在此基础上，我们进一步延伸，可以使用两个Map A和B，使用keyA得到valueA，再将valueA作为keyB即可得到valueB，这种方式所实现的就与多对多比较相似。</p>
<p>下面以选课功能的实现为例来展开介绍。</p>
<h4 id="定义多对多关系">定义多对多关系</h4>
<p>首先我们考虑，每个学生都会选择多个课程，那么不妨定义</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@OneToMany(mappedBy &#x3D; &quot;student&quot;,cascade &#x3D; CascadeType.ALL,fetch &#x3D; FetchType.EAGER)
private Set&lt;CourseSelection&gt; courseSelections;</code></pre></div>
<p>同样，每门课程都会用多个学生选择，如下所示</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@OneToMany(mappedBy &#x3D; &quot;course&quot;, cascade &#x3D; CascadeType.ALL, fetch &#x3D; FetchType.EAGER)
private Set&lt;CourseSelection&gt; courseSelections;</code></pre></div>
<p>可以看到，二者都持有一个<code>CourseSelection</code>类（下称中间类）的集合，这个类的作用就是连接二者实现多对多，我们可以看一下他的定义</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Entity
@Table(name &#x3D; &quot;course_selection&quot;,uniqueConstraints &#x3D; &#123;@UniqueConstraint(columnNames &#x3D; &quot;course_selection_id&quot;)&#125;)
&#x2F;&#x2F; 省略部分代码
public class CourseSelection &#123;
    @Id
    @Column(name &#x3D; &quot;course_selection_id&quot;)
    private Integer courseSelectionId;
    @Column(name &#x3D; &quot;type&quot;)
    private  String type;
    @ManyToOne
    @JoinColumn(name &#x3D; &quot;course_id&quot;)
    private Course course;
    @ManyToOne
    @JoinColumn(name &#x3D; &quot;student_id&quot;)
    private Student student;
    &#x2F;&#x2F; 省略部分代码
&#125;</code></pre></div>
<p>如上面所示，中间类主要负责持有两个对象并维护关系，也就是说他于其中一个类构成一对多关系，也与另一个类构成一对多关系。那么无论从哪个类进行操作，都可以通过<code>object.getCourseSlection().getAnotherObject()</code>这样的链式调用获取另一个对象，自然也就实现了多对多关系的维护。</p>
<p>在前面我们有提到，使用<code>@ManyToMany</code>注解同样可实现类似的效果，本组主要考虑以下两点而没有使用该注解</p>
<ol type="1">
<li>编程人员会失去控制权。使用注解会将关系的维护完全移交给Spring Data JPA，导致编程人员无法确定其详细的调用逻辑，留下潜在的风险。</li>
<li>缺少必要性，增加依赖性。由于这样的功能可以轻松实现，盲目使用注解会增加对框架的依赖，不利于后期开发或技术栈的迁移。</li>
<li>具有拓展空间。如上面的代码，中间还可以顺便用来表明二者的关系，将中间类进行暴露可以留出更多操作空间，比如表明二者的连接性质。</li>
</ol>
<h4 id="完善添加逻辑">完善添加逻辑</h4>
<p>就像刚才我们存了一个id，这里可以再存一个</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Object&gt; getAllCourseSelection(DataRequest dataRequest) &#123;
    try &#123;
        courseSelection.setCourseId(dataRequest.getInteger(&quot;courseId&quot;));
    &#125; catch (NullPointerException nullPointerException) &#123;
        SystemApplicationListener.logger.info(&quot;courseId设置失败&quot;);
    &#125;
    try &#123;
        courseSelection.setStudentId(dataRequest.getInteger(&quot;studentId&quot;));
    &#125; catch (NullPointerException nullPointerException) &#123;
        SystemApplicationListener.logger.info(&quot;courseId设置失败&quot;);
    &#125;
    return courseSelection.getCourseSelectionMapList();
&#125;</code></pre></div>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Integer saveCourseSelection(CourseSelection courseSelectionData,
                                   Integer courseIdData, Integer studentIdData) &#123;
    &#x2F;&#x2F; 省略部分代码                                   
    Student student &#x3D; null;
    Optional&lt;Student&gt; optionalStudent &#x3D; studentRepository.findById(studentIdData);
    if (optionalStudent.isPresent()) &#123;
        student &#x3D; optionalStudent.get();
        courseSelection.setStudent(student);
    &#125;
    Course course &#x3D; null;
    Optional&lt;Course&gt; optionalCourse &#x3D; courseRepository.findById(courseIdData);
    if (optionalCourse.isPresent()) &#123;
        course &#x3D; optionalCourse.get();
        courseSelection.setCourse(course);
    &#125;
    courseSelection.setCourse(course);
    courseSelection.setStudent(student);
    courseSelectionRepository.save(courseSelection);
    return maxCourseSelectionId;
&#125;</code></pre></div>
<p>上面的处理其实都是相似的，这里的重点在于用户通过其中一方开始操作，该如何选择要添加的另一个对象。本作品在几次迭代后，通过查询的方式获取满足条件的数据返回前端，前端生成一个下拉选项菜单进行选择，这部分逻辑被定义在有关初始化的方法里</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (courseSelection !&#x3D; null) &#123;
    resultMap.put(&quot;id&quot;, courseSelection.getCourseSelectionId());
    &#x2F;&#x2F; 省略部分代码
    resultMap.put(&quot;courseIdList&quot;, courseIdList);
&#125; else &#123;
    List&lt;Object&gt; studentIdList &#x3D; new ArrayList&lt;&gt;();
    if (studentId !&#x3D; null) &#123;
        Student student;
        Optional&lt;Student&gt; optionalStudent &#x3D; studentRepository.findById(studentId);
        if (optionalStudent.isPresent()) &#123;
            student &#x3D; optionalStudent.get();
            Map map &#x3D; new HashMap&lt;&gt;();
            map.put(&quot;label&quot;, student.getStudentName());
            map.put(&quot;value&quot;, student.getStudentId());
            studentIdList.add(map);
            resultMap.put(&quot;studentId&quot;, &quot;&quot;);
            resultMap.put(&quot;studentIdList&quot;, studentIdList);
        &#125;
    &#125; else &#123;
        List&lt;Student&gt; studentList &#x3D; studentRepository.findAll();
        Map map;
        for (Student value : studentList) &#123;
            map &#x3D; new HashMap&lt;&gt;();
            map.put(&quot;label&quot;, value.getStudentName());
            map.put(&quot;value&quot;, value.getStudentId());
            studentIdList.add(map);
        &#125;
        resultMap.put(&quot;studentId&quot;, &quot;&quot;);
        resultMap.put(&quot;studentIdList&quot;, studentIdList);
    &#125;
    List&lt;Object&gt; courseIdList &#x3D; new ArrayList&lt;&gt;();
    if (courseId !&#x3D; null) &#123;
        Course course;
        Optional&lt;Course&gt; optionalCourse &#x3D; courseRepository.findById(courseId);
        &#x2F;&#x2F; 省略部分代码
        resultMap.put(&quot;courseId&quot;, &quot;&quot;);
        resultMap.put(&quot;courseIdList&quot;, courseIdList);
    &#125;
&#125;</code></pre></div>
<p>可以看到，由于两个id初始化都被置为<code>null</code>，因此可以通过分支语句进行情况分类；接下来获取另一个类的所有对象填充到<code>List</code>中，并将其返回对应的字段即可实现选择的功能。这种处理具有良好的交互性，而且前端可以直接返回两个对象的id，不需要对后台逻辑进行过于复杂的修改。</p>
<h4 id="完善删除和其他逻辑">完善删除和其他逻辑</h4>
<p>对于删除功能的修改同样是类比即可，并不复杂</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void deleteCourseSelection(Integer courseSelectionId) &#123;
    CourseSelection courseSelection;
    Optional&lt;CourseSelection&gt; op;
    if (courseSelectionId !&#x3D; null) &#123;
        op &#x3D; courseSelectionRepository.findById(courseSelectionId);
        if (op.isPresent()) &#123;
            courseSelection &#x3D; op.get();
            Course relatedCourse;
            Optional&lt;Course&gt; opCourse &#x3D; courseRepository.findById(courseSelection.getCourse().getCourseId());
            if (opCourse.isPresent()) &#123;
                relatedCourse &#x3D; opCourse.get();
                relatedCourse.getCourseSelections().remove(courseSelection);
            &#125;
            Student relatedStudent;
            Optional&lt;Student&gt; opStudent &#x3D; studentRepository.findById(courseSelection.getStudent().getStudentId());
            if (opStudent.isPresent()) &#123;
                relatedStudent &#x3D; opStudent.get();
                relatedStudent.getCourseSelections().remove(courseSelection);
            &#125;
            courseSelectionRepository.delete(courseSelection);
        &#125;
    &#125;
&#125;</code></pre></div>
<h3 id="绩点计算与排名">绩点计算与排名</h3>
<p>对于一个学生管理系统，成绩、绩点的计算以及排名都是很有必要的功能。</p>
<h4 id="实现方式及思路">实现方式及思路</h4>
<p>本项目考虑到绩点的计算需要大量磁盘IO遍历数据，当受到大量请求时显然会给服务器带来很大的压力。基于这个考虑，本作品使用缓存的方式，定时计算成绩，在接受到请求后使用数据与缓存数据对撞取出满足条件的信息即可。</p>
<p>这种实现具有一定难度，首先我们需要引入Redis这个常用的内存数据来作为缓存；其次，本项目考虑将每个课程的成绩排名列表、总成绩的成绩排名列表进行缓存；除此以外，本作品设计了几个DTO用来包装数据，比如某个DTO中包含平均、GPA等等。</p>
<p>接下来进行展示</p>
<h4 id="redis的基本配置与序列化的准备">Redis的基本配置与序列化的准备</h4>
<p>首先是对Redis的简单配置</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">spring.redis.database&#x3D;0
spring.redis.host&#x3D;*****
spring.redis.port&#x3D;6379
spring.redis.password&#x3D;****</code></pre></div>
<p>除此以外，本组将所有对象进行序列化后存储。因此这里还需要提供一个序列化、反序列化的工具类，这样的类时依附于<code>DTO</code>类，可以通过一些分隔符对字段进行分隔后保存。此处给出一个示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TotalRankSerializator &#123;
    public static String serializeTotalRank(TotalRankDTO totalRankDTO) &#123;
        String result &#x3D; totalRankDTO.getAverageScore() + &quot;:&quot;;
        &#x2F;&#x2F; 省略部分代码
        result &#x3D; result + totalRankDTO.getSameScoreNum();
        return result;
    &#125;

    public static TotalRankDTO deserializeTotalRank(String str) &#123;
        TotalRankDTO totalRankDTO &#x3D; new TotalRankDTO();
        String stringDelimiter &#x3D; &quot;:&quot;;
        String[] temp &#x3D; str.split(stringDelimiter);
        &#x2F;&#x2F; 省略部分代码
        totalRankDTO.setSameScoreNum(Integer.parseInt(temp[3]));
        return totalRankDTO;
    &#125;
&#125;</code></pre></div>
<p>除此以外，我们还需要给每个<code>DTO</code>类定义一个<code>Comparator</code>用于<code>ArrayList</code>的<code>sort()</code>方法使用。它需要继承<code>Comparator&lt;T&gt;</code>并<code>override</code>继承的<code>comparator</code>方法以定义比较逻辑，比如说</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TotalScoreComparator implements Comparator&lt;TotalScoreDTO&gt; &#123;
    @Override
    public int compare(TotalScoreDTO o1, TotalScoreDTO o2) &#123;
        return o2.getAverageScore().compareTo(o1.getAverageScore());
    &#125;
&#125;</code></pre></div>
<p>总的来说，本项目设计的<code>DTO</code>类基本都需要一个序列化、反序列化工具类和<code>Comparator</code>以实现业务需求。</p>
<h4 id="成绩排名获取方式">成绩、排名获取方式</h4>
<p>首先考虑对于每一门课程的成绩</p>
<p>实现逻辑比较简单，首先我们遍历所有的课程，然后对某个课程进行操作</p>
<p>对于这样一个课程，我们取出他所持有的所有成绩的集合，建立若干个<code>DTO</code>对象对成绩进行二次封装；在此基础上得到一个列表，调用<code>ArrayList</code>的<code>sort()</code>方法，根据自定义比较器进行一次排序即可得到该课程下自高至低的所有成绩的列表。在此基础上，我们继续进行一次遍历，给该列表的每个对象赋予排名信息等，即可得到该门课程完整的所有成绩的信息。在此之后，我们对列表中的所有元素进行序列化，然后即可作为list存入Redis。</p>
<p>以下展示某个课程列表的实现方法</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 用来获取某门课程的所有学生的成绩并进行排序
 *
 * @param course 课程
 * @return CourseRankDTO的列表，包含排名和百分比
 *&#x2F;
public List&lt;CourseRankDTO&gt;  getCourseRankList(Course course) &#123;
    List&lt;Score&gt; scoreList &#x3D; new ArrayList&lt;&gt;(course.getScores());
    List&lt;CourseRankDTO&gt; courseRankDTOList &#x3D; new ArrayList&lt;&gt;();
    for (Score value : scoreList) &#123;
        courseRankDTOList.add(new CourseRankDTO(0, 0.0, value.getScore(), 0));
    &#125;
    courseRankDTOList.sort(new CourseRankComparator()); &#x2F;&#x2F; 排序
    int sameScoreNum &#x3D; 1;
    int size &#x3D; courseRankDTOList.size();
    for (int i &#x3D; 0; i &lt; size; i++) &#123; &#x2F;&#x2F; 遍历这一门课程下的所有成绩记录，从而得到该门课程的排名
        courseRankDTOList.get(i).setRank(i + 1);
        if ((i &gt; 1) &amp;&amp; courseRankDTOList.get(i).getScore().equals(courseRankDTOList.get(i - 1).getScore())) &#123;
            sameScoreNum +&#x3D; 1;
        &#125; else &#123;
            sameScoreNum &#x3D; 1;
        &#125;
        courseRankDTOList.get(i).setSameScoreNum(i);
        courseRankDTOList.get(i).setPercent((courseRankDTOList.get(i).getRank() + 1 - sameScoreNum + 1) &#x2F; (double) size);
    &#125;
    List&lt;String&gt; serializedCourseRankDTO &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 序列化
    for (CourseRankDTO value : courseRankDTOList) &#123;
        serializedCourseRankDTO.add(CourseRankDTOSerializator.serializeCourseRankDTO(value));
    &#125;
    try &#123;
        globalScoreRepository.drop(&quot;course:&quot; + (course.getCourseId() - 1));
    &#125; catch (Exception e) &#123;
        throw new RuntimeException(e);
    &#125;
    globalScoreRepository.leftPushStringList(&quot;course:&quot; + (course.getCourseId() - 1), serializedCourseRankDTO);
    try &#123;
        globalScoreRepository.drop(&quot;courseTime:&quot; + (course.getCourseId() - 1));
    &#125; catch (Exception e) &#123;
        throw new RuntimeException(e);
    &#125;
    globalScoreRepository.setString(&quot;courseTime:&quot; + (course.getCourseId() - 1), DateUtil.now().toString());
    return courseRankDTOList;
&#125;</code></pre></div>
<p>在此基础上，我们只需要进行一次所有课程的遍历即可将所有课程的信息获得。我们可以使用<code>findAll()</code>方法获得所有的对象，然后对列表中的所有元素执行上面定义的方法，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Course&gt; courseList &#x3D; courseRepository.findAll();
for (Course value : courseList) &#123;
    if (value.getScores() !&#x3D; null &amp;&amp; value.getScores().size() !&#x3D; 0) &#123;
        score.getCourseRankList(value);
    &#125;
&#125;</code></pre></div>
<p>基于上面的信息，我们可以进一步获取每个学生的成绩。但是我们还需要一个获得某个学生所有成绩的方法。</p>
<p>我们可以先获取某个学生的所有成绩，基于这个成绩的分数和课程，在对应的课程所有成绩内取出这个分数所对应的信息，对该学生所有课程进行遍历后即可计算该学生的平均绩点等信息。以下展示获取某个学生的成绩的方法</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 获取指定学生所有课程的排名
 *
 * @param courseScoresDTOList 学生的成绩DTO列表
 * @return 更新后的成绩DTO列表
 *&#x2F;
public List&lt;CourseScoresDTO&gt; getRankForCoursesForStudent(List&lt;CourseScoresDTO&gt; courseScoresDTOList) &#123;
    for (CourseScoresDTO courseScoresDTO : courseScoresDTOList) &#123;
        Optional&lt;Course&gt; op &#x3D; courseRepository.findById(courseScoresDTO.getCourseId());
        if (op.isPresent()) &#123;
            Course course &#x3D; op.get();
            List&lt;CourseRankDTO&gt; courseRankDTOList &#x3D; new ArrayList&lt;&gt;();
            try &#123;
                List&lt;String&gt; tempList &#x3D; globalScoreRepository.getAllRange(String.valueOf(course.getCourseId() - 1));
                for (String value : tempList) &#123;
                    courseRankDTOList.add(CourseRankDTOSerializator.deserializeCourseRankDTO(value));
                &#125;
            &#125; catch (Exception e) &#123;
                SystemApplicationListener.logger.warn(&quot;取出缓存失败！&quot;);
                SystemApplicationListener.logger.warn(String.valueOf(e));
            &#125;
            CourseRankDTO courseRankDTO &#x3D; score.getCourseRank(courseRankDTOList, courseScoresDTO.getScore());
            SystemApplicationListener.logger.info(&quot;打印学生的排名信息&quot;);
            SystemApplicationListener.logger.info(courseRankDTO.toString());
            courseScoresDTO.setCourseRankDTO(courseRankDTO);
        &#125;
    &#125;
    return courseScoresDTOList;
&#125;</code></pre></div>
<p>在此基础上，我们还可以提供一个方法进行学生的遍历，并对该集合每个元素调用上面的方法，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 获取所有学生的总成绩
 *
 * @return 学生总成绩的列表
 *&#x2F;
public List&lt;TotalScoreDTO&gt; getScoresForAllStudents() &#123;
    List&lt;TotalScoreDTO&gt; totalScoreDTOList &#x3D; new ArrayList&lt;&gt;();
    List&lt;Student&gt; studentList &#x3D; studentRepository.findAll();
    for (Student value : studentList) &#123;
        List&lt;CourseScoresDTO&gt; scoresDTOList &#x3D; getScoresForStudent(value);
        TotalScoreDTO totalScoreDTO &#x3D; new TotalScoreDTO();
        if (scoresDTOList !&#x3D; null &amp;&amp; scoresDTOList.size() !&#x3D; 0) &#123;
            AverageScoreDTO averageScoreDTO &#x3D; getAverageScoreForCoursesForStudent(getRankForCoursesForStudent(scoresDTOList));
            totalScoreDTO.setAverageScore(averageScoreDTO.getAverageScoreForAll());
        &#125; else &#123;
            totalScoreDTO.setAverageGPA(0.0);
            totalScoreDTO.setAverageScore(0.0);
        &#125;
        totalScoreDTOList.add(totalScoreDTO);
    &#125;
    return totalScoreDTOList;
&#125;</code></pre></div>
<p>值得注意的是，上面得到的信息同样是不含有排名的。因此所以我们接下来要做的就是对所有成绩进行排名，在进行排序后即可对每个元素进一步补充数据，最终得到完整的一个列表，对该列表进行序列化的处理后放入Redis缓存备用。可以看出，其实这与计算某门课程的成绩并无太大区别，只是有更多的遍历循环逐个进行计算</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;**
 * 获得所有学生的排名
 *
 * @param totalScoreDTOList 学生总成绩的列表
 * @return 加入排名信息后的学生总成绩的列表
 *&#x2F;
public List&lt;TotalScoreDTO&gt; getRanksForAllStudents(List&lt;TotalScoreDTO&gt; totalScoreDTOList) &#123;
    totalScoreDTOList.sort(new TotalScoreComparator());
    int size &#x3D; totalScoreDTOList.size();
    int sameScoreNum &#x3D; 1;
    for (int i &#x3D; 0; i &lt; totalScoreDTOList.size(); i++) &#123;
        TotalRankDTO totalRankDTO &#x3D; new TotalRankDTO();
        totalRankDTO.setRank(i + 1);
        totalRankDTO.setPercent((i + 1) &#x2F; (double) size);
        totalRankDTO.setAverageScore(totalScoreDTOList.get(i).getAverageScore());
        if (i &gt; 0 &amp;&amp; (totalScoreDTOList.get(i).getAverageScore().equals(totalScoreDTOList.get(i - 1).getAverageScore()))) &#123;
            sameScoreNum +&#x3D; 1;
        &#125; else &#123;
            sameScoreNum &#x3D; 1;
        &#125;
        totalRankDTO.setSameScoreNum(sameScoreNum);
        totalScoreDTOList.get(i).setTotalRankDTO(totalRankDTO);
        SystemApplicationListener.logger.warn(totalScoreDTOList.get(i).toString());
    &#125;
    try &#123;
        globalScoreRepository.drop(&quot;totalRank&quot;);
        SystemApplicationListener.logger.info(&quot;清空原有全部排名&quot;);
    &#125; catch (Exception e) &#123;
        SystemApplicationListener.logger.info(e.toString());
    &#125;
    List&lt;String&gt; totalRankDTOList &#x3D; new ArrayList&lt;&gt;();
    for (TotalScoreDTO value : totalScoreDTOList) &#123;
        totalRankDTOList.add(TotalRankSerializator.serializeTotalRank(value.getTotalRankDTO()));
    &#125;
    globalScoreRepository.leftPushStringList(&quot;totalRank&quot;, totalRankDTOList);
    return totalScoreDTOList;
&#125;</code></pre></div>
<p>当然，上面的一些方法并非是一环套一环耦合的。</p>
<p>本组建立一个<code>ScheduledService</code>，用于保存所有需要定时执行的事务。</p>
<p>首先要对每门课程进行计算，我们定义一个这个样子的方法，在服务启动后一段时间进行计算，顺便打印一下log，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 系统启动一分钟后计算所有课程的成绩列表
 * 之后每三分钟刷新一次
 *&#x2F;
@Scheduled(initialDelay &#x3D; MicroSecondsPerMinute, fixedDelay &#x3D; 3 * MicroSecondsPerMinute)
public void refreshCourseRank() &#123;
    SystemApplicationListener.logger.info(&quot;Begin refresh course rank&gt;&gt;&gt;&quot; + DateUtil.now());
    List&lt;Course&gt; courseList &#x3D; courseRepository.findAll();
    for (Course value : courseList) &#123;
        if (value.getScores() !&#x3D; null &amp;&amp; value.getScores().size() !&#x3D; 0) &#123;
            score.getCourseRankList(value);
        &#125;
    &#125;
    SystemApplicationListener.logger.info(&quot;Finish refresh course rank&gt;&gt;&gt;&quot; + DateUtil.now());
&#125;</code></pre></div>
<p>这样我们就可以获得一个动态刷新的课程成绩缓存</p>
<blockquote>
<p>值得一提的是，此处定时事务注解<code>@Scheduled</code>指定了<code>fixedDelay</code>属性，他的特点是在该方法执行结束后才开始计时，这样能够避免数据的冲突。</p>
</blockquote>
<p>同样的道理，我们可以进一步定义一个定时事务去求解所有同学的总成绩排名</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Scheduled(initialDelay &#x3D; 2 * MicroSecondsPerMinute, fixedDelay &#x3D; 3 * MicroSecondsPerMinute)
public void refreshTotalRank() &#123;
    SystemApplicationListener.logger.info(&quot;Begin refresh total rank&gt;&gt;&gt;&quot; + DateUtil.now());
    List&lt;Student&gt; studentList &#x3D; studentRepository.findAll();
    for (Student value : studentList) &#123;
        SystemApplicationListener.logger.info(value.toString());
    &#125;
    List&lt;TotalScoreDTO &gt; totalScoreDTOList &#x3D; globalScoreService.getScoresForAllStudents();
    totalScoreDTOList &#x3D; globalScoreService.getRanksForAllStudents(totalScoreDTOList);
    for (TotalScoreDTO value : totalScoreDTOList) &#123;
        SystemApplicationListener.logger.info(value.toString());
    &#125;
&#125;</code></pre></div>
<p>可以看到，这个方法非常明显地体现了对前述几个方法的调用和整合，同时又保证了每个方法的独立性，有效降低方法之间的耦合度。因此，下面进行简历数据的处理的时候同样调用一部分方法，由此可以看出本作品功能之间具有较为良好的独立性和可复用性。</p>
<h3 id="简历业务的实现">简历业务的实现</h3>
<p>对于个人简历业务的处理，此处略过Web层的分析，首先在服务层调用服务实现层的方法获得学生对象，该对象将会在后面面反复使用，可以说他是整个子业务的核心与灵魂</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 获取学生对象
 *
 * @param studentId 学生Id
 * @return 返回对象
 *&#x2F;
public Student getStudent(Integer studentId) &#123;
    SystemApplicationListener.logger.warn(&quot;getStudent:&quot; +studentId.toString());
    Student student &#x3D; null;
    Optional&lt;Student&gt; op;
    op &#x3D; studentRepository.findById(studentId);
    if (op.isPresent()) &#123;
        student &#x3D; op.get();
    &#125;
    return student;
&#125;</code></pre></div>
<p>在此之后，如前面所说，我们需要获得某个学生的成绩，因此这里还需要考虑一些方法。首先是如何获取指定科目的成绩。</p>
<p>由于缓存在Redis中，本质上讲使用一个Map存放数据，因此这里只需给出一个成绩，由于Map是基于一个红黑二叉树实现的，此处可以实现毫秒级的查询速度，代码大概是这个样子</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 基于课程的所有排名，根据成绩匹配其排名
 *
 * @param courseRankDTOList 包装后的成绩列表
 * @param score             需要查询的成绩
 * @return 返回对应的CourseRankDTO
 *&#x2F;
public CourseRankDTO getCourseRank(List&lt;CourseRankDTO&gt; courseRankDTOList, Integer score) &#123;
    for (CourseRankDTO value : courseRankDTOList) &#123;
        if (score.equals(value.getScore())) &#123;
            return value;
        &#125;
    &#125;
    return new CourseRankDTO();
&#125;</code></pre></div>
<p>相应的，还需要一个方法取出该学生的总成绩和排名信息，其原理也是相似的</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 获取某个学生的排名信息
 *
 * @param score 学生的成绩
 * @return 排名信息DTO
 *&#x2F;
public TotalRankDTO getStudentForStudent(Double score) &#123;
    List&lt;TotalRankDTO&gt; totalRankDTOList &#x3D; new ArrayList&lt;&gt;();
    List&lt;String&gt; serializedTotalRank &#x3D; globalScoreRepository.getAllRange(&quot;totalRank&quot;);
    for (String str : serializedTotalRank) &#123;
        totalRankDTOList.add(TotalRankSerializator.deserializeTotalRank(str));
    &#125;
    for (TotalRankDTO value : totalRankDTOList) &#123;
        if (value.getAverageScore().equals(score)) &#123;
            return value;
        &#125;
    &#125;
    return new TotalRankDTO();
&#125;</code></pre></div>
<p>此处需要补充一些对前端的介绍，基于已有的前端，我们对此进行了一些功能的添加。首先是对于基本信息的一些完善，比如</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div
  class&#x3D;&quot;item&quot;
  style&#x3D;&quot;
    display: flex;
    flex-direction: column;
    align-content: center;
    align-items: start;
  &quot;
&gt;
  &lt;div&gt;姓名： &#123; &#123; myName &#125; &#125;&lt;&#x2F;div&gt;
  &lt;div&gt;性别： &#123; &#123; sex &#125; &#125;&lt;&#x2F;div&gt;
  &lt;div&gt;年龄： &#123; &#123; age &#125; &#125;&lt;&#x2F;div&gt;
  &lt;div&gt;学院专业： &#123; &#123; overview &#125; &#125;&lt;&#x2F;div&gt;
  &lt;div&gt;学号： &#123; &#123; studentNum &#125; &#125;&lt;&#x2F;div&gt;
  &lt;div&gt;联系方式： &#123; &#123; contact &#125; &#125;&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre></div>
<p>针对每个人的成绩，我们使用一个雷达图进行展示。图像的绘制基于<code>vue-charts</code>组件，图表支持动画以及动态调整，能够十分形象的展示数据，前端部分主要由这几个语句构建</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;el-card class&#x3D;&quot;box-card&quot;&gt;
  &lt;div
    style&#x3D;&quot;
      display: flex;
      flex-direction: column;
      align-content: center;
      align-items: center;
    &quot;
  &gt;
    &lt;div class&#x3D;&quot;card-header;margin-bottom:36px&quot;&gt;&#123; &#123; myName &#125; &#125;的综合成绩分布&lt;&#x2F;div&gt;
    &lt;Radar
      v-if&#x3D;&quot;studyChartLoaded&quot;
      :chart-options&#x3D;&quot;studyChartOptions&quot;
      :chart-data&#x3D;&quot;studyChartData&quot;
      :chartId&#x3D;&quot;studyChartId&quot;
      style&#x3D;&quot;width: 400px&quot;
    &#x2F;&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;el-card&gt;</code></pre></div>
<p>后端需要提供两个列表，分别保存<code>label</code>和每个科目的成绩数据，其逻辑如下</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
     * 获取学生的所有成绩信息
     *
     * @param student             学生对象
     * @param courseScoresDTOList 学生的所有成绩列表
     * @return 图表数据DTO
     *&#x2F;
    public ChartInformationDTO getStudyChartInformation(Student student, List&lt;CourseScoresDTO&gt; courseScoresDTOList) &#123;
        ChartInformationDTO chartInformationDTO &#x3D; new ChartInformationDTO();
        List&lt;String&gt; studyChartLabels &#x3D; new ArrayList&lt;&gt;();
        List&lt;Object&gt; studyChartDatasets &#x3D; new ArrayList&lt;&gt;();
        Map&lt;String, Object&gt; datasetItem &#x3D; new HashMap&lt;&gt;();
        List&lt;Integer&gt; datasetItemData &#x3D; new ArrayList&lt;&gt;();
        for (CourseScoresDTO value : courseScoresDTOList) &#123;
            studyChartLabels.add(value.getCourse());
            datasetItemData.add(value.getScore());
        &#125;
        datasetItem.put(&quot;data&quot;, datasetItemData);
        &#x2F;&#x2F; 掠过部分代码
        datasetItem.put(&quot;borderColor&quot;, &quot;#79bbff&quot;);
        studyChartDatasets.add(datasetItem);
        chartInformationDTO.setLabels(studyChartLabels);
        chartInformationDTO.setDatasets(studyChartDatasets);
        return chartInformationDTO;
    &#125;</code></pre></div>
<p>同理，我们还可以的到另一个图表，这里不做赘述。</p>
<p>下一步，建立一个生成器来解析渲染其他内容，这样一个生成器每个单元由<code>title</code>和<code>content</code>两个字段组成，默认将会在同一行显示。<code>content</code>中的内容通常使用<code>StringBuilder</code>生成并使用<code>&lt;div&gt;</code>标签包裹、<code>&lt;/br&gt;</code>标签表明换行，前端部分逻辑如下所示</p>
<div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div
  class&#x3D;&quot;item&quot;
  style&#x3D;&quot;
    display: flex;
    flex-direction: column;
    align-content: start;
    align-items: start;
  &quot;
&gt;
  &lt;el-row
    type&#x3D;&quot;flex&quot;
    style&#x3D;&quot;margin-left: 12px; margin-right: 12px; width: 100%&quot;
    :gutter&#x3D;&quot;110&quot;
    v-for&#x3D;&quot;(item, i) in attachList&quot;
    :key&#x3D;&quot;i&quot;
  &gt;
    &lt;div class&#x3D;&quot;paragraph-header&quot;&gt;&#123; &#123; item.title &#125; &#125;&lt;&#x2F;div&gt;
    &lt;div v-html&#x3D;&quot;item.content&quot;&gt;&lt;&#x2F;div&gt;
  &lt;&#x2F;el-row&gt;
&lt;&#x2F;div&gt;</code></pre></div>
<p>后端信息的填充基本是下面的形式</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">m &#x3D; new HashMap&lt;&gt;();
m.put(&quot;title&quot;, &quot;--------&quot;);
m.put(&quot;content&quot;, &quot;&quot;);
attachList.add(m);
m &#x3D; new HashMap&lt;&gt;();
m.put(&quot;title&quot;, &quot;教学活动&quot;);
m.put(&quot;content&quot;, &quot;&quot;);
attachList.add(m);
pdfInfo.add(m);

m &#x3D; new HashMap&lt;&gt;();
m.put(&quot;title&quot;, &quot;实践信息&quot;);
StringBuilder practiceInformation &#x3D; new StringBuilder(&quot;&lt;div&gt;&quot;);
for (Practice value : student.getPractices()) &#123;
    practiceInformation.append(value.toString());
    practiceInformation.append(&quot;&lt;&#x2F;br&gt;&quot;);
&#125;
practiceInformation.append(&quot;&lt;&#x2F;div&gt;&quot;);
m.put(&quot;content&quot;, practiceInformation.toString());
attachList.add(m);</code></pre></div>
<p>基于上面的内容，我们就可以得到一份图文并茂的简历页。</p>
<h3 id="服务部署">服务部署</h3>
<h4 id="nginx配置">Nginx配置</h4>
<p>Nginx是一个高效稳定、使用广泛的Web和反向代理服务器，本项目使用它作为Web服务器，此处略过其安装过程，最终配置文件的主要部分为</p>
<div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">server &#123;
	listen 80 default_server;
	listen [::]:80 default_server;

	root &#x2F;var&#x2F;www;

	index index.html;

	server_name localhost;

	location &#x2F; &#123;
		root &#x2F;var&#x2F;www&#x2F;hexo;
		index index.html index.htm;
		try_files $uri $uri&#x2F; &#x3D;404;
	&#125;

	location &#x2F;blog &#123;
		alias &#x2F;var&#x2F;www&#x2F;hexo;
		add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;
		index index.html index.htm;
	&#125;

	location &#x2F;java &#123;
		alias &#x2F;var&#x2F;www&#x2F;java_course;
		index index.html;
	&#125;
&#125;</code></pre></div>
<p>域名下二级站点<code>/java</code>将只指向本作品的前端<code>index.html</code>文件启动服务，Nginx将持续监听80端口的请求。</p>
<p>使用以上配置即可实现对前端界面的访问。但是前端对后端的请求和访问是另一个新的问题，此处会有一个我们所谓的跨域问题。</p>
<h4 id="跨域问题的解决">跨域问题的解决</h4>
<p>首先需要在后端<code>controller</code>类头上声明<code>@CrossOrigin(orgin="*")</code>注解，前端直接请求服务器域名，并对Nginx加入以下配置</p>
<div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">location &#x2F;api&#x2F; &#123;
		proxy_redirect off;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_pass http:&#x2F;&#x2F;127.0.0.1:9090;
		proxy_buffer_size 64k;
		proxy_buffers 32 32k;
		proxy_busy_buffers_size 128k;
	&#125;</code></pre></div>
<p>该配置将形如<code>~/api</code>的请求进行转发，代理到本机的<code>127.0.0.1:9090</code>端口，并将请求得到的结果返回给请求方。由此配置杰克完成前后端在一台服务器上的部署。</p>
<h2 id="总结体会">总结体会</h2>
<h3 id="郭苏睿">郭苏睿</h3>
<p>本次课设我学习到一般后端服务的架构思路以及Spring框架的一些思想，能够将分层思想应用到单体应用的设计中，得到耦合度低、可复用能力强的应用架构。掌握了MySQL和Redis的入门知识，进一步加深对SQLite数据库的认识。具备了从需求分析、应用设计和具体实现再到使用Maven编译jar包部署到服务器。Git的理解和使用更深了一步，逐渐掌握大型工程的管理和控制。了解了关于UML图的知识，在与他人交流、文件撰写时效率更高。</p>
<h3 id="何硕">何硕</h3>
<p>我在本次课设中学到了很多的东西，比如各种类表的绘制，数据库的使用；如何提高编程效率、设计算法的技巧；如何高效使用工具来寻找资源，用科学分类的方法管理文档，养成了良好的代码规范，形成了规范的代码意识。</p>
<p>在做课设时，写sql表时，刚开始非常不习惯，看表时很奇怪，但随着学习的深入我看懂了，并应用了到实践中了，我又多会了一门语言。</p>
<h3 id="胡钊">胡钊</h3>
<p>本次课设我学会了网络协作编程，对于类之间的关系有了更加深刻的认识，也明白了类的可见性在编程中的重要性。对于接口的认识更加深刻。在查找资料的过程中，学会了JavaScript的基本内容，熟练了yaml语言的基本语法，学会了数据库的互连与互通，通过对于数据库的学习，我也对基本的数据结构有了大致的理解，也学会了与之相关的方法。学会了通过git实现多人编程。提高了阅读代码的能力，也养成了编写注释的习惯。也学会了绘制简单的UML类图，对于I/O流，“多线程”“一对多““多对多”等概念的理解更加深刻。</p>
<h3 id="吕俊安">吕俊安</h3>
<p>本次课程设计是我第一次参与设计真正的编程项目。在本次课设中，我认识到了代码风格习惯规范的重要性，意识到了积极、规范撰写注释的必要性，也认识到了代码安全的重要性。在本次课设中，我体验了通过网络协作编程的过程，熟悉了应用程序软件架构模型和应用模式的结构，巩固了Java语言的语法结构，更加深刻地认识了类的可见性和静态等特性对程序项目结构的影响，学习了有关数据库的常用操作和yaml语言的基本语法。同时，在本次课设中，我对通过算法和数据结构优化程序时空复杂度有了新的认识，更加清晰地了解程序中为追求更好地用户体验而对程序某些细节所作的妥协，通过在设计时对哈希表、红黑树、链表、trie树、哈夫曼编码等数据结构的取舍，让我认识到了程序设计时所需要综合考虑的各种问题。除此之外，我对Java Spring、IO流和文件以及socket网络编程等技术也有了了解。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux应用</title>
    <url>/blog/posts/7ae00066/</url>
    <content><![CDATA[<h2 id="课程基础">课程基础</h2>
<h3 id="计算机硬件系统基本原理">计算机硬件系统基本原理</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdpoolvpxj31000js0xa.jpg" alt="image-20211214220439572" /><figcaption aria-hidden="true">image-20211214220439572</figcaption>
</figure>
<h3 id="操作系统发展简史">操作系统发展简史</h3>
<h3 id="操作系统定义">操作系统定义</h3>
<h3 id="linux内核组成及简介">Linux内核组成及简介</h3>
<ul>
<li><p>基本组成：Kernel(内核)、Shell、Applications</p></li>
<li><p>Linux启动顺序：init -&gt; login -&gt; passwd -&gt; shell</p>
<h4 id="关于kernel">关于Kernel</h4>
<ul>
<li><p>管理程序的运行，为程序分配资源，并且处理程序之间的通信。</p></li>
<li><p>管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其它块设备的操作。</p></li>
<li><p>管理存储器，为程序分配内存，并且管理虚拟内存。</p></li>
<li><p>管理输入、输出，将设备映射成设备文件。</p></li>
<li><p>管理网络。</p></li>
</ul>
<h4 id="关于shell">关于Shell</h4>
<ul>
<li>Shell本身是一个解释器，是Kernel和用户之间的接口</li>
<li>Shell是一种脚本语言(Shell script)</li>
<li>Shell会在用户登录后启动</li>
<li>Shell能够为用户屏蔽内核的复杂性并保护内核</li>
<li>Shell有好几种，常见的如bash，csh，zsh</li>
</ul>
<h4 id="关于application">关于Application</h4>
<ul>
<li>Linux应用程序：标准的LInux应用程序都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等</li>
</ul></li>
</ul>
<h2 id="linux基本命令">Linux基本命令</h2>
<h3 id="登录和退出">登录和退出</h3>
<ul>
<li>登录</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$login:userName
$passwd:[your password]</code></pre></div>
<ul>
<li>退出</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;ctrl + D&gt;
$exit
$logout</code></pre></div>
<blockquote>
<p>logout是专门用于命令行中退出当前登录的Shell命令，<strong>exit也具有logout的功能</strong>，但exit同时还能<strong>用于退出执行的shell脚本</strong>，并通过设置参数返回给调用shell的程序本身，这个可以方便协同跨程序间的调用。</p>
</blockquote>
<h3 id="关于echo">关于echo</h3>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># Enter &quot;\&quot; to have a new line
$echo &quot;Hello&quot;
$echo Hello \World</code></pre></div>
<ul>
<li>添加选项 -n 表示输出文字后不换行</li>
<li>字符串加不加引号都可以，加双引号全部视作字符串但保留变量引用，<strong>单引号全部强制视作字符串</strong></li>
</ul>
<h3 id="日期和时间">日期和时间</h3>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 显示时间
$date
# 设置时间
$date -s 
# 显示日历
$cal[month][year]
# 显示当前月份
$cal
# 显示年份（0&lt;year&lt;1000）
$cal[year]</code></pre></div>
<ul>
<li>date实例</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$date    显示日期和时间	
-&gt; Wed Sep 29 09:58:29 CST 2004
#date -s 20041229    设置日期	
-&gt; Wed Dec 29 00:00:00 CST 2004
#date -s 12:23:23    设置时间
#date -s “2006-10-10 12:12:23″</code></pre></div>
<blockquote>
<p>设置日期和时间需要管理员权限</p>
</blockquote>
<h3 id="其他基本命令">其他基本命令</h3>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 清屏
$clear
# 显示登录到系统的所有用户的信息
$who
# 显示当前登录的用户的信息
$whoami
# 打印当前目录
$pwd
# 中断当前的命令并返回Shell
&lt;ctrl-c&gt;     
# 中断当前的通信或从文件中退出
&lt;Ctrl-d&gt;     
# 删除整行
&lt;ctrl-u&gt;     
</code></pre></div>
<h3 id="关于mail">关于mail</h3>
<ul>
<li><p>发送mail：$mail [-n] address</p></li>
<li><p>一旦邮件被打开，其将被放在 $HOME/mbox目录中，若想再看这些信息则用：mail –f</p></li>
</ul>
<h3 id="关于man">关于man</h3>
<h3 id="关于source命令">关于source命令</h3>
<ul>
<li>source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于<strong>重新执行刚修改的初始化文件</strong>，使之立即生效，而不必注销并重新登录。</li>
</ul>
<blockquote>
<p>/etc/profile:此文件为<strong>系统的每个用户设置环境信息</strong>,当用户<strong>第一次登录</strong>时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.</p>
<p>/etc/bashrc:为<strong>每一个运行bash shell的用户执行此文件</strong>.当bash shell被打开时,该文件被读取.</p>
<p>~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p>
<p>~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件.</p>
</blockquote>
<ul>
<li>bash是大多数Linux系统默认的shell 。</li>
<li>bash的命令语法是Bourne shell命令语法的超集。数量庞大的Bourne shell脚本大多不经修改即可以在bash中执行，只有那些引用了Bourne特殊变量或使用了Bourne的内置命令的脚本才需要修改。</li>
</ul>
<h2 id="文件系统">文件系统</h2>
<ul>
<li>Linux文件名最长256个字符</li>
<li>不能含有"/"（路径的分隔符）</li>
<li><strong>大小写敏感</strong></li>
<li>由一组普通文件、目录文件、设备文件和<strong>符号链接</strong>组成</li>
<li>Linux下的所有文件都依附在根目录/下</li>
</ul>
<h3 id="文件类型">文件类型</h3>
<ul>
<li><p>普通文件</p>
<ul>
<li>二进制文件</li>
<li>文本文件(.txt)</li>
</ul></li>
</ul>
<blockquote>
<p>从本质上来说文本文件和二进制文件之间没有什么区别，因为他们在硬盘上都有一种的存放方式：<strong>二进制</strong> 但是如果要对他们有些区分的话，那可以这样理解。我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的<strong>部分数值</strong>来表示的，也就是说，-128—127之间还有一些数据没有对应任何字符的任何字节。如果一个文件中的<strong>每个字节的内容都是可以表示成字符的数据</strong>，我们就可以称这个文件为文本文件，可见，<strong>文本文件只是二进制文件中的一种特例</strong>。 为了与文本文件相区别，人们又把除了文本文件以外的文件称为二进制文件。 由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件</p>
</blockquote>
<ul>
<li><p>目录文件</p>
<ul>
<li><p>是一个包含文件的容器，用于存放目录中文件列表信息。</p></li>
<li><p>目录文件存储一组相关文件的<strong>位置、大小等与文件有关的信息</strong>，但它不包含具体的文件内容，因而和常规文件相比占用的<strong>磁盘空间很小</strong>。</p></li>
<li><p>每一项(entry) 主要表示的是一个文件名(或子目录名)以及文件的<strong>索引节点号</strong>(i-node number ) 。</p>
<p><strong>索引节点号：</strong>指向<strong>该文件内容所在的数据块的位置，记录了该文件的属性</strong></p>
<p>通过 i-node表与文件之间建立对应关系，<strong>目录文件是存放文件名唯一的地方</strong>，<strong>但文件名不放在 i-node表中</strong></p></li>
<li><p>访问一个文件或子目录时，首先访问他所在的目录（因此需要目录文件的执行权限），找到该文件的i-node值，然后再查找i-node 表找出相应的i-node项（i-node entry），从而找到了相应的数据。</p></li>
<li><p>在Linux系统中，也可以把目录文件看作是将文<strong>件的名称和它的索引节点号</strong>结合在一起的一张表。</p></li>
</ul></li>
<li><p>设备文件</p>
<ul>
<li>块设备：以块为单位进行随机存取。如软盘、光盘和硬盘</li>
<li>字符设备：以单个字符为单位进行顺序存取。如：打印机终端、键盘、鼠标</li>
</ul>
<blockquote>
<p>在Linux中 ，因为它是Unix的一种，系统可以使用的不同文件系统，不能像Windows或DOS一样通过设备标识符存取(例如一个驱动器数字或一个驱动器命名)， 而是它们被构建成为一个单一的层次树状结构以作为代表文件系统的实体。</p>
</blockquote></li>
</ul>
<h3 id="关于i-node">关于i-node</h3>
<ul>
<li><p>i-node是什么</p>
<p>硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是<strong>一次性读取一个：“块”（block），每个”块”（block）由八个连续的sector组成</strong>。这种由多个扇区组成的<strong>“块”，是文件存取的最小单位</strong>。”块”的大小，最常见的是4KB，文件数据都储存在”块”中，那么还必须找到<strong>一个地方储存文件的元信息</strong>，比如文件的创建者、文件的创建日期、文件的大小等等。这种<strong>储存文件元信息的区域就叫做inode</strong>，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p></li>
<li><p>i-node的内容</p>
<p>inode包含文件的元信息，具体有以下内容：</p>
<ul>
<li><p>文件的字节数</p></li>
<li><p>文件拥有者的User ID</p></li>
<li><p>文件的Group ID</p></li>
<li><p>文件的读、写、执行权限</p></li>
<li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li>
<li><p>链接数，即<strong>有多少文件名指向这个inode</strong></p></li>
<li><p>文件数据block的位置</p></li>
</ul>
<blockquote>
<p>可以用stat命令查看某个文件的inode信息</p>
</blockquote></li>
<li><p>i-node号码</p>
<p>每个<strong>inode都有一个号码</strong>，Unix/Linux系统<strong>内部不使用文件名，而使用inode号码来识别文件</strong>。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<blockquote>
<p>使用ls -i命令，可以看到文件名对应的inode号码</p>
</blockquote></li>
<li><p>目录文件和i-node</p>
<p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：<strong>所包含文件的文件名，以及该文件名对应的inode号码。</strong> ls命令只列出目录文件中的所有文件名，ls -i命令列出整个目录文件，即文件名和inode号码</p>
<p>目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以<strong>如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中</strong>，而<strong>读取inode节点内的信息需要目录文件的执行权限（x）</strong>。</p></li>
</ul>
<h3 id="挂接mount">挂接（mount）</h3>
<ul>
<li><p>Linux 通过挂接（mount）一个文件系统将该新文件系统加入它的文件系统树中。</p></li>
<li><p>所有的文件系统, 不管是什么类型，都挂接在文件系统树的一个目录上并且<strong>该文件系统之上的文件将掩盖掉这个挂接目录中原来存在的内容</strong>。</p></li>
<li><p>这个目录称为挂接目录或挂接点。当文件系统被卸掉之后，挂接目录中原来的文件才再次可见。</p></li>
</ul>
<h3 id="用户主目录">用户主目录</h3>
<ul>
<li>用户每次登录后自动位于主目录下</li>
<li>用户主目录由系统管理员在创建帐号时建立，每个合法的用户在文件系统中都有一个唯一的起始目录。默认的主目录位于<strong>/home目录下，以该用户名命名</strong>。</li>
</ul>
<h3 id="链接文件">链接文件</h3>
<ul>
<li>目录中每一对<strong>文件名称和索引节点号</strong>称为一个链接</li>
</ul>
<h4 id="硬链接">硬链接</h4>
<ul>
<li>原文件名和链接文件名都指向相同的<strong>物理位址</strong>（i-node number）</li>
<li>如果删除硬链接文件的源文件，<strong>硬链接文件仍然存在，而且保留了原有的内容</strong></li>
<li>不允许<strong>普通用户对目录建立硬链接</strong>；硬链接不能跨越文件系统（不能跨越不同的分区）</li>
</ul>
<h4 id="符号链接">符号链接</h4>
<ul>
<li>内容是它所<strong>链接的文件的路径名</strong></li>
<li>每个链接文件<strong>都有各自的索引节点号</strong></li>
<li>如果删除符号链接文件的源文件，符号链接文件将无法找到原有资料</li>
<li>可用于链接目录，且符号链接能够跨越文件系统</li>
</ul>
<h3 id="相关指令">相关指令</h3>
<h4 id="catmore">cat、more</h4>
<ul>
<li><p>cat是将文件的文本内容一次全部显示在屏幕上，more可以分屏显示全部内容</p></li>
<li><p>cat（concatenate）用于连接文件并打印到标准输出设备上:</p>
<ul>
<li>-n(number):打印行号</li>
<li>-b(blank):打印行号，<strong>空行不编号</strong></li>
<li>cat可以通过<strong>重定向</strong>实现文件的合并、建立、覆盖和添加内容等操作</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：
$cat -n textfile1 &gt; textfile2
# 把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：
$cat -b textfile1 textfile2 &gt;&gt; textfile3
# 清空 &#x2F;etc&#x2F;test.txt 文档内容：
$cat &#x2F;dev&#x2F;null &gt; &#x2F;etc&#x2F;test.txt
# 例如要制作软盘的镜像文件，将软盘放好后输入：
$cat &#x2F;dev&#x2F;fd0 &gt; OUTFILE
# 相反的，如果想把 image file 写到软盘，输入：
$cat IMG_FILE &gt; &#x2F;dev&#x2F;fd0</code></pre></div></li>
<li><p>more</p>
<ul>
<li>F或space：下一页</li>
<li>B:上一页</li>
<li>Enter:向下移动一行</li>
<li>q:退出</li>
</ul></li>
</ul>
<h4 id="wc">wc</h4>
<ul>
<li>统计文件中的字符数、单词数和行数</li>
<li>若不给出文件名，则从标准输入中读取</li>
<li>选项，若不加选项则会列出字符数、单词数和行数。格式为：<strong>行数 单词数 字符数 文件名</strong>
<ul>
<li>-c(char):显示字符数</li>
<li>-l:显示行数</li>
<li>-w:显示单词数</li>
</ul></li>
</ul>
<h4 id="ls">ls</h4>
<ul>
<li>不带任何选项的ls命令只列出文件名</li>
<li>选项
<ul>
<li>-a:列出所有文件，包含.开头的隐藏文件</li>
<li>-l：长格式列出文件，格式为：文件类型 操作权限 链接数 属主名 属组名 字节数 最近修改时间 文件名。其中文件类型包括：
<ul>
<li>d：目录文件</li>
<li>-：普通文件</li>
<li>l(link)：符号链接文件</li>
<li>b(byte)：块设备文件</li>
<li>c(char)：字符设备文件</li>
</ul></li>
<li>-d：显示<strong>目录名而不现实文件</strong></li>
<li>-R(recursion)：递归列出子目录</li>
<li>-r(reverse)：逆序显示文件名列表</li>
<li>-x：显示时以字母顺序，正常是按照ASCII码顺序</li>
<li>--color：着色显示(/etc/DIR_COLORS可以修改颜色)
<ul>
<li>绿色：可执行文件</li>
<li>蓝色：目录</li>
<li>红色：压缩文件</li>
<li>浅蓝色：链接文件</li>
<li>灰色：一般文件</li>
</ul></li>
</ul></li>
</ul>
<h4 id="touch">touch</h4>
<ul>
<li>以当前时间创建文件或更新已有文件的时间戳</li>
<li>时间格式为[YYYY] [MMDDhhmm]</li>
<li>选项为-t</li>
</ul>
<h4 id="cp-src_file-dst_file">cp src_file dst_file</h4>
<ul>
<li>若目标文件名已存在，则会<strong>覆盖目标文件</strong></li>
<li>如果目的文件是一个目录，那么将源文件拷贝到目录下</li>
<li>拷贝多个文件，则最后一个参数是<strong>目标目录</strong></li>
<li>选项
<ul>
<li>-i：在覆盖文件前提示用户</li>
<li>-R/r：递归复制目录</li>
</ul></li>
</ul>
<blockquote>
<p>​ 可以试一下 -f 选项，-f 一般表示强制执行（force）：cp -f file dir ​ 但好像结果并不像我们希望的那样，系统依然会有覆盖提示。为什么呢？ ​ 原因很简单，系统将 <strong>cp 命令alias为 cp -i</strong>。当我们执行cp命令的时候，系统往往执行的是cp -i，-i 选项表示有交互的提示信息，所以执行 cp -f 的时候，<strong>系统实际执行的是 cp -i -f</strong>， 所以仍然会有覆盖提示。 　　想要执行原始的cp也很简单，可以在<strong>调用cp的时候加入绝对路径</strong>，当然还可以直接执行下面的语句：<strong>-f file dir</strong></p>
</blockquote>
<h4 id="mv">mv</h4>
<ul>
<li><p>对文件进行名称更改或路径迁移</p>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 把文件aaa改名为bbb
$mv aaa  bbb         
# 把文件aaa移动到&#x2F;home&#x2F;paul下
$mv aaa &#x2F;home&#x2F;paul  
# 将version1改名为proposal，并提示用户确认。
$mv -i version1 proposal 
# 把当前目录下的file1文件移动到当前目录的父目录下
$mv file1 .. 
# 另一种文件重命名的方式
$mv file1  ..&#x2F;new-filename

</code></pre></div></li>
<li><p>选项</p>
<ul>
<li>-f：强制执行</li>
<li>-i：提示覆盖信息</li>
</ul></li>
</ul>
<h4 id="rm">rm</h4>
<ul>
<li>选项
<ul>
<li>-f</li>
<li>-r</li>
<li>-i</li>
</ul></li>
</ul>
<h4 id="rmdir">rmdir</h4>
<ul>
<li>删除空目录</li>
<li>对该目录的<strong>父目录文件必须有写权限</strong></li>
<li>被删除的目录必须是<strong>空目录</strong>，否则只能考虑-p</li>
<li><strong>比起rm -rf来，rmdir是更安全的操作</strong></li>
<li>选项
<ul>
<li>-p：由指定目录的最底层开始，<strong>逐层尝试删除空目录</strong>，当碰到非空目录时便停止删除的动作。</li>
</ul></li>
</ul>
<h4 id="mkdir">mkdir</h4>
<ul>
<li><p>创建新目录时必须对其<strong>父目录文件有写权限</strong></p></li>
<li><p>选项</p>
<ul>
<li>-p(parent)：自动建立父目录</li>
<li>-m(mode)：建立指定权限的目录</li>
</ul></li>
</ul>
<h4 id="whereis">whereis</h4>
<ul>
<li>显示指令的二进制码、原始码与在线手册说明文件的存放目录</li>
<li>选项
<ul>
<li>-b：只查找二进制</li>
<li>-m：只查找在线手册</li>
<li>-s：只查找原始码文件</li>
</ul></li>
<li>whereis找不到某个文件的部分原因可能是这个文件没有存在于任何whereis命令搜索的子目录中</li>
<li>whereis命令检索的子目录是固定编写在它的程序中的</li>
</ul>
<h4 id="locate">locate</h4>
<ul>
<li>使用的是一个文件名数据库</li>
<li>查找文件位置又比whereis命令速度更快</li>
<li>数据库的更新是<strong>每星期执行一次</strong>,可执行 updatedb 手工更新数据库</li>
</ul>
<h4 id="ln">ln</h4>
<ul>
<li><p><strong>一个物理文件可以有多个文件名</strong></p></li>
<li><p>ln用于对一个已经存在的文件再创建一个新的链接，而不复制文件的内容</p></li>
<li><p>ln后的链接文件名与物理文件<strong>具有相同的权限</strong></p></li>
<li><p>格式： ln [-s] target [link name]</p>
<ul>
<li><p>-s(soft)：符号链接。不加此选项代表硬连接</p></li>
<li><p>Target:链接所对应的源文件</p></li>
<li><p>Link name：链接文件名。<strong>如果是符号链接，也可以是目录名</strong></p></li>
</ul></li>
<li><p>ls –l 命令可列出一个文件拥有的硬链接数。</p></li>
</ul>
<h4 id="cd">cd</h4>
<ul>
<li>cd/cd ～：返回到HOME目录下</li>
</ul>
<h2 id="权限管理">权限管理</h2>
<h3 id="用户类型">用户类型</h3>
<ul>
<li>文件所有者：能够设定同组用户和其他用户对该文件的访问权限。一般来说是文件的创建者。</li>
<li>同组用户：具有相同性质的所有用户,被系统管理员分在同一组。<strong>文件所有者或系统管理员</strong>可将文件的权限赋予组内的其它用户。</li>
<li>其他用户：文件所有者或系统管理员还可以将文件的访问权赋予系统中所有其它的用户。这 样,系统中每一位用户可能都能访问你的某一文件或目录。</li>
</ul>
<h3 id="表示方法">表示方法</h3>
<h4 id="用户的表示">用户的表示</h4>
<ul>
<li>所有者u(user)</li>
<li>同组用户g(group)</li>
<li>其他用户o(other)</li>
<li>所有用户a(all)</li>
</ul>
<h4 id="权限的表示">权限的表示</h4>
<ul>
<li><p>三组分别表示文件所有者、同组用户和其他用户的权限</p>
<table>
<thead>
<tr class="header">
<th>rwx</th>
<th>7</th>
<th>4+2+1</th>
<th>读、写、执行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>rw-</td>
<td>6</td>
<td>4+2+0</td>
<td>读、写</td>
</tr>
<tr class="even">
<td>r-x</td>
<td>5</td>
<td>4+1</td>
<td>读、执行</td>
</tr>
<tr class="odd">
<td>r--</td>
<td>4</td>
<td>4+0+0</td>
<td>只读</td>
</tr>
<tr class="even">
<td>-wx</td>
<td>3</td>
<td>2+1</td>
<td>写、执行</td>
</tr>
<tr class="odd">
<td>-w-</td>
<td>2</td>
<td>0+2+0</td>
<td>只写</td>
</tr>
<tr class="even">
<td>---</td>
<td>0</td>
<td>0+0+0</td>
<td>禁止读、写、执行</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="权限控制实例">权限控制实例</h3>
<ul>
<li>在移动文件时不需要被移动文件的权限，但需其<strong>所在目录具有写和执行权限</strong></li>
<li>在目录下<strong>增删文件、子目录</strong>时要有目录的写权限（touch,rm,mkdir,rmdir）</li>
<li>用ls列目录要有<strong>目录的读权限</strong>(这里只读了目录的文件名列表而不涉及到i-node)</li>
<li><strong>进入目录或将该目录作路径分量</strong>时(cd)要有目录的<strong>执行权限</strong>，故要<strong>使用任一个文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。</strong></li>
<li>只有执行权限只能进入目录，不能看到目录下的内容，要想<strong>看到目录下的文件名和目录名，需要可读权限</strong></li>
<li>一个文件能不能被删除，主要看该<strong>文件所在的目录对用户是否具有写权限，</strong>如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外</li>
<li>仅当要打开一个文件时，即执行<strong>涉及到文件内容的操作</strong>时，才需要文件的许可。</li>
</ul>
<h3 id="相关指令-1">相关指令</h3>
<h4 id="chmod">chmod</h4>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ chmod [-options] xyz [filelist]
$ chmod [-options] u&#x2F;g&#x2F;o&#x2F;a  +&#x2F;-&#x2F;&#x3D;  r&#x2F;w&#x2F;x  [filelist]
-c（check）：只有在文件权限确实改变时才进行详细说明；
-f（force）：不打印“权限不能改变”之类的文件错误信息；
-R：递归改变目录及其内容的权限；
-v：详细说明权限的变化。</code></pre></div>
<ul>
<li>用户修改密码，是通过运行命令passwd来实现的，最终必须要修改/etc/passwd文件，而passwd的文件只对于root用户是可写的，而对于所有的他用户来说都是没有写权限的。</li>
</ul>
<h4 id="chown">chown</h4>
<ul>
<li>用于改变文件的所有者,可以同时也改变其所属用户组 $chmod user:usergroup file</li>
<li>仅用于<strong>系统管理员</strong>对文件和用户的管理</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ chown [-options] user[：group] filelist 
 -R：递归改变目录及其内容的所属用户或用户组；</code></pre></div>
<h4 id="su">su</h4>
<h4 id="sudo">sudo</h4>
<h2 id="进程管理">进程管理</h2>
<ul>
<li><p>进程是程序的执行的过程，是<strong>执行的程序</strong></p></li>
<li><p>程序是静态的，是保存在磁盘上的<strong>可执行代码和数据</strong>的集合；</p>
<p>进程是动态的，是Linux系统的基本调度单位</p></li>
<li><p>PID(Process Identity number)：一个PID唯一的标识一个进程。</p>
<p>PPID(Parent Process ID)：进程的父进程号。</p></li>
</ul>
<h3 id="init进程">init进程</h3>
<ul>
<li><p>内核启动后的第一个进程，其PID=1</p></li>
<li><p>扮演<strong>终结父进程</strong>的角色，所有进程追溯其祖先最终都会落到init进程身上。</p></li>
<li><p>因为init进程永远不会被终止，所以系统总是可以确信它的存在，并在必要的时候以它为参照。如果某个进程在它衍生出来的全部子进程结束之前被终止，此时那些<strong>失去了父进程的子进程就都会以init作为它们的父进程</strong>。</p></li>
</ul>
<h3 id="启动方式">启动方式</h3>
<ul>
<li><p>手工启动：当时设置当时启动</p>
<ul>
<li><p>前台启动:启动一个进程后，如果不中断或挂起该进程，用户会<strong>一直被禁止与 Shell 进行交互</strong>，直至该进程执行结束。经常用于一般Linux命令的执行，和一些不太耗时的进程的启动。</p>
<p>停止: &lt;Ctrl+c&gt; 挂起：&lt;Ctrl+z&gt;</p></li>
<li><p>后台启动:启动进程后，用户仍可以与Shell进行交互。可用于一些耗时长的作业运行。</p>
<p>启动：$command &amp;，附一个<strong>&amp;</strong></p>
<p>终止和挂起后台进程：<strong>使用kill命令</strong></p></li>
</ul></li>
<li><p>调度启动：用户可事先进行设置安排，指定任务运行的时间或场合，到时候由系统自动启动进程完成此项任务。</p></li>
</ul>
<h3 id="进程的挂起和恢复">进程的挂起和恢复</h3>
<h4 id="进程挂起">进程挂起</h4>
<ul>
<li>前台进程的挂起： &lt;Ctrl+z&gt;</li>
<li>后台进程的挂起： kill –s 01 {PID|%job ID}</li>
</ul>
<h4 id="进程恢复">进程恢复</h4>
<ul>
<li>恢复到前台： fg %jobID</li>
<li>恢复到后台： bg %jobID</li>
</ul>
<h3 id="相关指令-2">相关指令</h3>
<h4 id="ps">ps</h4>
<ul>
<li><p>确定有哪些进程正在运行以及运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。</p></li>
<li><p>是一个<strong>静态列表</strong>，显示启动这个命令时正在运行的进程的快照</p></li>
<li><p>不跟任何选项表示查看系统中<strong>属于自己的进程</strong></p></li>
<li><p>选项</p>
<ul>
<li>-e：显示<strong>所有</strong>进程</li>
<li>-f(full)：全格式</li>
<li>-l：长格式</li>
<li>-w：宽格式</li>
<li>-a：显示<strong>所有用户</strong>的进程</li>
<li>-u：用户格式，显示用户名和进程起止世间</li>
<li>-x：显示与终端无关的所有进程</li>
</ul>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdmr2rijjj310u0ikwif.jpg" alt="image-20211214202306806" /><figcaption aria-hidden="true">image-20211214202306806</figcaption>
</figure></li>
</ul>
<blockquote>
<p>Linux下显示系统进程的命令ps，最常用的有<strong>ps -ef 和ps aux</strong> (请不要使用ps -aux) 这两个到底有什么区别呢？</p>
<p>显然，没太大差别。</p>
<p>讨论这个问题，要追溯到Unix系统中的两种风格，System Ｖ风格和BSD 风格，ps aux最初用到Unix Style中，而ps -ef被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。</p>
</blockquote>
<blockquote>
<p>linux上进程有5种状态: </p>
<ol type="1">
<li><p>运行(正在运行或在运行队列中等待)</p></li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </p></li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p></li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </p></li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p></li>
</ol>
<p>ps工具标识进程的5种状态码:  1. D 不可中断 uninterruptible sleep <strong>(usually IO)</strong>   1. R 运行 runnable (on run queue)  1. S 中断 sleeping  1. T 停止 <strong>traced or stopped</strong>   1. Z 僵死 a defunct ("zombie") process  注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p>
</blockquote>
<h4 id="top">top</h4>
<ul>
<li>显示的是可根据真实情况 , 定时更新的运行进程列表</li>
<li>与终端设备进行交互，根据用户从终端输入的交互命令来显示或管理进程</li>
<li>交互命令（<strong>注意到排序的指令都是大写</strong>）
<ul>
<li>[Space] 立即刷新显示</li>
<li>d 设置刷新进程的时间间隔，你会被提示输入一个数（秒）</li>
<li>q <strong>退出top命令</strong>。</li>
<li>k <strong>杀死某进程。你会被提示输入进程 ID 以及要发送给它的信号</strong>。<br />
</li>
<li>h 显示帮助屏幕</li>
<li>n 显示的进程数量。你会被提示输入数量。</li>
<li>u 选择用户。</li>
<li>M <strong>按内存用量排序</strong>。</li>
<li>P <strong>按 CPU 用量排序</strong>。</li>
</ul></li>
<li>top命令的功能强于ps，但需要长久占用前台，所以用户应该根据自己的情况来使用这个命令。</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># [例] 键入top命令查看系统状况
$ top
# 当前时间、系统启动时间、当前系统登录用户数目、平均负载。
1：55pm up 7 min， 4 user， load average:0.07，0.09，0.06
# 进程情况，依次为进程总数、休眠进程数、运行进程数、僵死进程数、终止进程数。
29 processes:28 sleeping， 1 running， 0 zombie， 0 stopped
# CPU状态，依次为用户占用、系统占用、优先进程占用、闲置进程占用。
CPU states: 4.5% user， 3.6% system， 0.0% nice， 91.9%
# 内存状态，依次为平均可用内存、已用内存、空闲内存、共享内存、缓存使用内存。
idle
Mem: 38916K av， 18564K used， 20352K free， 11660K shrd， 1220K buff
# 交换状态，依次为平均可用交换容量、已用容量、闲置容量、高速缓存容量
Swap: 33228K av， 0K used， 33228K free， 11820K cached
# 下面就是和ps相仿的各进程情况列表
---------------------------------------------------------------
PID USER PRI NI SIZE RSS SHARE STAT LIB %CPU %MEM TIME 
COMMAND
363 root 14 0 708 708 552 R 0 8.1 1.8 0:00 top
1 root 0 0 404 404 344 S 0 0.0 1.0 0:03 init
2 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 kflushd
3 root -12 -12 0 0 0 SW&lt; 0 0.0 0.0 0:00 kswapd
4 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 md_thread
5 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 md_thread
312 root 1 0 636 636 488 S 0 0.0 1.6 0:00 telnet
285 root 6 0 1140 1140 804 S 0 0.0 2.9 0.00 bash
286 root 0 0 1048 1048 792 S 0 0.0 2.6 0.00 bash
25 root 0 0 364 364 312 S 0 0.0 0.9 0.00 kerneld
153 root 0 0 456 456 372 S 0 0.0 1.1 0.00 syslogd
160 root 0 0 552 552 344 S 0 0.0 1.4 0.00 klogd
169 daemon 0 0 416 416 340 S 0 0.0 1.0 0.00 atd
178 root 2 0 496 496 412 S 0 0.0 1.2 0.00 crond
187 bin 0 0 352 352 284 S 0 0.0 0.9 0.00 portmap
232 root 0 0 500 500 412 S 0 0.0 1.2 0.00 rpc.mountd
206 root 0 0 412 412 344 S 0 0.0 1.0 0.00 inetd
215 root 0 0 436 436 360 S 0 0.0 1.1 0.00 icmplog</code></pre></div>
<blockquote>
<p>什么是系统平均负载(Load average)？ 在Linux系统中，uptime、w、top等命令都会有系统平均负载load average的输出，那么什么是系统平均负载呢？</p>
<p>系统平均负载被定义为在<strong>特定时间间隔内运行队列中的平均进程数</strong>。如果一个进程满足以下条件则其就会位于运行队列中：</p>
<ul>
<li>它没有在等待I/O操作的结果</li>
<li>它没有主动进入等待状态(也就是没有调用'wait')</li>
<li>没有被停止(例如：等待终止)</li>
</ul>
<p>例如： [root@opendigest root]# uptime 7:51pm up 2 days, 5:43, 2 users, load average: 8.13, 5.90, 4.94</p>
<p>命令输出的最后内容表示在过去的1、5、15分钟内运行队列中的平均进程数量。 一般来说只要<strong>每个CPU的当前活动（指一分钟内）进程数不大于3那么系统的性能就是良好</strong>的，如果每个<strong>CPU的任务数大于5，那么就表示这台机器的性能有严重问题</strong>。对于上面的例子来说，假设系统有两个CPU，那么其每个CPU的当前任务数为：8.13/2=4.065。这表示该系统的性能是可以接受的。</p>
</blockquote>
<h4 id="jobs">jobs</h4>
<ul>
<li>用于显示和控制后台正在执行的和被挂起的任务序列。</li>
<li>选项
<ul>
<li>-l：<strong>显示后台任务的进程号与信息</strong>。</li>
<li>-p：<strong>只显示后台任务的 PID</strong>。</li>
<li>-n（new）：显示上次通知用户后，执行状态有更动的后台任务状态。</li>
<li>-r：显示执行中的后台任务。</li>
<li>-s：显示暂停执行的后台任务。</li>
</ul></li>
</ul>
<blockquote>
<p>+号和-号</p>
<p>带有<strong>加号的作业被视为默认作业</strong>，如果命令行没有指定作业编号，则它应该是任何作业控制命令引用的作业。带有减号的作业是下一个默认作业。<strong>一次只有一个作业带有加号,一个作业带有减号</strong></p>
</blockquote>
<h4 id="kill">kill</h4>
<ul>
<li><p>向正在进行的进程发送信号，进程接收到信号后进行信号对应的相应操作</p></li>
<li><p>格式</p>
<p>kill [-option] [signal] {PID | %job ID}</p>
<ul>
<li>signal - 信号。与-s配合使用。不指定则送出信号 15(TERM）</li>
<li>pid - 要终止的进程号</li>
<li>job ID - 要终止的进程对应的后台任务编号。</li>
</ul></li>
<li><p>常用信号</p>
<ul>
<li>信号15（SIGTERM）
<ul>
<li>终止进程运行</li>
<li>为kill命令的缺省信号</li>
<li>经常用于<strong>后台进程的终止</strong></li>
<li>当某个进程占用的CPU时间过多，或是某进程已经挂起，可以用这种方法终止其执行</li>
<li>除root用户外，<strong>一般用户只能终止属于自己的进程</strong></li>
</ul></li>
<li>信号09(SIGKILL)
<ul>
<li><strong>强制</strong>终止进程</li>
</ul></li>
<li>信号01(SIGHUP)（ctrl+Z）</li>
<li>信号02(SIGINT)</li>
</ul></li>
</ul>
<h4 id="nohub">nohub</h4>
<ul>
<li>用于在用户退出系统时，继续执行程序</li>
<li>格式：nohub {command|script} &amp;</li>
</ul>
<h2 id="vi编辑器">Vi编辑器</h2>
<h4 id="启动命令">启动命令</h4>
<ul>
<li>基本语法： vi [-options] [+n] [file]</li>
<li>常用选项：
<ul>
<li>-r 恢复系统突然崩溃时正在编辑的文件。</li>
<li>-R 以只读方式打开文件</li>
<li>+[n] 指明进入vi后直接位于文件的第n行，如果只有“+”而不指定n，则<strong>光标位于文本的最后一行</strong></li>
</ul></li>
</ul>
<h4 id="搜索命令">搜索命令</h4>
<ul>
<li>正向搜索（/）：从光标所在位置起向文件末尾方向搜索。</li>
<li>反向搜索（?）：从光标所在位置起向文件开头方向搜索。</li>
<li>搜索得到结果后，可以使用重复命令n或N沿着相同或相反的方向重复上一次的搜索</li>
</ul>
<h2 id="shell">Shell</h2>
<h3 id="shell的启动和退出">Shell的启动和退出</h3>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$shellname
$exit</code></pre></div>
<h3 id="环境变量和变量">环境变量和变量</h3>
<ul>
<li>环境变量的值只能传递给子进程，而不能传递给它所在的父进程</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 定义变量
$ var&#x3D;value
$ &#123;var&#x3D;value&#125;
# 清除变量
$ unset var
# 显示所有shell环境变量
$ set
# 显示所有当前用户的用户环境变量
$ env</code></pre></div>
<h4 id="环境变量分类">环境变量分类</h4>
<ul>
<li><p>本地环境变量</p>
<ul>
<li><p>只能在当前shell中使用，不能传递给该shell创建的任何子进程</p></li>
<li><p>这个值只在用户当前Shell生命期有意义</p></li>
</ul></li>
<li><p>全局环境变量</p>
<ul>
<li>可以用于所有进程，原则上均为<strong>大写</strong></li>
<li>但赋值后必须将变量值导出，否则无法传递给子进程</li>
<li>子进程不会自动地继承父进程中本地的变量</li>
</ul></li>
</ul>
<h4 id="设置环境变量">设置环境变量</h4>
<ul>
<li>修改文件设置
<ul>
<li>/etc/profile：存放系统管理员设置的环境变量</li>
<li>~/.bash profile：用于增加新变量或覆盖/etc/profile中设置的变量，<strong>每次登录时都会被初始化</strong></li>
</ul></li>
<li>命令行设置
<ul>
<li>显式赋值：var=value。<strong>等号两边不能直接接单独的空格。</strong></li>
<li>read读取：read var1 var2 。若读入个数多于变量，则多出的都赋给最后一个变量；若少，则后面的变量赋空。</li>
</ul></li>
</ul>
<h4 id="shell内嵌变量">Shell内嵌变量</h4>
<ul>
<li><p>HOME：用户主目录的完全路径名</p></li>
<li><p>LOGNAME：登录用户名</p></li>
<li><p>PS1：主提示符。对root用户是#，普通用户是$</p></li>
<li><p>PATH：path1:path2:path3:</p>
<p>添加新的PATH：$PATH=$PATH:filelist\$export PATH</p></li>
</ul>
<h3 id="引号">引号</h3>
<h4 id="双引号">双引号</h4>
<ul>
<li>由双引号括起来的字符，除下面几种符号具有其特殊功能外，其余字符都作为普通字符对待
<ul>
<li>$符号：用其后指定的变量值来代替这个变量</li>
<li> 符号：它是<strong>转义字符</strong>，它告诉Shell不要对其后面的特殊字符($、)进行特殊处理，只当做普通字符即可</li>
<li>引号</li>
</ul></li>
</ul>
<h4 id="单引号">单引号</h4>
<ul>
<li>单引号括起来的所有字符都作为普通字符出现</li>
<li>特殊字符用单引号括起来后，也会失去原有意义，而只作为普通字符解释</li>
</ul>
<h4 id="反引号">反引号</h4>
<ul>
<li>内层嵌套的反引号要使用反斜线<strong>将其转义</strong></li>
<li>反引号括起来的内容被Shell解释为命令行</li>
</ul>
<h3 id="通配符和正则表达式regular-expression">通配符和正则表达式(Regular Expression)</h3>
<ul>
<li>通配符
<ul>
<li>***** ：可以匹配文件名中的任何字符串</li>
<li><strong>？</strong>：可以匹配文件名中的任何<strong>单个字符</strong></li>
<li><strong>[…]</strong> ：匹配方括号[ ]中指定范围内的字符，可以<strong>使用-来连接两个字母或数字，以表示范围</strong></li>
<li><strong>[!...]</strong> ：匹配不在指定范围内的任何字符</li>
</ul></li>
<li>正则
<ul>
<li>^：只匹配行首，用在字符串前面</li>
<li>$：只匹配行尾，用在字符串后面</li>
<li>X*：0个或多个字符X</li>
<li>.：只匹配任意单字符</li>
<li>[字符表]：字符表中的任意字符</li>
<li>[^字符表]：不在字符表中的任意字符</li>
<li>：屏蔽其后的特殊字符的特殊含义</li>
<li>\{n\}：前导的正则表达式重复n次</li>
<li>\{min, max\}：前导的正则表达式重复min~max次</li>
</ul></li>
</ul>
<h3 id="变量参数">变量参数</h3>
<ul>
<li><p>位置变量参数 $0, $1,···</p>
<ul>
<li><p>Shell在解释用户命令时,将把<strong>命令行的第一个字</strong>作为命令,而其它字作为参数通过位置变量传递给程序</p></li>
<li><p>$1-$9是第一到九个参数，<strong>第九个</strong>以后的参数都不会被访问</p></li>
<li><p>位置变量$0指命令对应的可执行名</p></li>
</ul></li>
<li><p>特定变量参数</p>
<ul>
<li>$#：传递到脚本的参数个数</li>
<li>$?：<strong>最后一个程序或命令的执行状态</strong>。用数字表示：0表示执行没有错误，其他任何值表明有错误</li>
<li>$*：所有参数</li>
<li>$$：<strong>脚本运行的当前Shell的PID</strong></li>
<li>$@：所有参数，每个参数用双引号引起</li>
</ul></li>
</ul>
<h3 id="标准文件和文件描述符">标准文件和文件描述符</h3>
<ul>
<li>在Shell中执行命令的时候，<strong>每个进程都和三个打开的文件相联系</strong>，并使用文件描述符来引用这些文件。 　 文件 　　　 文件描述符</li>
<li>输入文件 —　标准输入 – stdin 0</li>
<li>输出文件 —　标准输出 – stdout 1</li>
<li>错误输出文件 —标准错误输出 – stderr 2</li>
</ul>
<h3 id="重定向和管道">重定向和管道</h3>
<ul>
<li><p>由于大多数命令都以参数的形式在命令行上指定输入档的文件名，所以输入重定向并不经常使用。尽管如此，当要使用一个不接受档名作为输入参数的命令，而需要的输入内容又存在一个文档里时，就能用输入重定向解决问题。</p></li>
<li><p>重定向：&lt;、&gt;，追加：&lt;&lt;、&gt;&gt;</p></li>
<li><p>错误重定向：2 &gt; errfile/2 &gt; /dev/null</p></li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 标准输入与标准错误输出
$cat filea fileb
# 标准输出
-&gt;This is output from filea.
# 标准错误输出
-&gt;cat: cannot open fileb
</code></pre></div>
<ul>
<li><p>再举个例子</p>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Command &gt; outfile  2&gt; errfile  &lt;  infile
# 以infile为标准输入，将标准输出送到outfile,标准错误输出送到errfile. 
Command &gt;&gt; outfile  2&gt;&gt; errfile  &lt; infile
# 以infile为标准输入，将标准输出追加到outfile,标准错误输出追加到errfile. 
</code></pre></div></li>
<li><p>将stdout和stderr同时重定向到outfile：$Command &gt; outfile <strong>2&gt;&amp;1</strong></p></li>
</ul>
<blockquote>
<p>https://www.jianshu.com/p/d5ea4a8acfb9</p>
</blockquote>
<ul>
<li>管道是把一个命令在<strong>屏幕上的输出</strong>传递给另一个命令作为输入。用竖杠|表示。</li>
</ul>
<h3 id="算术扩展">算术扩展</h3>
<ul>
<li><p>$((expression))，有$符号</p></li>
<li><p>运算符源于C</p></li>
<li><p>算术扩展中包含的只有变量、运算符和常数，所以变量不需要$引用</p></li>
<li><p>算术扩展内空格可以随意使用</p></li>
<li><p>表达式内的变量若未定义，则当作其值为0</p>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 判断真假
$i&#x3D;2 ; echo $((  i&#x3D;&#x3D;2 ))    
# 变量赋值
$ result&#x3D; $(( i&gt;&#x3D;0 &amp;&amp;i&lt;&#x3D;3))</code></pre></div></li>
</ul>
<h3 id="各种操作符号">各种操作符号</h3>
<ul>
<li><p>命令组</p>
<p>多个命令在一行输入时，用 “;”作为命令间分隔符。</p></li>
</ul>
<h3 id="常用指令">常用指令</h3>
<h4 id="exit">exit</h4>
<ul>
<li><p>正常退出返回0</p></li>
<li><p>如果直接在终端上执行exit命令，会导致从系统注销，因为它会终止登陆Shell的执行。</p></li>
</ul>
<h4 id="和">$$和||</h4>
<ul>
<li>注意这个运算符也是短路的，只有前者为真后者才会进行or前者失败才执行后者</li>
<li>注意这个是对于两个命令，而不是逻辑判断</li>
</ul>
<h4 id="test">test</h4>
<ul>
<li><p>用于测试一种或几种条件</p></li>
<li><p>格式</p>
<p>Test expression</p>
<p>[ expression ]：要注意在<strong>条件两边加上空格</strong>。涉及到变量值（$variable）的比较时最好把<strong>变量取值用双引号括起来</strong>，以免Shell误解变量值。</p></li>
</ul>
<h5 id="字符串操作符">字符串操作符</h5>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 相等
$test string1 &#x3D; string2
# 不等
$test string1 !&#x3D; string2
# 非空
$test string </code></pre></div>
<ul>
<li>等号和不等号操作符两边必须有空格</li>
<li>在长度和内容上判断两个字符串相等</li>
</ul>
<h5 id="整数操作符">整数操作符</h5>
<div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 相等
$test int1 -eq int2
# 不等
$test int1 -ne int2
# 小于
$test int1 -lt int2
# 大于
$test int1 -gt int2
# 小于等于
$test int1 -le int2
# 大于等于
$test int1 -ge int2</code></pre></div>
<h5 id="文件操作符">文件操作符</h5>
<ul>
<li>-e(exist)：文件存在</li>
<li>-d(directory)</li>
<li>-f</li>
<li>-s：文件大小不为0</li>
<li>-r：及以下两个都需要有<strong>文件所有者</strong>的权限</li>
<li>-w</li>
<li>-x</li>
</ul>
<h5 id="逻辑操作符">逻辑操作符</h5>
<ul>
<li>-a(and)：与</li>
<li>-o(or)：或</li>
<li>!：非</li>
</ul>
<h4 id="expr">expr</h4>
<ul>
<li><p>表达式的各部分(操作数和运算符之间)必须以空格分隔。</p></li>
<li><p>表达式中某些对shell有特殊意义的字符必须转义。</p></li>
<li><p>*需要进行转义\*</p>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 多个算术表达式可以组合在一起
$expr 5 + 7 &#x2F; 3
# 使用反引号改变计算次序
$expr &#96;$expr 5 + 7&#96; &#x2F; 3
#expr命令一般用于整数值，此外，还可用于字符串测试
$s1&#x3D;“hello”
$expr  $s1 &#x3D; “hello”</code></pre></div></li>
</ul>
<h4 id="grepglobal-regular-expression-print">grep(global regular expression print)</h4>
<ul>
<li>允许对文本文件的内容进行模式查找。如果找到匹配模式，<strong>grep显示包含该模式的所有行</strong></li>
<li>在g r e p命令中输入字符串参数时，最好将其用双引号括起来。在调用模<strong>式匹配时，应使用单引号</strong></li>
<li>选项
<ul>
<li>-c(count)：只输出计数</li>
<li>-n：显示匹配行及行号</li>
<li>-v：显示不包含匹配文本的所有行</li>
</ul></li>
</ul>
<h4 id="find">find</h4>
<ul>
<li><p>格式：find path expression [-exec -ok] [command]</p></li>
<li><p>所查找的目录路径，对<strong>目录的搜索是递归</strong>的。.表示当前目录，/表示根目录</p></li>
<li><p>-exec command：find命令对匹配的文件执行该参数所给出的Shell命令command</p>
<p>-exec后的命令形式：command {} ; 注意{ }和；之间的空格。</p></li>
<li><p>-ok command：和-exec的作用相同，只是在执行每一个命令之前，<strong>都会给出提示</strong>，让用户来确定是否执行。如果用户不回应 'y' 或 'Y'，command 将不予以执行，并回应 false。</p></li>
<li><p>expression的名称标准：</p>
<ul>
<li>-name file：寻找名为file的文件，要找的文件名包括<strong>在引号中</strong>,可以使用通配符。</li>
<li>-user name：按照<strong>文件属主</strong>来查找文件</li>
<li>-group name</li>
<li>-type type：查找某一类型的文件(b、c、d、f、l)</li>
<li>-size n[c]：查找文件长度为n块(block)的文件，带有c时表示文件长度以字节计。</li>
<li>时间标准 -mtime n：-n表示在n天以内，n/+n表示在n天以上</li>
</ul></li>
</ul>
<h3 id="运行shell脚本">运行Shell脚本</h3>
<ul>
<li>sh：这种运行方式是启动了一个子Shell,set_dir 文件中的Shell命令都是在子Shell中执行, <strong>Shell命令执行完后，退回到命令提示符下</strong>时，子Shell结束</li>
<li>.(source)：</li>
<li>赋予执行权限：这种执行方式，Shell首先查找 <strong>PATH 变量中的各路径中是否有相应程序</strong>，若没有则会出错。因而需要在<strong>PATH变量中添加脚本所在的路径</strong>。这种方式也是在子Shell中执行脚本
<ul>
<li>用户必须对该文件具有读权限和执行权限</li>
<li>开放执行权限：$chmod +x set_dir</li>
<li>执行：$set_dir</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux是怎样工作的读书笔记</title>
    <url>/blog/posts/43113/</url>
    <content><![CDATA[<h2 id="用户模式实现的功能">用户模式实现的功能</h2>
<h3 id="cpu的工作模式">CPU的工作模式</h3>
<h3 id="系统调用">系统调用</h3>
<h3 id="系统调用的包装函数">系统调用的包装函数</h3>
<h2 id="进程管理">进程管理</h2>
<h3 id="进程的创建">进程的创建</h3>
<h3 id="fork函数"><code>fork()</code>函数</h3>
<h3 id="execve函数"><code>execve()</code>函数</h3>
<h3 id="结束进程">结束进程</h3>
<h2 id="进程调度器">进程调度器</h2>
<h3 id="多进程的调度策略">多进程的调度策略</h3>
<h3 id="上下文切换">上下文切换</h3>
<h2 id="参考资料">参考资料</h2>
]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven和Gradle的介绍和简单应用</title>
    <url>/blog/posts/7693/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python  科学计算</title>
    <url>/blog/posts/23478/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy7rk65f1qj310i09cack.jpg" title="fig:" alt="image-20220109215625112" /></li>
<li>https://www.zhihu.com/people/youcans-24/columns</li>
</ul>
<h1 id="数据处理">数据处理</h1>
<h2 id="数据的存储">数据的存储</h2>
<ul>
<li>详见Python爬虫一文</li>
</ul>
<h2 id="文件管理">文件管理</h2>
<ul>
<li>使用Python提供的os模块</li>
</ul>
<h3 id="文件和目录列表">文件和目录列表</h3>
<ul>
<li>使用<code>.listdir()</code>方法获得目录列表</li>
</ul>
<h3 id="目录操作">目录操作</h3>
<h3 id="文件操作">文件操作</h3>
<ul>
<li>rename()：文件重命名</li>
</ul>
<h2 id="数据清洗">数据清洗</h2>
<h3 id="存储在数据库中的数据">存储在数据库中的数据</h3>
<ul>
<li>优先考虑使用SQL语句进行清洗</li>
</ul>
<h3 id="存储在csvxlsx文件中的数据">存储在csv、xlsx文件中的数据</h3>
<ul>
<li>可以先使用可视化工具进行标准化处理</li>
</ul>
<h3 id="存储在xmljson和csv等文件中的数据">存储在XML、JSON和csv等文件中的数据</h3>
<ul>
<li>使用Python强大的字符串处理能力，使用<code>.split()</code>和<code>.strip()</code>等方法进行字符串的整理</li>
<li>使用正则表达式处理数据</li>
</ul>
<h1 id="numpy">Numpy</h1>
<h2 id="简介">简介</h2>
<ul>
<li>Numpy主要加强了Python的数组运算能力，引入ndarray对象和ufunc函数，大大提高了Python的矩阵运算能力</li>
<li>基本模仿Matlab的风格，并实现了相似的矩阵保存和运算功能</li>
</ul>
<h2 id="数组对象">数组对象</h2>
<h3 id="ndarray">ndarray</h3>
<ul>
<li>ndarray被设计用来表示矩阵，通常被叫做数组</li>
<li>数组的维度成为轴，维度内元素的数量成为轴的长度</li>
</ul>
<h4 id="数组的属性">数组的属性</h4>
<ul>
<li>ndarray.ndim：返回维度数</li>
<li>ndarray.shape：返回一个元组，表示数组的形状，其长度和维度相等，每个元素是对应维度的大小</li>
<li>ndarray.size：数组元素的总个数</li>
<li>ndarray.dtype：</li>
<li>ndarray.itemsize：</li>
<li>ndarray.data</li>
</ul>
<h4 id="numpy扩展数据类型">numpy扩展数据类型</h4>
<h4 id="数组的创建">数组的创建</h4>
<ul>
<li><p>直接创建</p></li>
<li><p>特殊数组的创建</p>
<ul>
<li><p>empty()：建立一个空矩阵，随机生成元素</p></li>
<li><p>zeros()/ones()：生成0/1矩阵</p></li>
<li><p>.arange：与Matlab类似，可以接受四个参数，分别是start、end、step和dtype</p></li>
<li><p>.linspace：创建一个等差数列一维数组</p></li>
<li><p>.logspace：创建一个等比数列一维数组</p></li>
<li><p>numpy.random.rand/randn/randint：生成符合一定规律的随机矩阵</p></li>
<li><p>formfunction()：根据指定函数生成矩阵</p></li>
</ul></li>
</ul>
<h2 id="数组操作">数组操作</h2>
<h3 id="运算">运算</h3>
<ul>
<li>numpy使用@来表示矩阵乘法</li>
</ul>
<h3 id="获取数组内容">获取数组内容</h3>
<ul>
<li>numpy可以使用<code>···</code>来表示剩余轴</li>
<li>对于多维数组的迭代仅仅是针对第一个轴进行的，要想遍历全部，需要调用数组的<code>.flat</code>属性</li>
</ul>
<h3 id="修改数组内容">修改数组内容</h3>
<ul>
<li>.delete()：删除一行or一列数据</li>
<li>.append()：插入数据</li>
</ul>
<h3 id="修改数组形状">修改数组形状</h3>
<ul>
<li><p>.reshape()、.ravel()和.resize()：重整数组形状，生成行向量，以及在原数组基础上进行重构（不建立新对象）</p>
<blockquote>
<p>特别的，<code>reshape()</code>方法接受类似（1，-1）、（2，-1）和（-1,1）这样的参数，将会得到一行、两行或者一列数据</p>
</blockquote></li>
<li><p>.T：转置变换</p></li>
<li><p>.flatten()：返回一份数组拷贝，相当于矩阵的行向量，接受一个order参数，提供以下选项</p>
<table>
<thead>
<tr class="header">
<th>order</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C</td>
<td>按行顺序</td>
</tr>
<tr class="even">
<td>F</td>
<td>按列顺序</td>
</tr>
<tr class="odd">
<td>A</td>
<td>原顺序</td>
</tr>
<tr class="even">
<td>K</td>
<td>元素在内存中出现的顺序</td>
</tr>
</tbody>
</table></li>
<li><p>.vstack()、.hstack()和.column_stack()：分别在垂直、水平和更高维度上进行数组的堆叠</p>
<blockquote>
<p><code>.c_</code>和<code>.r_</code>具有相同的作用</p>
</blockquote></li>
<li><p>.vsplit()、.hsplit()和.array_split()分别进行垂直、水平和自定义的拆分</p></li>
</ul>
<h2 id="高级索引">高级索引</h2>
<h3 id="数组索引">数组索引</h3>
<ul>
<li>使用<code>np.array()</code>方法建立一个numpy数组，可以实现从第一个维度开始的索引</li>
<li>使用一个高维数组对目标数组进行一维的索引，可以提升若干个维度</li>
<li>一维索引数组，可以获取目标数组的一维数据；二位索引数组，可以将若干个一维数据再进行组合，以此类推</li>
</ul>
<h3 id="布尔索引">布尔索引</h3>
<ul>
<li>使用一个与原始数组形状相同的布尔数组进行筛选</li>
</ul>
<h4 id="ix索引">ix()索引</h4>
<h2 id="linalg模块">linalg模块</h2>
<h3 id="linalg.norm">.linalg.norm</h3>
<ul>
<li>用于获得欧几里得范数</li>
<li>说白了就是两点间距离</li>
</ul>
<h1 id="pandas">Pandas</h1>
<h2 id="简介-1">简介</h2>
<ul>
<li>最早作为金融数据分析工具开发，有很强大的数据分析能力</li>
<li>支持类似SQL语句的模型</li>
</ul>
<h1 id="scipy">Scipy</h1>
<h1 id="sympy">Sympy</h1>
<h1 id="matplotlib入门">Matplotlib入门</h1>
<h1 id="seaborn入门">Seaborn入门</h1>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Python入门</title>
    <url>/blog/posts/21062/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<h3 id="python解释器原理">Python解释器原理</h3>
<h4 id="传入参数">传入参数</h4>
<ul>
<li>解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 sys 模块的 argv 变量里。</li>
<li>执行 import sys，可以导入这个模块，并访问该列表。
<ul>
<li>该列表最少有一个元素；</li>
<li>未给定输入参数时，sys.argv[0] 是空字符串。</li>
<li>给定脚本名是 '-' （标准输入）时，sys.argv[0] 是 '-'。</li>
<li>使用 -c command 时，sys.argv[0] 是 '-c'。</li>
<li>如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。</li>
</ul></li>
<li>解释器不处理 -c command 或 -m module 之后的选项，而是直接留在 sys.argv 中由命令或模块来处理。</li>
</ul>
<h3 id="运行环境">运行环境</h3>
<h4 id="字符编码">字符编码</h4>
<ul>
<li><p>默认使用UTF-8</p></li>
<li><p>如果不使用默认编码，则要声明文件的编码，文件的 第一 行要写成特殊注释</p></li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># -*- coding: encoding -*-</code></pre></div>
<blockquote>
<p>Unicode和ASCII都懂</br> 为了把Unicode转化为可变长度的一种编码，产生了UTF-8编码。</br> UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节</p>
</blockquote>
<h2 id="数据类型及运算">数据类型及运算</h2>
<blockquote>
<p>所有整数默认视作int，浮点数视作float</p>
</blockquote>
<p>首先要明确，Python并不是一个弱数据类型的语言。他只是有一个强大的类型推导机制，比如，可以在函数声明处使用<code>-&gt; float</code>这样的语法规定返回值类型。</p>
<p>Python提供了五个标准数据类型，分别为：</p>
<ol type="1">
<li>Numbers</li>
<li>String</li>
<li>List</li>
<li>Tuple</li>
<li>Dictionary</li>
</ol>
<h3 id="整数">整数</h3>
<p>有一个很有意思的特性，Python中对于较长的数字可以使用下划线分割，如10000000&gt; 100_0000_0</p>
<h3 id="复数">复数</h3>
<ul>
<li>使用a+bj或complex(a,b)来表示</li>
</ul>
<h3 id="字符串">字符串</h3>
<h4 id="基本内容">基本内容</h4>
<ul>
<li><p><strong>单引号和双引号等价</strong>，但实际运用中往往使用单引号比较多，反斜杠用于转义</p></li>
<li><p>字符串有“加（+）”连接和“乘(*)”反复两种操作</p></li>
<li><p>Python中的字符串默认使用str类型，其一个字符所对应的字节数是不确定的。在保存或传输时要转换成bytes类型。bytes类型使用b前缀来表明</p></li>
<li><p>交互式解释器会为输出的字符串加注引号，特殊字符使用反斜杠转义。</p>
<blockquote>
<p>虽然，有时输出的字符串看起来与输入的字符串不一样（外加的引号可能会改变），但两个字符串是相同的。如果字符串中有单引号而没有双引号，该字符串外将加注双引号，反之，则加注单引号。</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; &#39;doesn\&#39;t&#39;  # use \&#39; to escape the single quote...
&quot;doesn&#39;t&quot;
&gt;&gt;&gt; &quot;doesn&#39;t&quot;  # ...or use double quotes instead
&quot;doesn&#39;t&quot;</code></pre></div>
</blockquote></li>
<li><p>print() 函数输出的内容更简洁易读，它会省略两边的引号，并输出转义后的特殊字符</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; print(&#39;&quot;Isn\&#39;t,&quot; they said.&#39;)
&quot;Isn&#39;t,&quot; they said.</code></pre></div></li>
<li><p>如果不希望前置  的字符转义成特殊字符，可以使用 原始字符串，在引号前添加<code>r</code></p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; print(&#39;C:\some\name&#39;)  # here \n means newline!
C:\some
ame
&gt;&gt;&gt; print(r&#39;C:\some\name&#39;)  # note the r before the quote
C:\some\name</code></pre></div></li>
<li><p>字符串字面值可以实现跨行连续输入。实现方式是用三引号："""...""" 或 '''...'''，字符串行尾会自动加上回车换行，如果不需要回车换行，在行尾添加  即可</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&quot;&quot;&quot;\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
&quot;&quot;&quot;)</code></pre></div></li>
<li><p>python能够自动拼接两行字符串，不必使用链接符号；但合并变量和字面值必须使用</p></li>
<li><p>字符串索引，支持正负</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">word &#x3D; &#39;Python&#39;
word[0]
&#x2F;&#x2F; 不存在-0索引，没有意义
word[-2]</code></pre></div>
<blockquote>
<p>python没有char类型，只有长度为1的String</p>
</blockquote></li>
<li><p>字符串切片，支持接受第三个参数：截取的布长</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">word[0:2]
word[:2]
word[4:]
word[-2:]</code></pre></div>
<blockquote>
<p>索引越界会报错，但切片会自动处理越界索引</p>
</blockquote></li>
</ul>
<h4 id="常用方法">常用方法</h4>
<ul>
<li><p>ord()和chr：编码转换</p></li>
<li><p>encode()和decode()：将str编码或反编码为制定的bytes</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)
b&#39;ABC&#39;
&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;ascii&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)</code></pre></div>
<blockquote>
<p>decode()方法可以指定errors='ignore'来忽略错误的字节</p>
</blockquote></li>
<li><p>len()</p></li>
<li><p>in：如果字符串中包含指定子串则返回True</p></li>
<li><p>split()：给定一个字符串参数，将<strong>实例分割为一个字符串数组</strong></p></li>
<li><p>replace()：给定两个参数，用<strong>第二个参数替换第一个参数</strong>。还可以通过索引指定字符串的<strong>某段</strong>进行替换。</p></li>
<li><p>strip()：返回去除两侧指定字符（默认为空格）的字符串</p>
<blockquote>
<p>相当于通过正负索引的遍历进行替换</p>
</blockquote></li>
</ul>
<h4 id="格式化字符串">格式化字符串</h4>
<p>占位符使用<code>&#123;&#125;</code>表示，通常配合<code>format()</code>方法实现字符串的组装</p>
<p><code>format()</code>方法是字符串对象最常用的方法之一，可以用来替换占位符的内容，示例</p>
<p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kugou.com&#x2F;yy&#x2F;rank&#x2F;home&#x2F;&#123;&#125;-8888.html?from&#x3D;rank&#39;
        .format(str(i))
            for i in range(1, 10)]</code></pre></div></p>
<blockquote>
<p>使用单行函数的形式写出非常pythonic的代码</p>
</blockquote>
<h3 id="list">List</h3>
<p>使用中括号括起的即是List。</p>
<p>Python的List应该是使用链表实现的（还没有考证）。</p>
<p>常用的方法：</p>
<ul>
<li>len()：</li>
<li>append(element)</li>
<li>insert(index,element)</li>
<li>pop([index])</li>
<li>cmp</li>
<li>Max/min</li>
</ul>
<h4 id="生成器">生成器</h4>
<p>生成器是一种编程思想。他可以实现类似动态读取数据的效果，降低内存占用，算是用时间换空间的一种方式。</p>
<ul>
<li>生成器可以实现数据的懒加载，缓解内存压力</li>
<li>一种获得方式是将通过循环得到的数组，中括号更改为小括号即可</li>
<li>另一种方式是通过yield关键字获得</li>
</ul>
<h4 id="yield关键字"><code>yield</code>关键字</h4>
<ul>
<li>使用yield关键字返回一个数据，得到的就是一个<strong>生成器</strong></li>
<li>函数在执行到有yield关键字的内容时会结束执行</li>
</ul>
<h4 id="元素的生成">元素的生成</h4>
<ul>
<li>调用<code>.next()</code>或者<code>._next_（）</code>方法</li>
<li>最后一个元素使用<code>.next()</code>方法会抛出StopIteration异常</li>
<li>为了避免异常的发生可以使用for循环遍历</li>
</ul>
<h3 id="tuple">Tuple</h3>
<p>Tuple可以理解为<strong>静态数组</strong>，他最大的特征就是静态不可变。</p>
<ul>
<li>元组的元素不能被修改，<strong>使用小括号表示</strong></li>
<li>应当使用del删除整个元组</li>
<li>如果可能，能用tuple代替list就尽量用tuple，降低运算压力和内存开销</li>
</ul>
<h3 id="字典dict其他语言中一般指map">字典（dict，其他语言中一般指map）</h3>
<p>与各种各样的map类似，无非就是这些基本的方法</p>
<ul>
<li>clear和pop</li>
<li>get：获取指定key，并在不存在时返回None或指定结果，<strong>能够避免错误</strong></li>
</ul>
<h2 id="流程控制语句">流程控制语句</h2>
<h3 id="while">while</h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;python
 
count &#x3D; 0
while (count &lt; 9):
   print &#39;The count is:&#39;, count
   count &#x3D; count + 1
 
print &quot;Good bye!&quot;</code></pre></div></li>
<li><p>使用while...else结构，在while条件为false时执行else子块</p></li>
</ul>
<h3 id="多重循环">多重循环</h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">for var1,var2 in zip(list1,list2):</code></pre></div></li>
</ul>
<h3 id="if">if</h3>
<ul>
<li><p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; x &#x3D; int(input(&quot;Please enter an integer: &quot;))
Please enter an integer: 42
&gt;&gt;&gt; if x &lt; 0:
...     x &#x3D; 0
...     print(&#39;Negative changed to zero&#39;)
... elif x &#x3D;&#x3D; 0:
...     print(&#39;Zero&#39;)
... elif x &#x3D;&#x3D; 1:
...     print(&#39;Single&#39;)
... else:
...     print(&#39;More&#39;)
...
More</code></pre></div></li>
</ul>
<h3 id="for">for</h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; # Measure some strings:
... words &#x3D; [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]
&gt;&gt;&gt; for w in words:
...     print(w, len(w))
...
cat 3
window 6
defenestrate 12</code></pre></div></li>
<li><p>Python的for迭代列表或字符串等任意序列</p></li>
<li><p>使用for循环修改集合的内容，应当遍历其副本或者创建一个新的集合</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status &#x3D;&#x3D; &#39;inactive&#39;:
        del users[user]

# Strategy:  Create a new collection
active_users &#x3D; &#123;&#125;
for user, status in users.items():
    if status &#x3D;&#x3D; &#39;active&#39;:
        active_users[user] &#x3D; status</code></pre></div></li>
<li><p>range函数能够遍历数字序列</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; list(range(5, 10))
[5, 6, 7, 8, 9]

&gt;&gt;&gt; list(range(0, 10, 3))
[0, 3, 6, 9]

&gt;&gt;&gt; list(range(-10, -100, -30))
[-10, -40, -70]</code></pre></div>
<blockquote>
<p>range() 返回对象的操作和列表很像，但其实这两种对象不是一回事。迭代时，该对象基于所需序列返回连续项，并没有生成真正的列表，从而节省了空间。</p>
<p>这种对象称为<strong>可迭代对象 iterable</strong>，函数或程序结构可通过该对象获取连续项，直到所有元素全部迭代完毕</p>
</blockquote></li>
</ul>
<h3 id="else子句">else子句</h3>
<ul>
<li><p>循环语句支持 else 子句；for 循环中，可迭代对象中的元素全部循环完毕时，或 while 循环的条件为假时，执行该子句；break 语句终止循环时，不执行该子句。</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):
...         if n % x &#x3D;&#x3D; 0:
...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n&#x2F;&#x2F;x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, &#39;is a prime number&#39;)
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3</code></pre></div></li>
</ul>
<h3 id="pass语句">pass语句</h3>
<ul>
<li><strong>pass</strong> 不做任何事情，一般用做占位语句</li>
</ul>
<h2 id="文件io">文件IO</h2>
<h3 id="输入与读取">输入与读取</h3>
<h4 id="input和raw_input"><code>input()</code>和<code>raw_input()</code></h4>
<p>这两个函数用于从Terminal获取用户的输入。</p>
<p>input返回string，需要手动转换，如int()方法</p>
<h4 id="open"><code>open()</code></h4>
<p><code>open()</code>函数可以打开一个文件并建立file对象。</p>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">file object &#x3D; open(file_name [, access_mode][, buffering])</code></pre></div></li>
</ul>
<h3 id="print"><code>print()</code></h3>
<h3 id="write和read"><code>write</code>和<code>read</code></h3>
<h3 id="tell和seek">tell和seek</h3>
<ul>
<li>Tell返回文件内的位置，seek可以改变到指定位置</li>
</ul>
<h2 id="函数">函数</h2>
<h3 id="定义函数">定义函数</h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def functionname( parameters ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]</code></pre></div></li>
<li><p>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</p></li>
<li><p>return[]表示结束，留空则返回None</p></li>
</ul>
<h3 id="调用函数">调用函数</h3>
<ul>
<li>类型转换函数</li>
<li>isinstance：数据类型检查</li>
</ul>
<h3 id="函数参数">函数参数</h3>
<h4 id="位置参数">位置参数</h4>
<ul>
<li>调用函数时，传入的两个值按照位置顺序依次赋给指定参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<ul>
<li><p>指定某一个未知参数的默认值</p></li>
<li><p>必选参数在前，默认参数在后</p></li>
<li><p>变化比较大、覆盖范围广的参数放在前面，相对普遍的参数放在后面并使用默认参数</p></li>
<li><p>默认参数必须指向不可变对象</p>
<p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def add_end(L&#x3D;None):
    if L is None:
        L &#x3D; []
    L.append(&#39;END&#39;)
    return L</code></pre></div></li>
</ul>
<h4 id="可变参数">可变参数</h4>
<ul>
<li>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code></li>
<li>同样的，传入参数时可以在list或tuple前加*前缀作为可变参数传入</li>
<li>在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。</li>
</ul>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def person(name, age, **kw):
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</code></pre></div></li>
</ul>
<h3 id="装饰器">装饰器</h3>
<p>装饰器是一个类似Java中注解的语法特性。它允许对函数进行统一的前置和后置操作。</p>
<p>举个例子就可以</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def authorization(fn):
    def check_and_do(name):
        if name !&#x3D; &quot;mofanpy&quot;:   # 鉴权
            print(name + &quot; has no right!&quot;)
            return 
        res &#x3D; fn(name)
        return res
    return check_and_do

@authorization
def outer1(name):
    print(name+&quot; outer1&quot;)

@authorization
def outer2(name):
    print(name+&quot; outer2&quot;)

@authorization
def outer3(name):
    print(name+&quot; outer3&quot;)

outer1(&quot;mofanpy&quot;)
outer2(&quot;morgan&quot;)
outer3(&quot;mofanpy&quot;)</code></pre></div>
<h3 id="高阶函数">高阶函数</h3>
<p>高阶函数的引入，主要为了实现函数式编程的编程范式。</p>
<h4 id="map">map()</h4>
<ul>
<li>可以实现列表数据的逐个运算，并通过tuple()、list()等方法获得对应的运算结果</li>
</ul>
<h4 id="reduce">reduce()</h4>
<ul>
<li>用于实现列表数据和上次运算结果的复合关系</li>
</ul>
<h4 id="filter">filter()</h4>
<ul>
<li>返回运算结果为True的元素，可以对数据进行过滤</li>
</ul>
<h4 id="sorted">sorted()</h4>
<h2 id="模块化开发">模块化开发</h2>
<h2 id="多任务处理">多任务处理</h2>
<p>python中的多线程是伪多线程，因为存在GIL。 1、Python语言和GIL没有关系，只是因为历史原因在Cpython虚拟机(解释器)中难以移除GIL 2、GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。 3、线程释放GIL锁的情况：在IO操作等可能引起阻塞的system call之前，可以暂时释放GIL， 但在执行完毕后，必须重新获取GIL，python3使用计时器(执行时间到达阈值后，当前线程释放GIL) 或python2,tickets计数达到100 4、Python使用多进程是可以利用多核CPU资源的 5、多线程爬虫比单线程性能有提升，是因为IO阻塞会自动释放GIL锁</p>
<h3 id="多线程">多线程</h3>
<ul>
<li>使用threading模块</li>
</ul>
<h4 id="创建线程">创建线程</h4>
<ul>
<li>使用<code>threading.Thread(target,name)</code>来创建一个新的线程</li>
<li>其中，target指向的函数被称为该现成的回调函数</li>
<li><code>thread_name.start</code>用于启动这个新线程</li>
<li><code>thread_name.join</code>是一个阻塞式方法，表示在当前位置等待新线程结束后再继续执行主线程</li>
</ul>
<h4 id="线程同步">线程同步</h4>
<blockquote>
<p>由于每个线程在执行前都需要获取全局解释锁（Global Interpreter Lock,GIL），因此线程是交替执行的。每个线程执行一定量代码后就会释放GIL交给其他线程。</p>
<p>当多个线程共享一个进程的内存空间、同时修改一个全局变量，我们认为这种情况线程安全。</p>
</blockquote>
<ul>
<li>Python提供了锁机制保证线程安全</li>
<li>在需要保护的代码前添加一行<code>lock.acquire()</code>，最后添加一行<code>lock.release()</code>即可</li>
</ul>
<h3 id="多进程">多进程</h3>
<ul>
<li>通常使用multiprocessing模块的Process进行进程管理，Linux下也可以使用fork之间创建子线程</li>
</ul>
<h4 id="直接建立子进程">直接建立子进程</h4>
<ul>
<li>使用<code>multiprocessing.Process(target,args)</code>创建新进程</li>
<li>与线程的管理类似，提供了<code>.start()</code>和<code>.join()</code>方法</li>
</ul>
<h4 id="通过pool池建立子进程">通过Pool池建立子进程</h4>
<ul>
<li>使用<code>Pool(num)</code>创建一个能同时容纳num个进程的pool对象</li>
<li>调用pool对象的<code>.apply_async(target,args)</code>方法创建进程</li>
<li>在调用<code>.join()</code>方法之前需要使用<code>.close</code>方法关闭pool池防止加入新的进程</li>
</ul>
<h4 id="进程间通信">进程间通信</h4>
<blockquote>
<p>与线程不同，进程之间是完全独立运行的，因此Python使用multiprocessing模块中的Queue来进行管理</p>
</blockquote>
<ul>
<li>建立一个<code>Queue</code>对象</li>
<li>使用<code>q.put()</code>和<code>q.get()</code>方法获取数据</li>
</ul>
<h4 id="共享内存">共享内存</h4>
<h4 id="上锁">上锁</h4>
<h3 id="协程">协程</h3>
<blockquote>
<p>协程与进程、线程都不同，他是一个由async关键字创建的异步函数</p>
</blockquote>
<ul>
<li>异步函数返回的不是函数执行的结果，而是一个协程对象，需要通过<code>.send()</code>方法触发函数执行</li>
<li>异步函数退出时会抛出异常，其返回值就包含在异常对象中，使用<code>e.value</code>来获取</li>
<li>使用await关键字可以阻塞自身，执行另一个异步函数</li>
</ul>
<h2 id="错误和异常">错误和异常</h2>
<h3 id="异常处理">异常处理</h3>
<ul>
<li><p>使用try...except语句</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;python
# -*- coding: UTF-8 -*-

try:
    fh &#x3D; open(&quot;testfile&quot;, &quot;w&quot;)
    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)
except IOError:
    print &quot;Error: 没有找到文件或读取文件失败&quot;
else:
    print &quot;内容写入文件成功&quot;
    fh.close()</code></pre></div></li>
<li><p>支持finally语句</p></li>
<li><p>异常可以附带参数，习惯命名为Argument，通常包含详细的错误信息</p></li>
<li><p>raise语句可以手动触发异常</p>
<p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">def functionName( level ):
    if level &lt; 1:
        raise Exception(&quot;Invalid level!&quot;, level)
        # 触发异常后，后面的代码就不会再执行</code></pre></div></li>
</ul>
<h3 id="logging模块">logging模块</h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import logging
format &#x3D; logging.Formatter(&#39;%&#123;asctime&#125;s - %&#123;name&#125;s - %&#123;levelname&#125;s - &#39;,
                           &#39;%&#123;pathname&#125;s - %&#123;lineno&#125;s: %&#123;message&#125;s&#39;,datefmt&#x3D;&#39;%Y-%m-%d %H:%M:%S&#39;)

sh &#x3D; logging.StreamHandler()
sh.setFormatter(format)

logger &#x3D; logging.getLogger(&#39;MyLog&#39;)
logger.setlevel(10)
logger.addHandler(sh)

logger.info(&#39;content&#39;)
...</code></pre></div></li>
</ul>
<h2 id="oop的实现">OOP的实现</h2>
<p>Python是一门完全支持OOP范式的语言。</p>
<h3 id="类的定义">类的定义</h3>
<ul>
<li><p>格式示例如下</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class class_name:
compose &#x3D; [&#39;var&#39;,&#39;var&#39;] # 类变量
def _init_(self): # 魔法方法，类似构造方法
def function(self, var):</code></pre></div></li>
<li><p>注意类内的每个方法都需要调用参数<code>self</code></p></li>
</ul>
<h4 id="实例属性">实例属性</h4>
<ul>
<li>类变量中的属性可以直接引用，对于每个实例，可以在<code>.other</code>属性中创建实例属性</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li><p>继承示例如下</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A:
compose &#x3D; []

class B(A):</code></pre></div></li>
</ul>
<h2 id="pythonic-coding">Pythonic Coding</h2>
<ul>
<li><p>序列生成字典</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">  lst &#x3D; [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]
  &#x2F;&#x2F; 使用循环🏪存储
  for k, v in lst:
    dic[k] &#x3D; v
  &#x2F;&#x2F; 字典推导式
  &#123;k: v for k, v in lst&#125;

- 对未指定的key将value设置为0，可以用于一些可选参数的处理

  &#96;&#96;&#96;python
  if key not in dic:
    dic[key] &#x3D; 0
  &#x2F;&#x2F; 
  dic[key] &#x3D; dic.get(key,0)</code></pre></div></li>
<li><p>交换key和value</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Python&#39;: 1, &#39;Java&#39;: 2&#125;
new_dic &#x3D; &#123;&#125;
for k, v in dic.items():
    new_dic[v] &#x3D; k
    
&#x2F;&#x2F; 另一种写法，还是用推导式
new_dic &#x3D; &#123;v: k for k, v in dic.items()&#125;</code></pre></div></li>
<li><p>使用字典保存一个序列数据，当key已经存在时添加新的值到对应序列末尾；否则直接进行初始化</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">lst &#x3D; [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]
dic &#x3D; &#123;&#39;a&#39;: [0]&#125;

for key, value in lst:
    if key in dic:
        dic[key].append(value)
    else:
        dic[key] &#x3D; [value]
        
&#x2F;&#x2F; setdefault(key, default)会先判断key是否存在
&#x2F;&#x2F; 存在则返回dct[key]
&#x2F;&#x2F; 不存在则把dct[key]设为 [] 并返回。
for (key, value) in lst:
    group &#x3D; dic.setdefault(key, [])
    group.append(value)
    
&#x2F;&#x2F; 运行结果
# dic：&#123;&#39;a&#39;: [0, 1], &#39;b&#39;: [2], &#39;c&#39;: [3]&#125;
        </code></pre></div></li>
<li><p>交换两个字典相同key对应的值</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;&#39;Python&#39;: 1, &#39;Java&#39;: 2, &#39;C&#39;: 3&#125;
dic2 &#x3D; &#123;&#39;Python&#39;: 3, &#39;Java&#39;: 2, &#39;C++&#39;: 1&#125;

new_dic &#x3D; &#123;&#125;
for k, v in dic1.items():
    if k in dic2.keys():
        new_dic[k] &#x3D; v
        
&#x2F;&#x2F; 这里的dic1.keys() &amp; dic2.keys()用到的就是 
&#x2F;&#x2F; keys()进行集合运算
&#x2F;&#x2F; items()同样可以进行集合运算。
print(&#123;k: dic1[k] for k in dic1.keys() &amp; dic2.keys()&#125;)

        
&#x2F;&#x2F; 运行结果
# &#123;&#39;Python&#39;: 1, &#39;Java&#39;: 2&#125;</code></pre></div></li>
<li><p>使用<code>sorted()</code>函数快速排序</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0&#125;
lst1 &#x3D; sorted(dic.items(), key&#x3D;lambda x: x[0], reverse&#x3D;False)
# [(&#39;a&#39;, 2), (&#39;b&#39;, 1), (&#39;c&#39;, 3), (&#39;d&#39;, 0)]
lst2 &#x3D; sorted(dic.items(), key&#x3D;lambda x: x[1], reverse&#x3D;False)
# [(&#39;d&#39;, 0), (&#39;b&#39;, 1), (&#39;a&#39;, 2), (&#39;c&#39;, 3)]
print(&#39;按照键降序：&#39;, &#123;key: value for key, value in lst1&#125;)
print(&#39;按照值降序：&#39;, &#123;key: value for key, value in lst2&#125;)

# 按照键降序： &#123;&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0&#125;
# 按照值降序： &#123;&#39;d&#39;: 0, &#39;b&#39;: 1, &#39;a&#39;: 2, &#39;c&#39;: 3&#125;</code></pre></div></li>
<li><p>使用<code>sorted()</code>函数对序列中的多个字典排序</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">dict_list &#x3D; [
    &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;2&#39;&#125;,
    &#123;&#39;letter&#39;: &#39;A&#39;, &#39;number&#39;: &#39;3&#39;&#125;,
    &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;1&#39;&#125;
]

# 按 letter 排序
print(sorted(dict_list,
             key&#x3D;lambda dic: dic[&#39;letter&#39;]))
# 按 letter, number 排序
print(sorted(dict_list,
             key&#x3D;lambda dic: (dic[&#39;letter&#39;], dic[&#39;number&#39;])))
             
# [&#123;&#39;letter&#39;: &#39;A&#39;, &#39;number&#39;: &#39;3&#39;&#125;, &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;2&#39;&#125;, &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;1&#39;&#125;]
# [&#123;&#39;letter&#39;: &#39;A&#39;, &#39;number&#39;: &#39;3&#39;&#125;, &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;1&#39;&#125;, &#123;&#39;letter&#39;: &#39;B&#39;, &#39;number&#39;: &#39;2&#39;&#125;]</code></pre></div></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫入门</title>
    <url>/blog/posts/28509/</url>
    <content><![CDATA[<h1 id="爬虫基本原理">爬虫基本原理</h1>
<h2 id="网页构造">网页构造</h2>
<h3 id="前端简述">前端简述</h3>
<ul>
<li>前端开发最基本的是HTML、CSS和JavaScript，还有VUE等现代框架</li>
<li>HTML用于描述网页的内容，爬虫需要获取的信息往往就在html标签或文本里</li>
<li>有时网站的内容直接显示，有时则会通过js显示，就很蛋疼</li>
</ul>
<h2 id="爬虫工作流程">爬虫工作流程</h2>
<h3 id="基本的网络知识">基本的网络知识</h3>
<ul>
<li>网络连接最基本的工作就是发出一条request和一条response</li>
<li>request需要一条url，他不仅有一条域名，还包含header和属性等等</li>
<li>服务器通过header鉴别请求发出者是不是个人，cookie用来存放身份信息，等等</li>
</ul>
<h3 id="常用的python库">常用的python库</h3>
<ul>
<li>常用的第三方库一般有Requsts（用于发起网络请求）和BeautifulSoup（用于解析response），以及scrapy框架</li>
</ul>
<h3 id="url的构建">url的构建</h3>
<ul>
<li>对于多页面的网站，通常可以通过观察，使用占位符和<code>.format()</code>方法构建一个url列表</li>
<li>有时相信内容的url会在标签的文本内，有时会在属性的href标签内，分别通过<code>.get_text()</code>和<code>.get('tag')</code>来获取</li>
</ul>
<h3 id="请求内容的解析">请求内容的解析</h3>
<ul>
<li>bs4支持多种解析器，建议使用的是lxml（基于C）</li>
</ul>
<h1 id="简单爬虫程序">简单爬虫程序</h1>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests
from bs4 import BeautifulSoup
import time

# 请求头内容
headers &#x3D; &#123;
    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko) &#39;
                  &#39;Version&#x2F;15.2 Safari&#x2F;605.1.15&#39;
&#125;


def get_info(url):
    print(&#39;********* Start Analysing ********\n&#39;)
    print(url)
    res &#x3D; requests.get(url, headers&#x3D;headers) # 获取网站信息
    soup &#x3D; BeautifulSoup(res.text, &#39;lxml&#39;) # 使用bs4解析
    ranks &#x3D; soup.select(&#39;span.pc_temp_num&#39;) # 使用selector获取目标内容
    titles &#x3D; soup.select(&#39;div.pc_temp_songlist &gt; ul &gt; li &gt; a&#39;)
    for rank, title in zip(ranks, titles): # 多重循环进行遍历，构造字典
        data &#x3D; &#123;
            &#39;rank&#39;: rank.get_text().strip(&#39;\t&#39;), # 使用strip()方法除去空余内容
            &#39;singer&#39;: title.get(&#39;title&#39;).split(&#39; - &#39;)[0], # 使用.split()方法分割符合的内容
            &#39;song&#39;: title.get(&#39;title&#39;).split(&#39; - &#39;)[1]
        &#125;
        print(data)


if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kugou.com&#x2F;yy&#x2F;rank&#x2F;home&#x2F;&#123;&#125;-8888.html?from&#x3D;rank&#39;.format(str(i))
            for i in range(1, 10)] # 构造url列表
    for url in urls:
        get_info(url)
        time.sleep(1) # 每次请求等待1s，防止被ban
    print(&#39;Finish.&#39;)
</code></pre></div>
<h1 id="网络请求">网络请求</h1>
<h2 id="request库使用示例">Request库使用示例</h2>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requests

# header用来提供浏览器信息
headers &#x3D; &#123;
		&#39;User-Agent&#39;: &#39;content&#39;
&#125;

web_data &#x3D; requests.get(&#39;url&#39;,headers &#x3D; headers)</code></pre></div></li>
</ul>
<h2 id="request库的常用函数">Request库的常用函数</h2>
<h3 id="get请求">GET请求</h3>
<ul>
<li>使用<code>requests.get(url,headers)</code>方法发送GET请求并返回一个字符串实例</li>
</ul>
<h3 id="post请求">POST请求</h3>
<h1 id="请求内容的解析-1">请求内容的解析</h1>
<h2 id="bs4库示例">bs4库示例</h2>
<h2 id="bs4库常用函数">bs4库常用函数</h2>
<h3 id="元素的查找">元素的查找</h3>
<ul>
<li><p>find()：返回第一个符合匹配条件的元素</p></li>
<li><p>find_all()：返回所有符合条件的元素</p>
<blockquote>
<p>以上两个函数主要接收tag、attibutes和attrs三个参数，其中attrs参数接受一个字典</p>
</blockquote></li>
<li><p>select()：通过选择器寻找元素</p>
<blockquote>
<p>对于nth-child(1)这样的内容，需要修改为nth-of-type(1)</p>
<p>对于li:nth-child(1)这样的序列，可以改为li实现遍历，此时返回的对象是一个数组</p>
</blockquote></li>
</ul>
<h3 id="信息的获取">信息的获取</h3>
<ul>
<li>get_text()：主要获取文本内容</li>
<li>get()：获取标签内的内容</li>
</ul>
<h1 id="正则和re模块">正则和re模块</h1>
<h2 id="正则表达式">正则表达式</h2>
<h3 id="一般字符">一般字符</h3>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.</td>
<td>匹配单个任意字符</td>
</tr>
<tr class="even">
<td>\</td>
<td>转义字符</td>
</tr>
<tr class="odd">
<td>[...]</td>
<td>匹配集合中的任意一个字符</td>
</tr>
</tbody>
</table>
<h3 id="预定义字符集">预定义字符集</h3>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td> 任意一个数字字符</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>任意一个非数字字符</td>
</tr>
<tr class="odd">
<td></td>
<td>任何空白字符，如空格、制表符等（等价于</td>
</tr>
<tr class="even">
<td></td>
<td>任何非空白字符</td>
</tr>
<tr class="odd">
<td></td>
<td>任何单词字符，包括大小写字母和数字</td>
</tr>
<tr class="even">
<td></td>
<td>任何非单词字符</td>
</tr>
</tbody>
</table>
<h3 id="数量词">数量词</h3>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="边界匹配">边界匹配</h3>
<table>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="爬虫常用匹配">爬虫常用匹配</h3>
<h4 id="section">(.*?)</h4>
<ul>
<li><p>()表示括号的内容作为返回结果</p></li>
<li><p>.*?是非贪心算法，匹配任意字符</p></li>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import re
str &#x3D; &#39;xxIxxxxxloxxxvxxexxxxxpyxxthonxx&#39;
info &#x3D; re.findall(&#39;xx(.*?)xx&#39;,str)</code></pre></div></li>
</ul>
<h2 id="re模块">re模块</h2>
<h3 id="search">search()</h3>
<ul>
<li>匹配并返回第一个符合要求的内容，返回正则表达式对象</li>
<li>接收三个参数，分别是pattern、string和flags。其中flags标志位用来控制匹配选项</li>
<li>要将正则表达式对象转为普通对象，使用<code>.group()</code>方法</li>
</ul>
<h3 id="sub">sub()</h3>
<ul>
<li>用于替换符合条件的匹配项</li>
<li>接受五个参数，分别为pattern、repl、string、count和flag。其中count是替换的最大次数，0表示替换所有；flags为标志位</li>
</ul>
<h3 id="findall">findall()</h3>
<ul>
<li>匹配所有符合要求的内容，返回一个列表</li>
</ul>
<h3 id="修饰符">修饰符</h3>
<table>
<thead>
<tr class="header">
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>re.I</td>
<td></td>
</tr>
<tr class="even">
<td>re.L</td>
<td></td>
</tr>
<tr class="odd">
<td>re.M</td>
<td></td>
</tr>
<tr class="even">
<td>re.S</td>
<td></td>
</tr>
<tr class="odd">
<td>re.U</td>
<td></td>
</tr>
<tr class="even">
<td>re.X</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>其中常用的是<code>re.S</code>能够实现换行匹配</li>
</ul>
<h1 id="lxml库与xpath">Lxml库与Xpath</h1>
<ul>
<li>Lxml使用Xpath语法对XML进行解析，是基于C的libxml2的Python封装</li>
</ul>
<h2 id="使用lxml解析html">使用Lxml解析HTML</h2>
<ul>
<li>主要使用etree库</li>
</ul>
<h3 id="常用方法">常用方法</h3>
<ul>
<li>etree.HTML()/etree.parse()：解析HTML文件，返回element对象</li>
<li>etree.tostring：输出解析的element对象</li>
</ul>
<h2 id="xpath语言">Xpath语言</h2>
<h3 id="节点概念">节点概念</h3>
<h3 id="节点选择">节点选择</h3>
<ul>
<li>节点选择</li>
</ul>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>nodename</td>
<td></td>
</tr>
<tr class="even">
<td>/</td>
<td>根节点</td>
</tr>
<tr class="odd">
<td>//</td>
<td>当前节点的所有符合条件的子节点</td>
</tr>
<tr class="even">
<td>.</td>
<td>当前节点</td>
</tr>
<tr class="odd">
<td>..</td>
<td>当前节点的父节点</td>
</tr>
<tr class="even">
<td>@</td>
<td>选取属性</td>
</tr>
</tbody>
</table>
<ul>
<li>谓语</li>
</ul>
<table>
<thead>
<tr class="header">
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[n]</td>
<td>第n个元素（多个元素从1而不是0开始排列）</td>
</tr>
<tr class="even">
<td><span class="citation" data-cites="attribute">[@attribute]</span></td>
<td>含有指定属性的元素</td>
</tr>
<tr class="odd">
<td><span class="citation" data-cites="attribute">[@attribute='']</span></td>
<td>属性为某特定值</td>
</tr>
</tbody>
</table>
<h3 id="技巧">技巧</h3>
<ul>
<li><p>/text()：获取标签中的文字信息</p></li>
<li><p>切片索引：将返回的数组转换为字符串</p></li>
<li><p>starts-with：获取多个标签内容，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from lxml import etreee
html &#x3D; &#39;&#39;&#39;
&lt;li class&#x3D;&#39;tag-1&#39;&gt;content1&lt;&#x2F;li&gt;
&lt;li class&#x3D;&#39;tag-2&#39;&gt;content2&lt;&#x2F;li&gt;
&lt;li class&#x3D;&#39;tag-3&#39;&gt;content3&lt;&#x2F;li&gt;
&#39;&#39;&#39;
selector &#x3D; etree.HTML(html)
contents &#x3D; selector.xpath(&#39;&#x2F;&#x2F;li[starts-with(@class,&quot;tag&quot;)]&#x2F;text()&#39;)
for content in contents:
	print(content)</code></pre></div></li>
<li><p>.string()：用于获取嵌套字符串的信息并保留父子关系，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from lxml import etreee
html &#x3D; &#39;&#39;&#39;
&lt;div class&#x3D;&quot;red&quot;&gt;content1
		&lt;h1&gt;content2&lt;&#x2F;h1&gt;
&lt;&#x2F;div&gt;
&#39;&#39;&#39;
selector &#x3D; etree.HTML(html)
content1 &#x3D; selector.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;red&quot;]&#39;)[0]
content2 &#x3D; content1.xpath(&#39;string(.)&#39;)</code></pre></div></li>
</ul>
<h1 id="api的使用">API的使用</h1>
<h2 id="api简介">API简介</h2>
<ul>
<li>不必多说</li>
<li>参阅API文档</li>
</ul>
<h2 id="json解析">JSON解析</h2>
<ul>
<li>使用json库，将JSON解析为Python字典、数组和字符串，非常好使</li>
</ul>
<h3 id="常用方法-1">常用方法</h3>
<ul>
<li>json.loads()：解析JSON</li>
<li>jsonElement.get()：获取信息</li>
<li>pprint.pprint()：格式化打印json数据</li>
</ul>
<h1 id="数据存储">数据存储</h1>
<h2 id="txt文件">txt文件</h2>
<h2 id="csv文件">csv文件</h2>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import csv
fp &#x3D; open(&#39;file&#39;)
writer &#x3D; csv.writer(fp) # 创建writer实例</code></pre></div></li>
<li><p>常用方法</p>
<ul>
<li>.writerow('key':'value')：</li>
</ul></li>
<li><p>可能需要修正编码格式</p></li>
</ul>
<h2 id="xlsx文件">xlsx文件</h2>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import xlwt
book &#x3D; xlwt.Workbook(encoding&#x3D;&#39;utf-8&#39;) # 创建工作簿
sheet &#x3D; book.add_sheet(&#39;Sheet1&#39;) # 创建工作表
sheet.write(row,column,&#39;value&#39;) # 写入数据
sheet.save(&#39;filename&#39;)</code></pre></div></li>
</ul>
<h2 id="mongodb存储">MongoDB存储</h2>
<ul>
<li>MongDB是一种文档型数据库，NoSQL还包含键值存储型数据库（Redis）、列存储数据库（Hbase）和图形数据库（Graph）</li>
</ul>
<h2 id="mysql存储">MySQL存储</h2>
<h1 id="多线程爬虫">多线程爬虫</h1>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">from multiprocessing import Pool
if __name__&#x3D;&#x3D;&#39;__main__&#39;:
		pool &#x3D; Pool(processes&#x3D;4)
pool.map(get_info,rest_urls)</code></pre></div></li>
</ul>
<h1 id="异步加载网页">异步加载网页</h1>
<ul>
<li>主要通过抓取XHR信息获取url来实现</li>
</ul>
<h1 id="表单交互与模拟登录">表单交互与模拟登录</h1>
<h2 id="post请求-1">POST请求</h2>
<h3 id="post的使用">POST的使用</h3>
<ul>
<li><p>构造一个字典存储属性，并在请求时以data字段加入，示例</p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">param &#x3D; &#123;
	&#39;key&#39;:&#39;value&#39;,
	&#39;key&#39;:&#39;value&#39;
&#125;
web_data &#x3D; requests.post(url,data&#x3D;param)</code></pre></div></li>
</ul>
<h3 id="网页表单的提交">网页表单的提交</h3>
<ul>
<li>所有表单都在dorm标签内</li>
<li>form标签有两个重要属性，分别是提交的URL，action和提交的字段，input</li>
<li>提交表单后，可以根据登录状态进行判断是否成功</li>
</ul>
<h2 id="cookie与模拟登录">Cookie与模拟登录</h2>
<h1 id="selenium模拟浏览器">Selenium模拟浏览器</h1>
<h1 id="scrapy框架">Scrapy框架</h1>
<h2 id="框架基本使用">框架基本使用</h2>
<h3 id="简介">简介</h3>
<h4 id="主要组件及其功能">主要组件及其功能</h4>
<ul>
<li>Scrapy Engine</li>
<li>Spiders：实体类，用于提取网页数据，用“item”表示</li>
<li>Item Pipeline：用于处理Spiders抽取的实体，进行数据处理</li>
</ul>
<h4 id="目录结构">目录结构</h4>
<ul>
<li>spiders：具体的爬虫程序</li>
<li>items.py：存放实体类，继承自<code>scrapy.Item</code></li>
<li>middlewares.py：</li>
<li>pipelines.py：用于处理数据</li>
<li>settings.py：框架配置，比如添加header、修改请求速度等</li>
<li>scrapy.cfg：项目配置</li>
</ul>
<h3 id="数据处理">数据处理</h3>
<h3 id="数据存储-1">数据存储</h3>
<h3 id="辅助功能">辅助功能</h3>
<h2 id="反爬虫">反爬虫</h2>
<h2 id="crawlspider">CrawlSpider</h2>
<h2 id="分布式爬虫">分布式爬虫</h2>
<h1 id="爬虫伪装">爬虫伪装</h1>
<h2 id="url的伪装">url的伪装</h2>
<h3 id="添加请求头">添加请求头</h3>
<ul>
<li>通过requests库添加header</li>
</ul>
<h2 id="请求频率">请求频率</h2>
<ul>
<li>等待一会儿，使用<code>time.sleep</code>方法</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Reinforcement Learning and Artificial Intelligence</title>
    <url>/blog/posts/48478/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Reinforcement Learning (RL) is a <strong>scientific theory</strong> (or hypothesis) that seeks to provide a <strong>computational explanation</strong> to the widely <strong>observed phenomenon</strong> that some complex <strong>physical system</strong> can adapt to the <strong>physical environment</strong> around it.</p>
<ul>
<li>scientific theory: links an observation (i.e. the subject) to some other reproducible observations (i.e. the evidence) with logic.</li>
<li>computational explanation</li>
<li>observed phenomenon</li>
<li>physical system</li>
<li>physical environment</li>
</ul>
<p>The Rl regard the physical world as a Markov chain. Consider a physical system that interacts with a surrounding environment by exchanging mass/energy across the system boundary. The <strong>world (system + environment)</strong> changes over time, and is in a certain state <span class="math inline">\(\mathbf{s_t}\)</span> at each moment <span class="math inline">\(t\)</span>.</p>
<p>Different physical theories may formulate <span class="math inline">\(\mathbf{s_t}\)</span> into different mathematical objects (<span class="math inline">\(s\)</span> can be a vector, a tensor, a function, a function of functions, etc.). But in most physical theories, the time evolution of the state follows time-invariant (possibly stochastic) transition laws, such that <span class="math inline">\(\mathbf{s_t}\)</span> decouples the past from the future.</p>
<blockquote>
<p>Theorem (H. M. Sheffer, in Transactions of the American Mathematical Society, 1913): Every digital computer is functionally equivalent to an NAND network.</p>
</blockquote>
<h2 id="math-basics">Math Basics</h2>
<h3 id="probability-theory-basics">Probability Theory Basics</h3>
<blockquote>
<p>详见概率论相关的文章，这里摘录一下课上的大纲</p>
</blockquote>
<h4 id="probability-space">Probability Space</h4>
<ul>
<li>Sample Space, a set of all “possible worlds” under concern, each with full certainty and definiteness.</li>
<li>Event Space, a set of all random events; each event may occur in a subset of the possible worlds.</li>
<li>Probability function, mapping that assigns a real number to each random event to indicate its “propensity of occurrence”.</li>
</ul>
<h4 id="joint-probability-union-probability-union-bound">Joint Probability, Union Probability, Union Bound</h4>
<p>Union Bound:</p>
<p><span class="math display">\[
\begin{array}{c}
  P[{A_1}or{A_1}or{\dotsb}{ {A_n} }]{\le}\sum_{i=1}^{n}P[A_i]
\end{array}
\]</span></p>
<h4 id="conditional-probability-independence">Conditional Probability, Independence</h4>
<p>The conditional probability has been in a new probability space, so much different with joint probability.And to point it, use <span class="math inline">\(P_B[A]\)</span> is better than <span class="math inline">\(P[A|B]\)</span>.</p>
<p>To change the probability space</p>
<p><span class="math display">\[
\begin{array}{c}
  P[AB]=P[A|B]P[B]=P[B|A]P[A]
\end{array}
\]</span></p>
<p>And if we want to add a probability of C</p>
<p><span class="math display">\[
\begin{array}{c}
  P[AB|C]=P[A|BC]P[BC], or this form\\
  P_C[AB]=P_C[AB]P_C[B].\\
\end{array}
\]</span></p>
<h4 id="random-variable">Random Variable</h4>
<p>If <span class="math inline">\(X\)</span> is continuous, we will (ab-)use 𝐏[𝑋 = 𝑥] to refer (instead) to the probability density of <span class="math inline">\(X = x\)</span>.</p>
<p>If 𝑋 is continuous, we will (ab-)use Σ𝑥 (instead of ∫ d𝑥) to refer to the probabilistic integration</p>
<h4 id="probability-distribution">Probability Distribution</h4>
<p>A function 𝑷 is a probability distribution function if and only if (1) 𝑃 𝒙 ≥ 𝟎 and (2) σ𝒙 𝑃(𝒙) = �</p>
<h4 id="multivariate-variable-categorical-variable">Multivariate Variable, Categorical Variable</h4>
<ul>
<li>Multivariate variable (random vector), a vector of random variables.</li>
<li>Categorical variable, rand. var. whose values are “labels” (rather than “numbers”)</li>
<li>One-hot vectors, numerical representation for categorical variables</li>
</ul>
<h4 id="function-of-random-variable">Function of Random Variable</h4>
<p>For an ordinary, definite, and deterministic function, its output becomes a random variable if the input of the function is a random variable.</p>
<p>𝐏 𝑓 𝑋 = 𝑦 = σ{𝑥: 𝑓 𝑥 =𝑦} 𝐏[𝑋 = 𝑥]</p>
<h4 id="expectation-conditional-expectation-and-function-of-random-variables-expectation">Expectation, Conditional Expectation and Function of Random Variable's Expectation</h4>
<p>Expectation, also called expected value, or mean value, or simply the mean, is the probability-weighted average over all possible values of a random variable.</p>
<p>conditional expectation is conditioned on a random event, not on a random variable.</p>
<p>For a function, <span class="math inline">\(P[f(X)=y]=\sum_{\{x:f(x)=y\} }P[X=x]\)</span>, and <span class="math inline">\(E[f(X)]=\sum_{x}P[X=x]{\cdot}f(x)\)</span></p>
<p>typically used as <strong>distance unit</strong> to measure how far a particular value of 𝑋 deviates from the mean 𝐄[𝑋]</p>
<h4 id="variance-standard-deviation">Variance, Standard Deviation</h4>
<p>The variance of 𝑋 is the probability-weighted average of the squared distances between possible values of 𝑋 and its mean</p>
<p><span class="math display">\[
\begin{array}{c}
  Var[X]=E[(X-E[X])^2], and conveniently\\
  Var[X]=E[X^2]=(E[X])^2
\end{array}{c}
\]</span></p>
<p>Standard deviation <span class="math inline">\(\sigma(X)=\sqrt{Var[X]}\)</span></p>
<h4 id="covariance-and-correlation">Covariance and Correlation</h4>
<p>The covariance between two random variables 𝑋 and 𝑌 measures the tendency that the values of 𝑋 and 𝑌 jointly deviate in the same way from their respective mean values.</p>
<p>$$</p>
<p>$$</p>
<p>Pearson correlation coefficient normalizes the deviations by dividing the standard deviations, so that we always have 0 ≤ 𝜌(𝑋, 𝑌) ≤ 1</p>
<p>For multivariate random variable 𝑿 = 𝑋1, 𝑋2, … ,𝑋𝑛 T, the covariance matrix of 𝑿consists of all the pairwise covariances between the elements in 𝑿</p>
<h4 id="entropy-and-cross-entropy">Entropy and Cross Entropy</h4>
<p>The entropy of a random variable 𝑋 characterizes the inherent uncertainty of 𝑋, or equivalently, the “expected surprise” when observing a sample of 𝑋.</p>
<p>The uniform distribution is the maximum-entropy distribution among all probability distributions with the same support.</p>
<p>For two random variables 𝑋 and 𝑌 with the same support, the cross entropy of 𝒀relative to 𝑿 measures <strong>how 𝑌’s distribution differs from 𝑋’s distribution</strong>.</p>
<p>Cross entropy (or more accurately, 𝑯 𝒀 𝑿 − 𝑯(𝑿), called the KL-divergence) is usually used as a measure of the <strong>distance between two distributions</strong></p>
<h3 id="parametric-models-in-statistics">Parametric Models in Statistics</h3>
<h4 id="gaussian-model">Gaussian Model</h4>
<p>Gaussian distribution is so widely observed that it’s been called, the normal</p>
<p>当样本数据 X 是一维数据（Univariate）时，高斯分布遵从下方概率密度函数（Probability Density Function）<sup>2</sup>：</p>
<p><span class="math display">\[
N(x;\mu,\sigma^2)={\frac{1}{\sigma \sqrt{2\pi} } }e^{ {-\frac{1}{2} }(\frac{x-\mu}{\sigma})^2}
\]</span></p>
<blockquote>
<p>A parametric model that well captures the probability distribution of not a single, but many random variables encountered in the real world.</p>
</blockquote>
<p><strong>Gaussian distribution</strong> has a single “peak” (called the mode of the distribution). For many random variables <span class="math inline">\(Y\)</span> in the real world, its marginal distribution <span class="math inline">\(P(y)\)</span> is <strong>multi-modal</strong>.</p>
<p>Sometimes such <span class="math inline">\(P(y)\)</span> can be decomposed into a mixture of unimodal distributions.</p>
<p><span class="math display">\[
P(y)=\sum_{x}P(x)P(y|x)
\]</span></p>
<p>where <span class="math inline">\(X\)</span> is another observable random variable.</p>
<p>we can fit the conditional distribution <span class="math inline">\(P(y|x)\)</span> , with a separate Gaussian function, for each <span class="math inline">\(x\)</span></p>
<p><span class="math display">\[
f(y;\mathbf{\theta})=\sum_{x}P(x)N(y;\mu_x,\sigma_x^2), \\
where {\quad}\mathbf{\theta}=({\mu_1},{\mu_2},\dotsb,{\mu_n},{\sigma_1},{\sigma_2},\dotsb,{\sigma_n})
\]</span></p>
<p><strong>Gaussian Mixture Model, GMM</strong> method seeks to estimate <span class="math inline">\(\mathbf{\theta}\)</span> for the mixture distribution <span class="math inline">\(f\)</span> without observing <span class="math inline">\(X\)</span>.</p>
<p>高斯混合模型可以看作是由 K 个单高斯模型组合而成的模型，这 K 个子模型是混合模型的隐变量（Hidden variable）。一般来说，一个混合模型可以使用任何概率分布，这里使用高斯混合模型是因为高斯分布具备很好的数学性质以及良好的计算性能<sup>2</sup>。</p>
<p>We can further factorize <span class="math inline">\(X\)</span> into a mixture distribution, depending on some <span class="math inline">\(Z\)</span>, and so on, eventually leading to a <strong>Probabilistic Graphical Model</strong> (called <strong>Bayesian Network</strong>)</p>
<h4 id="gaussian-linear-model1">Gaussian Linear Model<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="机器学习——线性高斯模型
">[1]</span></a></sup></h4>
<p>When <span class="math inline">\(X\)</span> has infinite support, we can’t parameterize <span class="math inline">\(f\)</span> with a finite number of <span class="math inline">\(\mu x\)</span> and <span class="math inline">\(\sigma x\)</span>.</p>
<p>In this case, we can make <span class="math inline">\(\mu\)</span> (and <span class="math inline">\(\sigma\)</span>) a function of <span class="math inline">\(x\)</span>, and parameterize <span class="math inline">\(f\)</span> through parameterizing the functions <span class="math inline">\(\mu(x)\)</span> and <span class="math inline">\(\sigma(x)\)</span></p>
<p>Gaussian Linear Models (or Linear Gaussian Models) are parametric models that seek to fit the <strong>conditional probabilities</strong> <span class="math inline">\(P[Y=y|X=x]\)</span>, where both <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are observablerandom variables, with a Gaussian function with linear mean:</p>
<p><span class="math display">\[
f(y|x;a,b,\sigma)=N(y;ax+b,\sigma)={\frac{1}{\sigma{\sqrt{2\pi} } } }e^{ {-\frac{1}{2} }{(\frac{y-(ax+b)}{\sigma})}^2}
\]</span></p>
<p>With separately learned distribution <span class="math inline">\(P(x)\)</span>, the Gaussian Linear function <span class="math inline">\(f(y|x;a,b,\sigma)\)</span>can model more complex marginal distribution of <span class="math inline">\(Y\)</span> (than a single Gaussian function can), <span class="math inline">\(P[Y=y]=\sigma_x{P(x)f(y|x;a,b,\sigma)}\)</span>.</p>
<p>Often, we just care about the conditional probability for its own sake (e.g. in policy learning), <span class="math inline">\(P[Y=y|X=x]=f(y|x;a,b,\sigma)\)</span>.</p>
<h4 id="maximum-likelihood-estimation-mle">Maximum Likelihood Estimation, MLE</h4>
<p>对于单高斯模型，我们可以用最大似然法估算参数 <span class="math inline">\(\mathbf{\theta}\)</span>的值<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="高斯混合模型（GMM） - 戴文亮的文章 - 知乎
">[2]</span></a></sup></p>
<p><span class="math display">\[
\prod^{n}_{i=1}{\mathbf{P_{\theta} } }[{Y_i}={y_i}|{X_i}={x_i}]=\prod^{n}_{i=1}f({x_i,y_i;\mathbf{\theta} })
\]</span></p>
<p>The MLE principle proposes to choose the parameter vector <span class="math inline">\(\mathbf{\theta}\)</span> that maximizes the function, which is equivalent to minimize the <strong>negative-log-likelihood (NLL) function</strong>:</p>
<p><span class="math display">\[
-\log{\prod^{n}_{i=1}f({x_i,y_i;\mathbf{\theta} })}=-{\sum_i}\log f({x_i,y_i;a,b,\sigma})={\frac{1}{2\sigma^2} }{({\sum_i}(a{x_i}+b-{y_i})^2)}+n\log{\sigma{\sqrt{2\pi} } }
\]</span></p>
<h4 id="gaussian-linear-model-with-multivariate">Gaussian Linear Model with Multivariate</h4>
<p>Multivariate Gaussian Linear Model is a parametric model that seeks to fit the conditional distribution <span class="math inline">\(Y=y|\mathbf{X}=\mathbf{x}\)</span>, where <span class="math inline">\(\mathbf{X}\)</span> is an observable <strong>multivariate random variable</strong>, such that</p>
<p><span class="math display">\[
f(y|\mathbf{x};\mathbf{w},\sigma)=N(y;{\mathbf{w}\cdot\mathbf{x} },\sigma)={\frac{1}{\sigma{\sqrt{2\pi} } } }e^{ {-\frac{1}{2} }{(\frac{y-{\mathbf{w}\cdot\mathbf{x} } }{\sigma})}^2}
\]</span></p>
<h4 id="gasussian-linear-regression-and-mean-squared-error-mse">Gasussian Linear Regression and Mean Squared Error, MSE</h4>
<p>The Gaussian linear function can be alternatively viewed as a parametric model for a “perturbed mapping” from a vector variable 𝒙 to a scalar variable 𝑦, where the perturbation is a Gaussian noise <span class="math inline">\(\epsilon ~ N(0,\sigma^2)\)</span></p>
<p>Given observations and the parameter vector as the linear coefficients, can be equivalently chosen based on the <strong>Mean Squared Error (MSE) principle</strong>, without the explicit probabilistic interpretation</p>
<p><span class="math display">\[
{L_{MSE} }={\frac{1}{n} }\sum_i{(\mathbf{w\cdot x}-{y_i})^2}
\]</span></p>
<h4 id="logistic-regression">Logistic Regression</h4>
<p>深度学习的实践说明，线性回归总是存在他的局限性。</p>
<p>Generalized linear model in the form of</p>
<p><span class="math display">\[
g(\mathbb{}{x};\mathbb{w})=\phi(\mathbf{w}\cdot \mathbf{x}), {\quad}\phi(s)=\frac{1}{1+e^{-s} }
\]</span></p>
<p>or other function with the similar S-shape curve</p>
<h4 id="deep-logistic-networks">Deep Logistic Networks</h4>
<h2 id="elements-in-reinforcement-learning">Elements in Reinforcement Learning</h2>
<p><strong>RL is a Cross-disciplinary nature.</strong></p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3ve5vqbuoj20xa0u0q5v.jpg" alt="image-20220705010806726" /><figcaption aria-hidden="true">image-20220705010806726</figcaption>
</figure>
<h3 id="origin-of-rl">Origin of RL</h3>
<p>Reinforcement: The observation that under some conditions, some stimulus has the effect that it can increase the likelihood of the action preceding it, with a reproducible pattern.</p>
<p>Behavioral psychology research not only gave birth to the name of RL, but more importantly, provides abundant experimental data for the RL theory to explain.</p>
<h3 id="the-policy">The Policy</h3>
<p>Policy is changing during learning.</p>
<p>When a system learns, the mapping rule between its inputs (=observations) and outputs (=actions) must be changing.</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3vef3efh3j20na0b03yy.jpg" alt="image-20220705011701586" /><figcaption aria-hidden="true">image-20220705011701586</figcaption>
</figure>
<p>The mapping rule is called <strong>a decision policy function</strong>, or just <strong>policy</strong> for short.</p>
<ul>
<li>Deterministic policy: <span class="math inline">\(\mathbf{a_t}=\pi(\mathbf{x_t})\)</span></li>
<li>Stochastic policy: <span class="math inline">\(P[{A_t}=\mathbf{a_t}|{X_t}=\mathbf{x_t}]=\pi(\mathbf{x_t},\mathbf{a_t})\)</span>,so that <span class="math inline">\({A_t}~\pi({x_t},\cdot)\)</span></li>
</ul>
<h4 id="parameterization">Parameterization</h4>
<p>For any system to learn anything, its policy <span class="math inline">\(\pi\)</span> must be able to change flexibly</p>
<p>With a parameter <span class="math inline">\(\theta\)</span>, we get</p>
<ul>
<li>Deterministic policy: <span class="math inline">\(\mathbf{a_t}=\pi(\mathbf{x_t},\theta)\)</span></li>
<li>Stochastic policy: <span class="math inline">\(P[{A_t}=\mathbf{a_t}|{X_t}=\mathbf{x_t}]=\pi(\mathbf{x_t},\mathbf{a_t},\theta)\)</span></li>
</ul>
<p>To change the model <span class="math inline">\(\pi\)</span>, we only need to change its parameter <span class="math inline">\(\theta\)</span>.</p>
<p>For flexible learning, we want the model to cover a large enough set of possible policy functions. For example, a linear model is impossible to learn effectively if the optimal policy is <span class="math inline">\(a=x^2\)</span>.</p>
<h4 id="trial-and-error">Trial and Error</h4>
<p>Trial and Error is family of optimization methods that can optimize an objective function <span class="math inline">\(J\)</span> without explicit knowledge (e.g. the closed form) about <span class="math inline">\(J\)</span>.</p>
<p>The trial-and-error process results in a trace of policies with improving performance</p>
<h3 id="related-modelspreview">Related models(preview)</h3>
<p>About parameterization:</p>
<ul>
<li>Regression models in statistics</li>
<li>Parameterization in biological neuronal networks</li>
<li>Artificial neural networks</li>
<li>From Genotype to Biological Fitness</li>
</ul>
<p>About trial and error:</p>
<ul>
<li>Evolution as a special form of trial-and-error learning</li>
<li>Evolutionary algorithms in AI</li>
<li>Policy Gradient Method, Stochastic Gradient Descent (SGD)</li>
<li>Bandit Algorithms, Upper Confidence Bound (UCB) Algorithm</li>
<li>Q-Learning</li>
<li>Monte-Carlo Tree Search</li>
<li>Correspondence in Cognitive Neuroscience</li>
<li>Deep Reinforcement Learning</li>
</ul>
<h2 id="biological-neural-nwtwork">Biological Neural Nwtwork</h2>
<p>Brain consists of two types of cells: glial cells and neurons.</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3x8m229o2j218e0u0gr7.jpg" alt="image-20220706152706244" /><figcaption aria-hidden="true">image-20220706152706244</figcaption>
</figure>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3x8nz6x74j21aa0fktbd.jpg" alt="image-20220706152905711" /><figcaption aria-hidden="true">image-20220706152905711</figcaption>
</figure>
<h3 id="integrate-and-fire-model">Integrate-and-fire Model</h3>
<p><strong>Action potential</strong> in pre-synaptic neuron induces <strong>response current</strong> in post-synaptic neuron.Resoonse current decays over time.</p>
<p><span class="math display">\[
{I_{response}({\Delta t})}={\frac{w_i}{\tau_s} }e^{-{\Delta t}/{\tau_s} }
\]</span></p>
<blockquote>
<p>Response currents from all synapses integrate through the dendrite of the post-synaptic neuron, accumulating potential imbalance in the membrane of the cell, until <strong>reaching a threshold</strong> at which point a post-synaptic action potential is released (which resets the membrane potential)</p>
</blockquote>
<p>Firing-rate model is a statistical model of biological neural networks, which assumes that functionality of a biological neural network mostly depends on <strong>frequency patterns of the action potentials</strong> flowing in the network, whose precise timing patterns do not matter.</p>
<p>The firing rate of a neuron is a <strong>function of time <span class="math inline">\(t\)</span></strong> which gives the <strong>frequency density of action potentials</strong> that the neuron would probabilistically release at each time point <span class="math inline">\(t\)</span>.</p>
<p><span class="math display">\[
{x(t)}=\lim_{ {\Delta t}\rightarrow 0}\mathbf{E}[\frac{ {spikes{\ }in}[t-{\Delta t},t]}{\Delta t}]
\]</span></p>
<p>Firing-rate <span class="math inline">\(x_i(\cdot)\)</span> of pre-synaptic neuron <span class="math inline">\(i\)</span> induces a response current <span class="math inline">\(I_i(\cdot)\)</span> at post synaptic neuron. Response currents from all synapses integrate into a total synaptic current <span class="math inline">\(I(\cdot)\)</span> which induces the firing-rate <span class="math inline">\(y(\cdot)\)</span> of the post-synaptic neuron.</p>
<p>Step by step,</p>
<ol type="1">
<li>Response current induced by a single action potential: <span class="math inline">\({I_{response}(\Delta t)}={\frac{w_i}{\tau_s} }e^{-{\Delta t}/{\tau_s} }\)</span></li>
<li>Response current induced by all spikes of synapse <span class="math inline">\(i\)</span>: <span class="math inline">\({I_i(t)}={\int_{-\infty}^{t} }{I_{response}(t-\tau){s_i(\tau)d\tau} }\)</span></li>
<li>Total synaptic current induced by all spikes of all synapses: <span class="math inline">\(I(t)=\sum_i{T_i(t)}\)</span></li>
</ol>
<p>Finally, firing rates <span class="math inline">\(\mathbf{x}\)</span> of all the pre-synaptic neurons collectively induce total synaptic current <span class="math inline">\(I\)</span> at the post-synaptic neuron:</p>
<p><span class="math display">\[
{\tau_s}{\frac{\mathrm{d}I}{\mathrm{d}t} }=-I\,+\,\mathbf{w}\cdot\mathbf{x}
\]</span></p>
<p>Total synaptic current <span class="math inline">\(I\)</span> determines the firing rate <span class="math inline">\(y\)</span> of the post-synaptic neuron</p>
<p><span class="math display">\[
{\tau_r}{\frac{\mathrm{d}y}{\mathrm{d}t} }=-y+\phi(I)
\]</span></p>
<p>where <span class="math inline">\(\phi(\cdot)\)</span> is called the <strong>activation function</strong> of the (post-synaptic) neuron.</p>
<h3 id="activity-independent-synaptic-plasticity-and-hebbian-rule">Activity-independent Synaptic Plasticity and Hebbian Rule</h3>
<p><strong>Plasticity</strong> is the ability of a solid material to undergo permanent deformation, a persistent change of shape in response to applied forces.</p>
<p>Changes of a synapse’s strength <span class="math inline">\(w\)</span> that persist for tens of minutes or longer are generally called long-term potentiation (LTP) and long-term depression (LTD). Activity-dependent long-term synaptic plasticity is widely believed to be the biological foundation underlying the phenomenon of learning and memory.</p>
<p>The <strong>Hebbian theory</strong> is the best-known model for activity-dependent long-term synaptic plasticity. The <strong>Hebbian rule</strong> states that synapses change in proportion to the covariance between activities of the pre- and post-synaptic neurons.</p>
<p>赫布理论（英語：Hebbian theory）是一个神经科学理论，解释了在学习的过程中脑中的神经元所发生的变化。赫布理论描述了突触可塑性的基本原理，即突触前神经元向突触后神经元的持续重复的刺激，可以导致突触传递效能的增加。这一理论由唐纳德·赫布于1949年提出，又被称为赫布定律（Hebb's rule）、赫布假说（Hebb's postulate）、细胞结集理论（cell assembly theory）等<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="赫布理论 - 维基百科
">[3]</span></a></sup>。</p>
<p>“当神经元 A 的一个轴突和神经元 B 很近，足以 对它产生影响，并且持续地、重复地参与了对神经元 B 的兴奋，那么在这两个神 经元或其中之一会发生某种生长过程或新陈代谢变化，以致神经元 A 作为能使 神经元B兴奋的细胞之一，它的效能加强了．”这个机制称为赫布理论（Hebbian Theory）或赫布规则（Hebbian Rule，或 Hebb’s Rule）．如果两个神经元总是相 关联地受到刺激，它们之间的突触强度增加．这样的学习方法被称为赫布型学习 （Hebbian learning）．Hebb认为人脑有两种记忆：长期记忆和短期记忆．短期记 忆持续时间不超过一分钟．如果一个经验重复足够的次数，此经验就可储存在长 期记忆中．短期记忆转化为长期记忆的过程就称为凝固作用．人脑中的海马区为 大脑结构凝固作用的核心区域<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="机器学习简介
">[4]</span></a></sup></p>
<ul>
<li>Let real number <span class="math inline">\(w\)</span> denote the <strong>strength of an excitatory synapse</strong>, <span class="math inline">\(x(t)\)</span> and <span class="math inline">\(y(t)\)</span> the pre- and post-synaptic firing rates at time <span class="math inline">\(t\)</span>,</li>
</ul>
<p><span class="math display">\[
{\tau_w}{\frac{\mathrm{d}w}{\mathrm{d}t} }=x(t){\,}y(t)
\]</span></p>
<ul>
<li>Let <strong>random variable</strong> <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> be the pre- and post-synaptic firing rates at a random time <span class="math inline">\(\tau\)</span> in a time window <span class="math inline">\([t-{\Delta t},t]\)</span>,</li>
</ul>
<p><span class="math display">\[
{\tau_w}{\frac{\mathrm{d}w}{\mathrm{d}t} }=\mathbf{E}[XY]-{\mathbf{E}[X]}{\mathbf{E}[Y]}
\]</span></p>
<h2 id="artificial-neural-networks-ann">Artificial Neural Networks, ANN</h2>
<blockquote>
<p>ANN在统计领域由于难以证明，近几年虽然在动力系统、抽象代数的方向上有研究，但可解释性还是比较差；生物科学方面，过于复杂的脑神经系统仍然难以模仿，不过话说回来，全脑模拟也确实是一个研究方向；最后，AI领域曾在早期被提出，但由于过于庞大被搁置了数十年</p>
</blockquote>
<p>Parameterization in AI:</p>
<ul>
<li>Neural-network models</li>
<li>Tabular models</li>
<li>Non-differentiable models</li>
</ul>
<h3 id="multi-layer-perceptron-mlp">Multi-Layer Perceptron, MLP</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3ycb4jbvej20si0jcn08.jpg" alt="image-20220707142039567" /><figcaption aria-hidden="true">image-20220707142039567</figcaption>
</figure>
<p>Each hidden-layer and ouput-layer node <span class="math inline">\(i\)</span> repoesents a sub-mode <span class="math inline">\(g(\mathbf{x};\mathbf{w_i},b_i)=\phi({\mathbf{w_i}\cdot{\mathbf{x} }+{b_i} })\)</span>. If define <span class="math inline">\(\mathbf{\bar{x} }=(\mathbf{x},1)^T,{\;}\bar{\mathbf{w_i} }=(\mathbf{w_i},{b_i})\)</span></p>
<h3 id="activitation-functions">Activitation Functions</h3>
<ul>
<li><p>Sigmoid, it can seperate when the <strong>input is too large</strong>: <span class="math display">\[
\sigma(x)=\frac{1}{1+e^{-x} }
\]</span></p></li>
<li><p>tanh: <span class="math inline">\(\tanh(x)\)</span></p></li>
<li><p>ReLU: <span class="math inline">\(max(0,x)\)</span></p></li>
<li><p>Leaky</p></li>
<li><p>ReLU</p></li>
<li><p>Maxout</p></li>
<li><p>ELU</p></li>
</ul>
<p>一个MLP模型的需要的参数是非常多的，以一个输入<span class="math inline">\(\mathbb{R}^5\)</span>，有两个<span class="math inline">\(\mathbb{R}^7\)</span>隐藏层并输出<span class="math inline">\(\mathbb{R}^4\)</span>的网络来讲，他需要的参数是</p>
<p><span class="math display">\[
n=[(N_{input}+1)\cdot{N_{next} }]+[(N_{hidden1}+1)\cdot{N_{next} }]+[(N_{hidden2}+1)\cdot{N_{output} }]=170
\]</span></p>
<p>A <strong>decision policy</strong> determines the probability that an “intelligent” system would output a particular “action” in a time step conditioned on aparticular “state” of the system.</p>
<p>A policy function 𝜋 is a conditional probability distribution. As a probability distribution, any policy function has to satisfy the following constraints</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3ycvp1fuaj20wu0fuad9.jpg" alt="image-20220707144028629" /><figcaption aria-hidden="true">image-20220707144028629</figcaption>
</figure>
<p>For a discrete output, define <strong>softmax function</strong> and add it to the output layer</p>
<p><span class="math display">\[
\sigma:\mathbb{R}^K{\rightarrow}[0,1]^K,{\;}where{\;}\sigma_i(z)={\frac{e^{z_i} }{\sum_{j=1}^K}{e^{z_j} } },{\,} for{\,} i=1,\dotsb,K
\]</span></p>
<blockquote>
<p>由于指数的增长速率很大，这个函数可以“柔软”的放大输出之间的差异，并共同成为一个概率分布函数。</br> Softmax function是为了将输出转换为一个条件概率，而不是获得一个最大值。</p>
</blockquote>
<p>Then <span class="math inline">\(\pi(\mathbf{s},\mathbf{a};\mathbf{\theta})=\sigma(f_{MLP}(\mathbf{s};\mathbf{\theta}))\cdot\mathbf{a}\)</span></p>
<p>其中<span class="math inline">\(\mathbf{a}\)</span>是一组one-hot vector。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3yd81y6lyj21400fgq6i.jpg" alt="image-20220707144606874" /><figcaption aria-hidden="true">image-20220707144606874</figcaption>
</figure>
<h3 id="example-locomotion-control">Example: Locomotion Control</h3>
<h3 id="domain-specific-nn-architecture">Domain-specific NN architecture</h3>
<h4 id="convolutional-network">Convolutional Network</h4>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3yec7ew8rj214u0q6tc2.jpg" alt="image-20220707153056204" /><figcaption aria-hidden="true">image-20220707153056204</figcaption>
</figure>
<h4 id="transformer-network">Transformer Network</h4>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3yem057wej21z60magpd.jpg" alt="image-20220707154021201" /><figcaption aria-hidden="true">image-20220707154021201</figcaption>
</figure>
<h4 id="graph-network">Graph Network</h4>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3yep7une0j210g0jmwfq.jpg" alt="image-20220707154326848" /><figcaption aria-hidden="true">image-20220707154326848</figcaption>
</figure>
<h2 id="tabular-model-and-non-differential-model">Tabular Model and Non-differential Model</h2>
<p>A tabular model is a parametric model that covers the entire policy space.</p>
<h2 id="biological-evolution">Biological Evolution</h2>
<h2 id="homeworkds">HomeWorkds</h2>
<h3 id="homework-1.a">homework-1.a</h3>
<h2 id="references">References</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/young978/p/15813842.html">机器学习——线性高斯模型</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/30483076">高斯混合模型（GMM） - 戴文亮的文章 - 知乎</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span><a href="https://zh.m.wikipedia.org/zh/赫布理论">赫布理论 - 维基百科</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/qq_40808154/article/details/115407544">机器学习简介</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud入门</title>
    <url>/blog/posts/42360/</url>
    <content><![CDATA[<h2 id="简述">简述</h2>
<h3 id="分布式和微服务概述">分布式和微服务概述</h3>
<blockquote>
<p>参考资料</p>
<p><a href="https://cloud.google.com/learn/what-is-microservices-architecture?hl=zh-cn" class="uri">https://cloud.google.com/learn/what-is-microservices-architecture?hl=zh-cn</a></p>
<p><a href="https://www.zhihu.com/question/28253777" class="uri">https://www.zhihu.com/question/28253777</a></p>
</blockquote>
<p>不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：</p>
<ul>
<li>代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；</li>
<li>开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；</li>
<li>排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。</li>
</ul>
<p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，<strong>微服务架构</strong>逐渐取代了单体架构，且这种趋势将会越来越流行。</p>
<p>Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p>
<blockquote>
<p>微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。</p>
</blockquote>
<p><a href="https://cloud.google.com/containers?hl=zh-cn">容器</a>是微服务架构的绝佳示例，因为它们可让您专注于开发服务，而无需担心依赖项。现代云原生应用通常使用容器构建为微服务。</p>
<p>通常，微服务可用于加快应用开发速度。使用 Java 构建的微服务架构非常常见，尤其是 Spring Boot 架构。比较微服务与面向服务的架构也很常见。它们具有相同的目标，即将单体式应用分解为更小的组件，但这些架构所用的具体方法素有不同。</p>
<p>Google Cloud给出了一些微服务的示例，如</p>
<ul>
<li><p>网站迁移：托管在单体式平台上的复杂网站可以迁移到云端和基于容器的微服务平台。</p></li>
<li><p>媒体内容：通过使用微服务架构，图片和视频资源可以存储在可扩缩的对象存储系统中，并直接提供给网站或移动设备。</p></li>
<li><p>交易信息和帐单：付款处理和订单可分离开来，各自作为独立的服务单元，这样即便帐单服务无法正常工作，也能正常接收付款。</p></li>
<li><p>数据处理：微服务平台可以扩展对现有模块化数据处理服务的云端支持。</p></li>
</ul>
<p>从概念理解，<strong><a href="https://www.zhihu.com/search?q=分布式服务架构&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A551785648%7D">分布式服务架构</a>强调的是服务化以及服务的分散化，微服务则更强调服务的专业化和精细分工</strong>；从实践的角度来看，<strong>微服务架构通常是分布式服务架构</strong>，反之则未必成立。所以，<strong>选择微服务通常意味着需要解决分布式架构的各种难题。</strong></p>
<p>这里同时给出对于几个相关名词的解释</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 49%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="header">
<th>技术</th>
<th>实现方式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>分布式</td>
<td>不同模块部署在不同服务器上</td>
<td>分布式解决网站高并发带来的问题</td>
</tr>
<tr class="even">
<td>集群</td>
<td>相同服务部署在不同服务器上</td>
<td>通过负载均衡设备共同对外提供服务</td>
</tr>
<tr class="odd">
<td>SOA(组装服务/ESB企业服务总线)</td>
<td>业务系统分解为多个组件，让每个组件独立提供离散、自治、可复用的服务能力，通过服务的编排和组合来实现上层的业务流程</td>
<td>简化维护，降低整体风险，伸缩灵活</td>
</tr>
<tr class="even">
<td>微服务</td>
<td>各服务间隔离（分布式也是），自治（分布式要相互组合），具有单一职责、边界、异步通信和独立部署等特性</td>
<td>各服务可独立应用</td>
</tr>
</tbody>
</table>
<h3 id="微服务相关技术">微服务相关技术</h3>
<p>微服务架构的定义：微服务架构是一种应用架构类型，其中应用会开发为一系列服务。它提供了独立开发、部署和维护微服务架构图和服务的框架。</p>
<blockquote>
<p>在微服务架构中，每个微服务都是独立的服务，旨在容纳一种应用特性并处理离散的任务。每个微服务都通过简单的接口与其他服务通信，以解决业务问题。</p>
</blockquote>
<p>以下给出一个表格</p>
<table>
<thead>
<tr class="header">
<th>微服务条目</th>
<th>落地技术</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>服务开发</td>
<td>SpringBoot、Spring和SpringMVC</td>
<td></td>
</tr>
<tr class="even">
<td>服务配置与管理</td>
<td>Archaius（Netflix），Diamond（阿里）</td>
<td></td>
</tr>
<tr class="odd">
<td>服务注册与发现</td>
<td>Eureka、Consul、Zookeeper</td>
<td></td>
</tr>
<tr class="even">
<td>服务调用</td>
<td>Rest、RPC、gRPC</td>
<td></td>
</tr>
<tr class="odd">
<td>服务熔断器</td>
<td>Hystrix、Envoy</td>
<td></td>
</tr>
<tr class="even">
<td>负载均衡</td>
<td>Ribbon、Nginx</td>
<td></td>
</tr>
<tr class="odd">
<td>服务接口调用</td>
<td>Feign</td>
<td></td>
</tr>
<tr class="even">
<td>消息队列</td>
<td>Kafaka、RabbitMQ、ActiveMQ</td>
<td></td>
</tr>
<tr class="odd">
<td>服务配置中心管理</td>
<td>SpringCloudConfig、Chef</td>
<td></td>
</tr>
<tr class="even">
<td>服务路由（API网关）</td>
<td>Zuul</td>
<td></td>
</tr>
<tr class="odd">
<td>服务监控</td>
<td>Zabbix、Nagios、Metrics、Spectator</td>
<td></td>
</tr>
<tr class="even">
<td>全链路追踪</td>
<td>Zipkin、Brave、Dapper</td>
<td></td>
</tr>
<tr class="odd">
<td>服务部署</td>
<td>Docker、OpenStack、Kuberetes</td>
<td></td>
</tr>
<tr class="even">
<td>数据操作开发包</td>
<td>SpringCloud Stream</td>
<td></td>
</tr>
<tr class="odd">
<td>事件消息总线</td>
<td>SpringCloudBus</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="springcloud简介">SpringCloud简介</h2>
<blockquote>
<p>参考资料</p>
<p><a href="https://blog.51cto.com/lovebetterworld/2853431" class="uri">https://blog.51cto.com/lovebetterworld/2853431</a></p>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/103715146" class="uri">https://blog.csdn.net/ThinkWon/article/details/103715146</a></p>
</blockquote>
<p>Spring Cloud是<strong>一系列框架的有序集合</strong>。</p>
<p>它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<blockquote>
<p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步</p>
</blockquote>
<figure>
<img src="https://img-blog.csdnimg.cn/20191226143921760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>SpringCloud 和SpringBoot有密切的关系</p>
<ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发<strong>单个微服务</strong>，Spring Cloud是一个基于Spring Boot实现的云应用开发工具。Spring -&gt; Spring Boot &gt; Spring Cloud 这样的关系。</li>
<li>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系</li>
<li>Spring Boot专注于快速、方便集成的单个个体微服务，Spring Cloud是关注全局的服务治理框架</li>
<li>Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现</li>
</ul>
<h3 id="springcloud版本和组件">SpringCloud版本和组件</h3>
<p>Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。</p>
<p>为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。</p>
<p>为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。</p>
<p>当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。</p>
<p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架"Spring Boot化"的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。</p>
<h3 id="spring-cloud-config">Spring Cloud Config</h3>
<p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<h3 id="spring-cloud-netflix">Spring Cloud Netflix</h3>
<p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件</p>
<ul>
<li>Eureka：服务治理组件，包括服务端的<strong>注册中心</strong>和客户端的<strong>服务发现机制</strong>；</li>
<li>Ribbon：<strong>负载均衡</strong>的服务调用组件，具有多种负载均衡调用策略；</li>
<li>Hystrix：<strong>服务容错</strong>组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
<li>Feign：基于Ribbon和Hystrix的<strong>声明式服务调用</strong>组件；</li>
<li>Zuul：<strong>API网关组件</strong>，对请求提供路由及过滤功能。</li>
</ul>
<h3 id="spring-cloud-bus">Spring Cloud Bus</h3>
<p>用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<h3 id="spring-cloud-consul">Spring Cloud Consul</h3>
<p>基于Hashicorp Consul的服务治理组件。</p>
<h3 id="spring-cloud-security">Spring Cloud Security</h3>
<p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持</p>
<h3 id="spring-cloud-sleuth">Spring Cloud Sleuth</h3>
<p>Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>
<h3 id="spring-cloud-stream">Spring Cloud Stream</h3>
<p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot入门</title>
    <url>/blog/posts/22597/</url>
    <content><![CDATA[<script src='https://gitee.com/guo-surui/fuck_course_design/widget_preview' async defer></script>
<div id="osc-gitee-widget-tag">

</div>
<style>
.osc_pro_color {color: #4183c4 !important;}
.osc_panel_color {background-color: #ffffff !important;}
.osc_background_color {background-color: #ffffff !important;}
.osc_border_color {border-color: #e3e9ed !important;}
.osc_desc_color {color: #666666 !important;}
.osc_link_color * {color: #9b9b9b !important;}
</style>
<h1 id="前言">前言</h1>
<h2 id="三层架构">三层架构</h2>
<h3 id="基本层次">基本层次</h3>
<h3 id="podtodao等">PO、DTO、DAO等</h3>
<h3 id="各层设计原则">各层设计原则</h3>
<h3 id="一些范例">一些范例</h3>
<h2 id="restfulapi">RESTfulAPI</h2>
<blockquote>
<p>参考资料</p>
<p>https://www.runoob.com/w3cnote/restful-architecture.html</p>
</blockquote>
<h3 id="简述">简述</h3>
<p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。</p>
<blockquote>
<p>它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。</p>
<p>他在论文中提到："我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</p>
</blockquote>
<p>REST指的是<strong>一组架构约束条件和原则</strong>。" 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p>
<p>REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。</p>
<p>虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p>
<h3 id="进一步解释">进一步解释</h3>
<h4 id="资源与uri">资源与URI</h4>
<blockquote>
<p>REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。</p>
<p><strong>任何事物，只要有被引用到的必要，它就是一个资源。</strong></p>
<p>资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。</p>
</blockquote>
<p>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。</p>
<p>URI既可以看成是资源的地址，也可以看成是资源的名称。</p>
<blockquote>
<p>如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。</p>
</blockquote>
<p>URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联</p>
<h3 id="api的设计">API的设计</h3>
<h2 id="spring家族">Spring家族</h2>
<h3 id="spring">Spring</h3>
<h3 id="springboot">SpringBoot</h3>
<h3 id="ssm架构">SSM架构</h3>
<h3 id="springcloud">SpringCloud</h3>
<h1 id="spring原理">Spring原理</h1>
<h2 id="ioc容器">IOC容器</h2>
<h2 id="aop">AOP</h2>
<h1 id="springboot基本应用">SpringBoot基本应用</h1>
<h2 id="创建一个项目">创建一个项目</h2>
<h3 id="项目结构">项目结构</h3>
<p>一个全新的Springboot Web项目目录基本长成这个样子</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|- java
  |- com.package.name
    |- SpringBootDemoApplication
  |- resources
    |- application.properties
|- test
  |- java
    |- com.package.name
      |- SpringBootDemoApplicationTest
|- pom.xml</code></pre></div>
<p>可以参考如下形式构建项目结构</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|- POJO
|- DAO
|- DTO
|- VO
|- service
|- service Implements
|- controller
|- config
|- utils
|- constants</code></pre></div>
<p>其中一些分包和层次的解释</p>
<ul>
<li>POJO/PO：实体类，对于JPA项目可以使用models/domain，MyBatis项目可以使用pojo/entity</li>
<li>DAO：数据访问层，对于JPA项目可以使用repository，MyBatis项目可以使用mapper</li>
<li>DTO：数据传输对象，用于实现非侵入式的封装多个实体类之间的关系</li>
<li>VO：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li>
<li>Service：数据服务接口层</li>
<li>service implements：数据服务接口实现层，一般使用impl</li>
<li>controller：前端控制器</li>
</ul>
<p>对于Controller层，有一些约定</p>
<ul>
<li>参数传递建议不要使用HashMap，建议使用数据模型定义</li>
<li>可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到Service层代码中去做</li>
</ul>
<blockquote>
<p>参考资料</p>
<p>分层资料</p>
<p>https://blog.csdn.net/qq_35246620/article/details/77247427</p>
<p>https://www.zhihu.com/question/39651928</p>
<p>https://blog.csdn.net/qq_39615545/article/details/90172038</p>
<p>https://zhuanlan.zhihu.com/p/115403195</p>
<p>命名规范</p>
<p>https://blog.csdn.net/Luomingkui1109/article/details/78882468</p>
<p>https://blog.csdn.net/qq_33404395/article/details/79877384?utm_medium=distribute.pc_relevant.none-task-blog-2<sub>default</sub>baidujs_baidulandingword~default-1.pc_relevant_aa&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4</p>
<p>https://blog.csdn.net/weixin_30474613/article/details/95303995?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_paycolumn_v3&amp;utm_relevant_index=5</p>
</blockquote>
<h3 id="依赖分析">依赖分析</h3>
<blockquote>
<p>对于一个使用Maven配置的Springboot项目，依赖由<code>pom.xml</code>文件来描述。</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"># 版本号和编码
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;
    # 1------parent
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;
        &lt;version&gt;2.6.4&lt;&#x2F;version&gt;
        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;&#x2F;parent&gt;
    # 2-----项目元数据
    # 这一部分就是在创建时的Project Metadata
    &lt;groupId&gt;com.surui&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring_boot_example&lt;&#x2F;artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;
    &lt;name&gt;spring_boot_example&lt;&#x2F;name&gt;
    &lt;description&gt;spring_boot_example&lt;&#x2F;description&gt;
  
    &lt;properties&gt;
        &lt;java.version&gt;11&lt;&#x2F;java.version&gt;
    &lt;&#x2F;properties&gt;
    # 3-----具体依赖
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;
            &lt;scope&gt;test&lt;&#x2F;scope&gt;
        &lt;&#x2F;dependency&gt;
    &lt;&#x2F;dependencies&gt;
    # 4----构建配置
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;
            &lt;&#x2F;plugin&gt;
        &lt;&#x2F;plugins&gt;
    &lt;&#x2F;build&gt;

&lt;&#x2F;project&gt;
</code></pre></div>
<p>以上主要分为四个部分</p>
<ol type="1">
<li><p>parent：继承spring-boot-starter-parent的依赖管理，控制版本与打包等内容</p></li>
<li><p>项目元数据：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等</p></li>
<li><p>dependencies：项目具体依赖，这里包含了spring-boot-starter-web用于实现HTTP接口（该依赖中包含了Spring MVC）；spring-boot-starter-test用于编写单元测试的依赖包。更多功能模块的使用我们将在后面的教程中逐步展开。</p></li>
<li><p>build：构建配置部分。默认使用了spring-boot-maven-plugin，配合spring-boot-starter-parent就可以把Spring Boot应用打包成JAR来直接运行。</p></li>
</ol>
<h2 id="配置文件">配置文件</h2>
<blockquote>
<p>参考资料</p>
<p>https://blog.didispace.com/spring-boot-learning-21-1-3/</p>
</blockquote>
<p><code>src/main/resources</code>目录是Spring Boot的配置目录，所以我们要为应用创建配置个性化配置时，就是在该目录之下。Spring Boot的默认配置文件位置为： <code>src/main/resources/application.properties</code>。</p>
<p>关于Spring Boot应用的配置内容都可以集中在该文件中了，根据我们引入的不同Starter模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。</p>
<blockquote>
<p>比如，我们需要自定义web模块的服务端口号，可以在<code>application.properties</code>中添加<code>server.port=8888</code>来指定服务端口为8888，也可以通过<code>spring.application.name=hello</code>来指定应用名（该名字在Spring Cloud应用中会被注册为服务名）。</p>
</blockquote>
<p>Spring Boot的配置文件除了可以使用传统的properties文件之外，还支持现在被广泛推荐使用的YAML文件。</p>
<h3 id="多个环境分别配置">多个环境分别配置</h3>
<p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p>
<p>在Spring Boot中多环境配置文件名需要满足<code>application-&#123;profile&#125;.properties</code>的格式，其中<code>&#123;profile&#125;</code>对应你的环境标识，比如：</p>
<ul>
<li><code>application-dev.properties</code>：开发环境</li>
<li><code>application-test.properties</code>：测试环境</li>
<li><code>application-prod.properties</code>：生产环境</li>
</ul>
<p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应配置文件中的<code>&#123;profile&#125;</code>值。如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容。</p>
<p>因此，多环境配置有这个思路</p>
<ul>
<li><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</li>
<li><code>application-&#123;profile&#125;.properties</code>中配置各个环境不同的内容</li>
<li>通过命令行方式去激活不同环境的配置</li>
</ul>
<p>特别的，YAML可以在一个单个文件中通过使用<code>spring.profiles</code>属性来定义多个不同的环境配置。</p>
<p>例如下面的内容，在指定为test环境时，<code>server.port</code>将使用8882端口；而在prod环境，<code>server.port</code>将使用8883端口；如果没有指定环境，<code>server.port</code>将使用8881端口。</p>
<div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:
  port: 8881
---
spring:
  profiles: test
server:
  port: 8882
---
spring:
  profiles: prod
server:
  port: 8883</code></pre></div>
<h3 id="自定义参数和参数引用">自定义参数和参数引用</h3>
<p>在配置文件中添加<strong>自定义参数</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">book.name&#x3D;SpringCloudInAction
book.author&#x3D;ZhaiYongchao</code></pre></div>
<p>自定义参数时还可以<strong>引用参数</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">book.name&#x3D;SpringCloud
book.author&#x3D;ZhaiYongchao
book.desc&#x3D;$&#123;book.author&#125;  is writing《$&#123;book.name&#125;》</code></pre></div>
<p>就可以直接使用<code>@Value</code>注解调用自定义参数</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
public class Book &#123;

    @Value(&quot;$&#123;book.name&#125;&quot;)
    private String name;
    @Value(&quot;$&#123;book.author&#125;&quot;)
    private String author;

    &#x2F;&#x2F; 省略getter和setter
&#125;</code></pre></div>
<h3 id="建立实体类">建立实体类</h3>
<p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data
public class User &#123;

    private Long id;
    private String name;
    private Integer age;

&#125;</code></pre></div>
<blockquote>
<p>这里使用<code>@Data</code>注解可以实现在编译器自动添加set和get函数的效果。该注解是lombok提供的，只需要在<code>pom.xml</code>里引入即可</p>
</blockquote>
<h2 id="实现一个接口">实现一个接口</h2>
<h3 id="可能使用到的注解">可能使用到的注解</h3>
<ul>
<li><code>@Controller</code>：修饰class，用来创建处理http请求的对象</li>
<li><code>@RestController</code>：Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式</li>
<li><code>@RequestMapping</code>：配置url映射。现在更多的也会直接用以Http Method直接关联的映射注解来定义，比如：<code>GetMapping</code>、<code>PostMapping</code>、<code>DeleteMapping</code>、<code>PutMapping</code>等</li>
</ul>
<p>参数的绑定</p>
<ul>
<li><code>@RequestParam</code>：接受页面中传递来的参数</li>
<li><code>@RequestBody</code>：用来绑定通过http请求中application/json类型上传的数据</li>
<li><code>@PathVariable</code>：用于获取url中的参数，需要在映射时使用花括号注明</li>
</ul>
<h3 id="编写controller">编写Controller</h3>
<p>首先在类声明外使用注解<code>@RequestMapping(value = "/users")</code>进行一次分发，将所有<code>.../users/...</code>都分发到这个controller下</p>
<p>使用<code>GetMapping</code>等注解实现具体请求</p>
<blockquote>
<p>在这里没有对service层进行分离</p>
</blockquote>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
@RequestMapping(value &#x3D; &quot;&#x2F;users&quot;)     &#x2F;&#x2F; 通过这里配置使下面的映射都在&#x2F;users下
public class UserController &#123;

    &#x2F;&#x2F; 创建线程安全的Map，模拟users信息的存储
    static Map&lt;Long, User&gt; users &#x3D; Collections.synchronizedMap(new HashMap&lt;Long, User&gt;());

    &#x2F;**
     * 处理&quot;&#x2F;users&#x2F;&quot;的GET请求，用来获取用户列表
     *
     * @return
     *&#x2F;
    @GetMapping(&quot;&#x2F;&quot;)
    public List&lt;User&gt; getUserList() &#123;
        &#x2F;&#x2F; 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递
        List&lt;User&gt; r &#x3D; new ArrayList&lt;User&gt;(users.values());
        return r;
    &#125;

    &#x2F;**
     * 处理&quot;&#x2F;users&#x2F;&quot;的POST请求，用来创建User
     *
     * @param user
     * @return
     *&#x2F;
    @PostMapping(&quot;&#x2F;&quot;)
    public String postUser(@RequestBody User user) &#123;
        &#x2F;&#x2F; @RequestBody注解用来绑定通过http请求中application&#x2F;json类型上传的数据
        users.put(user.getId(), user);
        return &quot;success&quot;;
    &#125;

    &#x2F;**
     * 处理&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;的GET请求，用来获取url中id值的User信息
     *
     * @param id
     * @return
     *&#x2F;
    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)
    public User getUser(@PathVariable Long id) &#123;
        &#x2F;&#x2F; url中的id可通过@PathVariable绑定到函数的参数中
        return users.get(id);
    &#125;

    &#x2F;**
     * 处理&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;的PUT请求，用来更新User信息
     *
     * @param id
     * @param user
     * @return
     *&#x2F;
    @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)
    public String putUser(@PathVariable Long id, @RequestBody User user) &#123;
        User u &#x3D; users.get(id);
        u.setName(user.getName());
        u.setAge(user.getAge());
        users.put(id, u);
        return &quot;success&quot;;
    &#125;

    &#x2F;**
     * 处理&quot;&#x2F;users&#x2F;&#123;id&#125;&quot;的DELETE请求，用来删除User
     *
     * @param id
     * @return
     *&#x2F;
    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)
    public String deleteUser(@PathVariable Long id) &#123;
        users.remove(id);
        return &quot;success&quot;;
    &#125;

&#125;</code></pre></div>
<h1 id="mybatis">MyBatis</h1>
<h2 id="示例">示例</h2>
<ul>
<li><p>引入MyBatis的Starter以及MySQL Connector依赖</p>
<blockquote>
<p>注意MyBatis的版本关系</p>
<ul>
<li><code>2.1.x</code>版本适用于：MyBatis 3.5+、Java 8+、Spring Boot 2.1+</li>
<li><code>2.0.x</code>版本适用于：MyBatis 3.5+、Java 8+、Spring Boot 2.0/2.1</li>
<li><code>1.3.x</code>版本适用于：MyBatis 3.4+、Java 6+、Spring Boot 1.5</li>
</ul>
<p>其中，目前还在维护的是<code>2.1.x</code>版本和<code>1.3.x</code>版本</p>
</blockquote></li>
<li><p>在<code>application.properties</code>中配置mysql的连接配置</p></li>
<li><p>Mysql中创建一张用来测试的表</p></li>
<li><p>创建User表的映射对象User</p></li>
<li><p>创建User表的操作接口：UserMapper</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper
public interface UserMapper &#123;

    @Select(&quot;SELECT * FROM USER WHERE NAME &#x3D; #&#123;name&#125;&quot;)
    User findByName(@Param(&quot;name&quot;) String name);

    @Insert(&quot;INSERT INTO USER(NAME, AGE) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)
    int insert(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);

&#125;</code></pre></div></li>
</ul>
<h2 id="可能用到的注解">可能用到的注解</h2>
<ul>
<li><code>@Param：</code><span class="citation" data-cites="Param">@Param</span><code>中定义的</code>name<code>对应了SQL中的</code>#{name}<code>，</code>age<code>对应了SQL中的</code>#{age}`。</li>
<li><code>@Map</code>：通过<code>Map&lt;String, Object&gt;</code>对象来作为传递参数的容器</li>
</ul>
<h2 id="增删改查的实现">增删改查的实现</h2>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserMapper &#123;

    @Select(&quot;SELECT * FROM user WHERE name &#x3D; #&#123;name&#125;&quot;)
    User findByName(@Param(&quot;name&quot;) String name);

    @Insert(&quot;INSERT INTO user(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)
    int insert(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age);

    @Update(&quot;UPDATE user SET age&#x3D;#&#123;age&#125; WHERE name&#x3D;#&#123;name&#125;&quot;)
    void update(User user);

    @Delete(&quot;DELETE FROM user WHERE id &#x3D;#&#123;id&#125;&quot;)
    void delete(Long id);
&#125;</code></pre></div>
<h3 id="查询">查询</h3>
<p>对于增、删、改操作相对变化较小。而对于“查”操作，我们往往需要进行多表关联，汇总计算等操作，那么对于查询的结果往往就不再是简单的实体对象了，往往需要返回一个与数据库实体不同的包装类，那么对于这类情况，就可以通过<code>@Results</code>和<code>@Result</code>注解来进行绑定，具体如下：</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Results(&#123;
    @Result(property &#x3D; &quot;name&quot;, column &#x3D; &quot;name&quot;),
    @Result(property &#x3D; &quot;age&quot;, column &#x3D; &quot;age&quot;)
&#125;)
@Select(&quot;SELECT name, age FROM user&quot;)
List&lt;User&gt; findAll();</code></pre></div>
<p>在上面代码中，<span class="citation" data-cites="Result中的property属性对应User对象中的成员名">@Result中的property属性对应User对象中的成员名</span>，column对应SELECT出的字段名。在该配置中故意没有查出id属性，只对User对应中的name和age对象做了映射配置</p>
<h2 id="自动建表">自动建表</h2>
<blockquote>
<p>参考资料</p>
<p>https://github.com/zyf970617/mybatis-auto-create-table</p>
</blockquote>
<h2 id="跨表查询">跨表查询</h2>
<blockquote>
<p>参考资料</p>
<p>https://blog.51cto.com/u_15305798/3130563</p>
</blockquote>
<h1 id="spring-jpa">Spring Jpa</h1>
<h2 id="基本的实体管理">基本的实体管理</h2>
<h3 id="唯一性约束">唯一性约束</h3>
<h2 id="多表关联">多表关联</h2>
<blockquote>
<p>参考资料</p>
<p>https://glory.blog.csdn.net/article/details/79465859?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=1</p>
<p>https://chuhang123.github.io/2017/10/09/Learning-JPA-OneToMany/</p>
<p>https://www.jianshu.com/p/bf6b7b0da8d8</p>
<p>http://wangzhenhua.rocks/zh-hans/java/jpa-one-to-many-many-to-one-best-practice</p>
</blockquote>
<p>我们在使用JPA的时候，会使用OneToMany表示对象之间的一对多的关系，ManyToOne表示多对一的关系。</p>
<p>多对一和一对多只是对象关系中的正面描述和反面描述，在JPA中不一样的定义方法会有不同的SQL生成，对性能会有比较大的影响。</p>
<blockquote>
<p>比如我们举一个例子：一个学校会有很多的学生，很多学生都会在一个学校上学，那么我们应该会设计一个父对象School和一个子对象Student，School实体会和和Student之间有一对多的关联关系，Student实体和School实体有多对一的关联关系。</p>
</blockquote>
<p>在JPA中对于上述的场景描述我们会有三个不同的做法：</p>
<ol type="1">
<li>在父对象中使用<code>@OneToMany</code>建立和子对象的关系关系</li>
<li>在父对象中使用<code>@OneToMany</code>和<code>@JoinColumn</code>来建立和子对象的关系</li>
<li>建立双向关系，在父对象中使用<code>@OneToMany</code>，在子对象中使用<code>@ManyToOne</code></li>
<li>在子对象中使用<code>@ManyToOne</code>建立和父对象的联系</li>
</ol>
<h3 id="只在父对象中使用onetomany">只在父对象中使用<code>@OneToMany</code></h3>
<ul>
<li><p>只需要在父对象中声明即可，例如</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class School &#123;
    @Id
    @GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE)
    private long id;

    private String name;

    @OneToMany(
            cascade &#x3D; CascadeType.ALL,
            orphanRemoval &#x3D; true
    )
    @JoinColumn(name &#x3D; &quot;school_id&quot;)
    private List&lt;Student&gt; students;

&#125;

public class Student &#123;

    @Id
    @GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE)
    private long id;

    private String name;
&#125;</code></pre></div></li>
<li><p>这种方式实际上上建立了多对多的关系，也就是说Jpa会建立一张新的多对多表进行记录，SQL语句示例</p>
<div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">Hibernate: insert into School (name) values (?)
Hibernate: insert into Student (name) values (?)
Hibernate: insert into Student (name) values (?)
Hibernate: insert into Student (name) values (?)
Hibernate: insert into School_Student (School_id, students_id) values (?, ?)
Hibernate: insert into School_Student (School_id, students_id) values (?, ?)
Hibernate: insert into School_Student (School_id, students_id) values (?, ?)</code></pre></div></li>
</ul>
<h3 id="在父对象中使用onetomany和joincolumn">在父对象中使用<code>@OneToMany</code>和<code>@JoinColumn</code></h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class School &#123;
    @Id
    @GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE)
    private long id;

    private String name;

    @OneToMany(
            cascade &#x3D; CascadeType.ALL,
            orphanRemoval &#x3D; true
    )
    @JoinColumn(name &#x3D; &quot;school_id&quot;)
    private List&lt;Student&gt; students;

&#125;</code></pre></div></li>
<li><p>这里没有生成多对多的中间表，而是在student表中多了一个school_id的字段，要比上面生成的sql要精简了很多，但是问题是这里创建student的school_id的值是通过update语句更新进去的。因此这还不是一个最佳的sql语句。</p></li>
</ul>
<h3 id="父对象中使用onetomany子对象使用manytoone">父对象中使用<code>@OneToMany</code>，子对象使用<code>ManyToOne</code></h3>
<ul>
<li><p>示例</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class School &#123;
    @Id
    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)
    @GenericGenerator(name &#x3D; &quot;native&quot;, strategy &#x3D; &quot;native&quot;)
    @Column(name &#x3D; &quot;id&quot;, updatable &#x3D; false, nullable &#x3D; false)
    private long id;

    private String name;

    @OneToMany(
            mappedBy &#x3D; &quot;school&quot;,
            cascade &#x3D; CascadeType.ALL,
            orphanRemoval &#x3D; true
    )
    private Set&lt;Student&gt; students;

&#125;

public class Student &#123;

    @Id
    @GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE)
    private long id;

    private String name;

    @ManyToOne
    @JoinColumn(name &#x3D; &quot;school_id&quot;)
    private School school;

&#125;</code></pre></div></li>
<li><p>请注意，这里<code>@JoinColumn</code>在子对象中被使用，其注解的是一个父对象，但其作用还是相同的</p></li>
<li><p>这个结果是我们预期生成的，并没有额外的SQL产生。但是这里还存在的问题是在School中定义的OneToMany有导致内存泄漏的风险，因为我们没有办法控制它获取数据的数量，即使我们使用了懒加载，也有内存泄漏的问题。</p></li>
</ul>
<h3 id="子对象中使用manytoone">子对象中使用<code>@ManyToOne</code></h3>
<ul>
<li>这个就是一对多关系最完美的解决方案</li>
<li>可以实现的查询方式</li>
</ul>
<h3 id="使用manytoone和onetomany实现双向一对多关系">使用<code>@ManyToOne</code>和<code>@OneToMany</code>实现双向一对多关系</h3>
<blockquote>
<p>本质上是双向一对多的关系，并不能叫做多对多</p>
</blockquote>
<h3 id="使用manytomany实现多对多关系">使用<code>@ManyToMany</code>实现多对多关系</h3>
<ol type="1">
<li><code>@ManyToMany 注解用于关系的发出端和接收端</code></li>
<li><code>同时关系的发出端和接收端--定义一个集合类型的接收端的字段属性；</code></li>
<li><code>关系的接收端，@ManyToMany(mappedBy='集合类型发出端实体的字段名称')；</code></li>
</ol>
<p>由于<code>@JoinTable</code>和<code>@JoinColumn</code>一般定义在拥有关系的这一端，而<code>@mappedBy</code>一定是定义在关系的被拥有方（the owned side），也就是跟定义<code>@JoinTable</code>和<code>@JoinColumn</code>互斥的一方，它的值指向拥有方中关于被拥有方的字段，可能是一个对象（<code>@OneToMany</code>），也可能是一个对象集合（<code>@ManyToMany</code>）。</p>
<h2 id="一多对多关系中的级联管理">一/多对多关系中的级联管理</h2>
<blockquote>
<p>参考资料</p>
<p>https://wycode.cn/2018-04-19-many_to_many.html</p>
</blockquote>
<p>实际业务中，我们通常会遇到以下情况：</p>
<ol type="1">
<li>用户和用户的收货地址是一对多关系，当用户被删除时，这个用户的所有收货地址也应该<strong>一并删除</strong>。</li>
<li>订单和订单中的商品也是一对多关系，但订单被删除时，订单所关联的商品肯定<strong>不能被删除</strong>。</li>
</ol>
<p>此时只要配置正确的级联关系，就能达到想要的效果。</p>
<p>级联关系有</p>
<ul>
<li>CascadeType.REFRESH：级联刷新，当多个用户同时作操作一个实体，为了用户取到的数据是实时的，在用实体中的数据之前就可以调用一下refresh()方法</li>
<li>CascadeType.REMOVE：级联删除，当调用remove()方法删除Order实体时会先级联删除OrderItem的相关数据</li>
<li>CascadeType.MERGE：级联更新，当调用了Merge()方法，如果Order中的数据改变了会相应的更新OrderItem中的数据</li>
<li>CascadeType.ALL：包含以上所有级联属性</li>
<li>CascadeType.PERSIST：级联保存，当调用了Persist() 方法，会级联保存相应的数据</li>
</ul>
<h1 id="鉴权的实现">鉴权的实现</h1>
<h1 id="单元测试">单元测试</h1>
<h2 id="简单的单元测试">简单的单元测试</h2>
<h1 id="日志">日志</h1>
<h2 id="配置">配置</h2>
<ul>
<li><p>启动日志：通过在<code>pom.xml</code>中引入了Lombok，然后使用<code>@Slf4j</code>声明引入Slf4j的<code>log</code>日志记录对象，之后就可以轻松的用它来日志了。而这个日志具体是如何写到控制台或者文件的，则有Spring Boot项目中引入了什么具体的日志框架决定，默认情况下就是Logback</p></li>
<li><p>开启DEBUG日志：在配置文件<code>application.properties</code>中配置<code>debug=true</code></p>
<blockquote>
<p>这里开启的DEBUG日志，仅影响核心Logger，包含嵌入式容器、hibernate、spring等这些框架层面的会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别</p>
</blockquote></li>
<li><p>多彩输出：</p></li>
<li><p>通过在<code>application.properties</code>中设置<code>spring.output.ansi.enabled</code>参数来支持，该参数有三个选项：</p>
<ul>
<li>NEVER：禁用ANSI-colored输出</li>
<li>DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（默认项）</li>
<li>ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用</li>
</ul></li>
</ul>
<h1 id="部署">部署</h1>
<h2 id="启动springboot项目">启动Springboot项目</h2>
<h2 id="打包">打包</h2>
<h2 id="在服务器上润起来">在服务器上润起来</h2>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in Java 笔记</title>
    <url>/blog/posts/63900/</url>
    <content><![CDATA[<h2 id="初始化与清理">初始化与清理</h2>
<p>从概念上讲，“初始化”与“创建”是分离的，但是Java的构造器（构造方法）保证了“初始化”和“创建”捆绑在一起。</p>
<h3 id="构造器与方法重载">构造器与方法重载</h3>
<p>构造方法的重载是方法重载这一特性的典型场景。被重载的方法通过<strong>参数列表</strong>进行区分。</p>
<blockquote>
<p>为什么不使用返回值区分？</br> 在一些使用场景下，对方法的调用是一种“只希望得到函数副作用”的调用，此时并不接受函数的返回值（这与是否返回<code>void</code>无关，我们只是调用一个函数<code>func()</code>且不接受返回值），在这个情况下，编译器无法判断程序员在调用哪一个函数。</p>
</blockquote>
<p><code>this</code>关键字只能在方法内使用，它是<strong>使用这个方法的那个对象的引用</strong></p>
<blockquote>
<p>C中的<code>this</code>并不是引用而是一个指针，不过作用其实是相似的。<code>this</code>关键字再语义上等价于<code>*this</code>释放指针引用</p>
</blockquote>
<p>利用<code>this</code>关键字，我们可以在一个构造方法中调用另一个构造方法。比如，无参构造方法可以调用一个全参构造方法并进行默认的初始化。</p>
<p>与<code>this</code>相对，<code>ststic</code>关键字表明的就是没有<code>this</code>，也就是没有调用对象的方法，<code>static</code>方法直接通过类调用，可以访问<code>static</code>域，有些类似全局方法。</p>
<blockquote>
<p>其实这里可以考虑另一种对方法的描述。</p>
<p>在面向对象的概念下，方法的调用其实是向一个对象发送了一个消息，例如<code>demo.func()</code>应该理解为<code>Demo.func(demo)</code>。而<code>static</code>方法是不需要发送消息的，所以从原教旨主义（bushi的角度来看，<code>static</code>方法多少有些不OOP。</p>
</blockquote>
<h3 id="清理终结和垃圾回收">清理：终结和垃圾回收</h3>
<blockquote>
<p>一个对象的创建、初始化，使用，直到他被销毁、清理，其实就是安卓和Spring里进行的所谓对象的生命周期的管理。安卓给一个<code>Activity</code>类的实例规定<code>initState</code>等等方法，无非就是给一个类规定一些方法在相应的情况下被调用嘛，并在这些阶段做对象应该做的事情。</p>
</blockquote>
<p>Java的GC负责回收无用对象占据的内存区域，但是，GC无法释放那些特殊的内存（比如Java调用C代码使用<code>malloc()</code>函数开辟的内存空间）。因此Java为类提供了一个<code>finalize()</code>方法，他将在GC准备释放对象的内存空间时，首先被调用，并在下一次被调用时在真正回收对象的内存。</p>
<p>必须指出<code>finalize()</code>方法不是析构函数，Java里的对象并不总是被垃圾回收</p>
<ol type="1">
<li>对象可能不被垃圾回收</li>
<li>垃圾回收并不等驾驭“析构”</li>
<li>垃圾回收只与内存有关</li>
</ol>
<p>注意，<strong>使用GC的唯一目的就是为了回收程序不再使用的内存</strong></p>
<p>因此<code>finalize()</code>的使用总是很别扭的，但书中指出可以用于<strong>对象终结条件</strong>的验证。调用<code>finalize()</code>时一定要调用<code>super.finalize()</code>。</p>
<h3 id="gc的工作原理">GC的工作原理</h3>
<h4 id="引用计数">引用计数</h4>
<h4 id="停止-复制">停止-复制</h4>
<h4 id="标记-清扫">标记-清扫</h4>
<h4 id="即时编译器just-in-time-jit">即时编译器（Just-In-Time, JIT）</h4>
<h3 id="成员初始化">成员初始化</h3>
<h4 id="构造器初始化">构造器初始化</h4>
<p>默认初始化是无法阻止的，一定会在手动初始化之前先=执行；即使构造器中存在初始化的代码也一定会把所有数据成员先初始化成默认的值。</p>
<p>类的内部，变量定义的先后顺序决定了初始化的顺序；即使变量定义散布在方法各处，他们依旧会在哥任意方法（包括构造器）被调用钱得到初始化。</p>
<p>静态初始化只有在必要的时候才会进行。</p>
<p>从总体上看，对象的初始化过程为：</p>
<ol type="1">
<li>首次创建类的对象或访问类的静态区域时（构造方法也是静态方法），Java解释器将定位<code>Demo.class</code>文件</li>
<li>载入<code>Demo.class</code>文件，创建<code>Class</code>对象，进行静态初始化</li>
<li>使用<code>new</code>关键字时，在堆上分配足够的空间</li>
<li>空间清0，所有基本数据类置为了<code>0</code>，引用置为了<code>null</code></li>
<li>执行字段定义处（可能分散在各个方法处）的初始化动作</li>
<li>执行构造器</li>
</ol>
<h4 id="显式的静态初始化">显式的静态初始化</h4>
<p>域内使用<code>static</code>关键字声明的语句将跟其他静态初始化动作一样，只执行一次。</p>
<h4 id="非静态实例初始化">非静态实例初始化</h4>
<p>实例初始化子句是在两个构造器之间进行的，这个语法对于支持匿名内部类是必要的。</p>
<h4 id="数组初始化">数组初始化</h4>
<p>所有数组都包含一个<code>length</code>成员。</p>
<h2 id="数据和引用">数据和引用</h2>
<h3 id="static和final关键字">static和final关键字</h3>
<ul>
<li><code>static</code>强调只有一份</li>
<li><code>final</code>强调是一个常量</li>
</ul>
<p>具体来讲，对于一个数据，或者说域</p>
<h4 id="数据域">数据（域）</h4>
<p>一个又<code>final</code>又<code>static</code>的域是内存上不变的连续区域。</p>
<p><code>final</code>修饰基本数据类型时，数据的值不改变；修饰引用时，值也是不改变，但引用的值不改变其实就是不可以改变引用指向的对象。</p>
<h4 id="方法">方法</h4>
<p><code>final</code>方法主要用于方法锁定，禁止继承类修改这个方法的定义。</p>
<p><code>private</code>关键字在这个角度上与<code>final</code>有相同的效果，二者可以并存，但没什么意义。</p>
<blockquote>
<p>开发项目时，除了设计好用于继承的基类，将所有方法都先声明为<code>final</code>是一个好习惯。</p>
</blockquote>
<h4 id="类">类</h4>
<p><code>final</code>类禁止被继承，且所有方法都被隐式指定为<code>final</code>的。</p>
<h2 id="类的复用">类的复用</h2>
<blockquote>
<p>对应原书第七章</p>
</blockquote>
<p>类的复用主要有两种方式，组合和继承</p>
<p>一条通用的准则：“<strong>用继承表示行为间的差异，用字段表示状态上的变化</strong>”。</p>
<h3 id="组合">组合</h3>
<p>组合是一种更自由的方式。他不会继承接口，不会有转型的问题，被组合的类以对象（字段）的形式存在于调用类内部，因此调用类需要编写一系列方法去调用被组合类。</p>
<p>组合适合添加某个类的功能，利用它实现某个功能，而不是暴露他的所有接口。</p>
<h3 id="继承">继承</h3>
<p>继承会自动得到基类的所有域和方法。</p>
<blockquote>
<p>要访问基类的域，必须使用<code>super</code>关键字访问。</p>
</blockquote>
<p>继承方式得到的类，其构建过程是从基类“向外”扩散的所以基类在导出类的构造方法调用前就已经完成了构造；当然，导出类构造时将会先装在导出类的构造方法，再通过显式的<code>super()</code>调用基类构造方法（或隐式调用基类的无参构造方法）。</p>
<p>为了解决继承时错误的override，Java引入了<code>@Override</code>注解，该注解能够提示编译器检查是否override成功。</p>
<p>继承往往用于构造基类的一个特殊版本。</p>
<blockquote>
<p>要判断是否使用继承，可以考虑这个类需不需要向上转型，如果不需要就不使用继承。</p>
</blockquote>
<p>通常，实体类应避免使用继承的方式构造。</p>
<h3 id="代理">代理</h3>
<p>代理是一种折中的方法，他将一个成员对象置于所要构造的类中（类似组合），与此同时，在类中暴露了该成员对象的所有方法（类似继承）</p>
<h2 id="多态和类型信息">多态和类型信息</h2>
<blockquote>
<p>对应原书第八章和第十四章</p>
</blockquote>
<p>继承会带来类与类之间的耦合，而多态就是用来消除这种耦合关系的。</p>
<p>Java中，除了<code>static</code>和<code>final</code>方法，所有的方法都是后期绑定的。</p>
<blockquote>
<p>C++就不同，我们使用<code>virtual</code>关键字使得一个方法可以被后期绑定，也就是赋予其多态性。</p>
</blockquote>
<p>即使引用并不知道对象的具体类型也可以正常工作。引用只是向对象发送一条信息，发送的前提是对象有这个接口（显然继承保证了导出类具有基类的所有这些接口），至于如何执行全部交给对象，因此对象总是可以执行其自身定义的正确的方法。</p>
<p>由于任何域访问操作都将由编译器解析，因此不是多态的。当访问基类的域时，就必须要使用<code>super</code>引用。</p>
<h3 id="协变返回类型">协变返回类型</h3>
<p>自Java SE5开始，重写方法可以返回原方法返回值类型的导出类型。</p>
<h3 id="rtti">RTTI</h3>
<p>Java会对所有向下转型进行类型检查，存在错误就会抛出<code>ClassCastException</code>异常。</p>
<p>这种运行期间检查类型的机制被称为运行时类型识别（RTTI）。</p>
<h2 id="接口抽象方法和内部类">接口、抽象方法和内部类</h2>
<div class="note note-success">
            <p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。</p>
          </div>
<blockquote>
<p>原书第九、十章</p>
</blockquote>
<h3 id="抽象类和抽象方法">抽象类和抽象方法</h3>
<p>很多时候一个基类中的方法有许多无效方法，他们只用于为导出类提供一个接口；如果导出类对象向上转型后调用这个方法，得到的是没有意义的结果。</p>
<p>Java为这种情况下的方法提供了<code>abstract</code>关键字，这个关键字允许创建一个只有签名、没有实现的方法，这种方法就是<strong>抽象方法</strong>。抽象方法就是一个单纯的接口了，他的实现必须由基类实现。因此，一个继承自抽象方法的类，必须对所有抽象方法实现；否则的话，这个导出类也会被处理为抽象类，同时编译器强制要求加上<code>abstract</code>关键字。</p>
<p>因此，包含抽象方法的类不能被实例化，因为这些抽象方法没有方法体，我们自然的将含有抽象方法的类称为<strong>抽象类</strong>。抽象类不可以被实例化。</p>
<p>抽象方法和抽象类主要有两个作用</p>
<ol type="1">
<li>明确抽象性，告诉编译器需要做的工作。</li>
<li>有利于重构，将公共方法沿着继承层次向上移动。</li>
</ol>
<h3 id="接口">接口</h3>
<p>接口是一种完全抽象的类，不包含任何实现。他为类与类之间的通信建立了一个协议，因此有些语言使用<code>protocol</code>关键字实现这个功能。接口也可以包含域，这些域隐式地<code>static</code>和<code>final</code>。</p>
<p>接口可以实现完全解藕。如果一个方法使用类声明，他就只能接受这个类及其子类；但接口可以几乎完全忽视这种限制。</p>
<h3 id="内部类">内部类</h3>
<h2 id="对象容器">对象容器</h2>
<p>Java的容器类有两个概念，单列集合<code>Collection</code>和双列集合<code>Map</code>；其中<code>Collection</code>又有三个拓展<code>List</code>、<code>Set</code>和<code>Queue</code>；因此共有四个基本的容器接口，每个接口提供了一些实现。</p>
<p>在使用容器类时，有必要向具体容器传入类型参数（也就是将使用范型设计的类实例化），这样</p>
<ol type="1">
<li>编译器可以提供编译阶段的类型检验</li>
<li>从容器中取出的对象将直接拥有类型，而不需要向下转型</li>
</ol>
<p>理想情况下，<strong>应该使用<code>list</code>等四个接口进行容器的操作</strong>，除非需要使用具体实现类的特殊方法。</p>
<blockquote>
<p>对于<code>Collection</code>的实现类，尽管可以在构造时传入参数，但先创建一个空对象，再使用<code>Collection.addAll()</code>方法要快得多。</p>
</blockquote>
<p>对于有查询速度要求的情况，使用<code>HashSet</code>、<code>HashMap</code>等基于散列函数的类是最优解；要维护插入顺序或结构的话，就要考虑<code>TreeSet</code>等类。</p>
<h3 id="list列表"><code>List</code>列表</h3>
<p>通常，可以使用<code>Arrays.asList()</code>方法由数组创建一个集合，但该方法创建的元素类型是所有元素的“最小公倍数”，有时并不是我们期望的类型；针对这种情况，可以使用显式类型参数说明<code>Arrays.&lt;Type&gt;asList()</code>。</p>
<p><code>List</code>有两个主要的实现</p>
<ul>
<li><code>ArrayList</code>，底层是动态数组</li>
<li><code>LinkedList</code>，底层是链表</li>
</ul>
<figure>
<img src="https://img-blog.csdn.net/20160413184734236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="List" /><figcaption aria-hidden="true">List</figcaption>
</figure>
<p>从这个继承图<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="java集合框架05——ArrayList和LinkedList的区别 武哥聊编程 CSDN
">[6]</span></a></sup>可以看出</p>
<ul>
<li><code>List</code>接口共有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code>和<code>Stack</code>四个实现，后两者已经被弃用。</li>
<li><code>AbstractList</code> 是一个抽象类，它继承与 <code>AbstractCollection</code> <code>。AbstractList</code> 实现了 <code>List</code> 接口中除了 <code>size()</code>、<code>get(int location)</code>之外的方法。</li>
<li><code>AbstractSequentialList</code>是一个抽象类，它继承与<code>AbstrctList</code>。<code>AbstractSequentialList</code>实现了“链表中，根据index索引值操作链表的全部方法”。</li>
</ul>
<p><code>List</code>接口定义了一个<code>subList()</code>与<code>String</code>的<code>subString()</code>方法不同，他返回的只是一个原列表的引用，因此其修改会直接影响到原<code>List</code>；要避免这个副作用，可以嵌套一层<code>List</code>作为引用的引用，这样操作的就不是原数据。</p>
<h3 id="set集合"><code>Set</code>集合</h3>
<p><code>Set</code>完全继承并实现了<code>Collection</code>接口的内容，实际上二者就是一回事儿，只是行为不同。</p>
<h3 id="queue队列"><code>Queue</code>队列</h3>
<p>队列是一种能够可靠的将对象从程序的一个区域传输到另一个区域的途径。</p>
<blockquote>
<p>比如用在并发编程。</p>
</blockquote>
<h3 id="map双列集合"><code>Map</code>双列集合</h3>
<p>并不知道有什么特别要说的。。或许，<code>Map</code>可以生成 key 或 value 的<code>Collection</code>？</p>
<h3 id="iterator迭代器">Iterator迭代器</h3>
<p>迭代器是一个轻量的对象。它的作用是遍历并选择序列中的对象，且不需要知道序列的具体实现。</p>
<p>这个概念很奇怪，其实迭代器是一种实现和操作分离的方式。例如</p>
<ol type="1">
<li>使用<code>hasNext()</code>和<code>next()</code>方法进行迭代，这种方式无需使用<code>for</code>或<code>foreach</code>语句和序列长度即可进行遍历；解决了序列长度不可知的问题。</li>
<li><code>remove()</code>方法替代了使用引用指向要被删除的元素，并且对于一些结构（如链表），隐藏了重新连接序列的过程，使得基于动态数组或链表的数据结构得到了统一的实现。</li>
</ol>
<p>因此，迭代器能够将遍历序列的操作与序列底层的结构分离。</p>
<blockquote>
<p>迭代器统一了对容器的访问方式。</p>
</blockquote>
<p>在 Java 中，实现<code>Collection</code>接口就意味着提供<code>iteartor()</code>方法，二者似乎被绑定了。实际上对于一个已有的类，要让它实现<code>Collection</code>接口需要实现较多方法，这并不方便，因此，在这种情况下，继承这个类并提供创建迭代器的能力要更加合适。</p>
<h3 id="iterable接口"><code>Iterable</code>接口</h3>
<p>这个接口提供<code>iterator()</code>方法，它用于产生一个<code>Iterator</code>。</p>
<h2 id="异常处理机制">异常处理机制</h2>
<h3 id="异常的创建与捕获">异常的创建与捕获</h3>
<p>对于 Java 的异常处理机制而言，异常也是一个对象，因此异常的产生大致有这三个阶段</p>
<ol type="1">
<li>使用<code>new</code>在堆上创建异常对象。</li>
<li>从当前环境弹出异常对象的引用。</li>
<li>寻找一个合适的地方接管程序，这个地方就是异常处理程序。</li>
</ol>
<p>理论上，异常处理理论有两种模型：终止模型和恢复模型。终止模型是 C++ 和 Java 采用的设计。</p>
<blockquote>
<p>现在也有一些人认为异常的意义不大。他们指出很多程序错误的情况，并不是通过异常处理机制就能解决的，例如用户的错误交互，文件、网络流的错误。</p>
</blockquote>
<h3 id="finally子句的使用"><code>finally</code>子句的使用</h3>
<p><code>finally</code>与析构函数要解决的问题不同，理论上，我们应该使用它保证程序在结束 try 块后处于正确的状态。例如，文件应该是被关闭的，TDP 连接断开，物理设备连接断开等等。</p>
<h3 id="继承与异常">继承与异常</h3>
<p>当 override 方法时，只能抛出基类方法的异常说明里列出的异常，或者这些异常的派生异常。</p>
<p>上面提到的异常限制对构造方法是无效的；但由于积累构造器必定被直接或间接的调用，因此派生类的构造方法还是要包含积累构造方法的异常说明才行。</p>
<h3 id="捕获构造时的异常">捕获构造时的异常</h3>
<p>一些异常会发生在对象的构造阶段，比如执行建立网络连接、打开文件等。在这种情况下，一个 try-catch 语句很难有效的捕获这种异常。</p>
<p>基于一个基本原则：在创建需要清理的对象后，立即进入一个 try-finally 语句块。</p>
<p>真正写起来的话，大概是这个样子</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;
  Object o &#x3D; new Object();
  try &#123;
    &#x2F;&#x2F; do something
  &#125; catch(Exception e) &#123;
    &#x2F;&#x2F; 正常的异常处理
  &#125; finally &#123;
    &#x2F;&#x2F; 执行类似dispose()的方法收尾
  &#125;
&#125; catch(Exception e) &#123;
  &#x2F;&#x2F; 处理对象构造时出现的异常
&#125;</code></pre></div>
<h3 id="异常的使用场景">异常的使用场景</h3>
<p>书中将异常使用分为这几个主要的类别（有所整理）</p>
<ol type="1">
<li>知道如何处理潜在的异常</li>
<li>解决问题后重新调用原方法</li>
<li>调整后，绕过抛出异常的部分或用代替的方法执行</li>
<li>尽量做完剩下的事情，向上层跑出异常</li>
<li>及时终止程序并回收资源</li>
</ol>
<h2 id="范型">范型</h2>
<h2 id="多线程与并发">多线程与并发</h2>
<p>计算机程序不论做什么事情，归根到底可以分类为“<strong>计算任务</strong>”和“<strong>读写任务</strong>”。两者使用的是计算机上的不同的资源，CPU是计算资源，硬盘、网络是读写资源。多个计算任务之间可能有顺序依赖也可能没有，把<em>彼此之间没有顺序依赖的<strong>计算任务</strong>同时进行以缩短处理时间的做法叫做“<strong>并发（concurrency）</strong>”</em>；当计算任务对读写任务有依赖时，<em>不把计算资源浪费在对<strong>读写任务</strong>的等待上的做法叫做“<strong>异步（asynchronous）</strong>”</em>。并发和异步都是单一线程无法实现的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="多线程是否有意义？ - chris sun的回答 - 知乎
">[2]</span></a></sup>。</p>
<p>一般，CPU密集型使用多进程，IP密集型使用多线程即可<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="关于多线程和多进程 - 飞鸟梦想的文章 - 知乎
">[5]</span></a></sup>。</p>
<h3 id="多进程和多线程">多进程和多线程</h3>
<blockquote>
<p>多线程是一个适用面极窄、效果一般的、向现实妥协的设计；它的出现和火爆都只是一种偶然、且推广乏力<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决？ - invalid s的回答 - 知乎
">[3]</span></a></sup>。</p>
</blockquote>
<p>总的来讲，共识是多线程比多进程成本低，但性能更低<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="多进程跟多线程如何取舍，在不同系统，不同场景下？ - 崔学彬的回答 - 知乎
">[4]</span></a></sup>；而且由于系统差异在Linux下编程多用多进程编程少用多线程编程<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="多进程跟多线程如何取舍，在不同系统，不同场景下？ - 崔学彬的回答 - 知乎
">[4]</span></a></sup>。</p>
<h4 id="协程">协程</h4>
<p>协程(coruntine)，又称微线程是近几年兴起的技术。是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调用切换时，将寄存器上下文和栈保存到其他地方，再切回来的时候，恢复先前保存的寄存器上下文和栈， 直接操作栈则没有内核切换的开销，可以不加锁的访问全局的变量，所以上下文切换非常快<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="关于多线程和多进程 - 飞鸟梦想的文章 - 知乎
">[5]</span></a></sup>。</p>
<h2 id="参考材料">参考材料</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span>Thinking in Java <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span><a href="https://www.zhihu.com/question/25371167/answer/117658801">多线程是否有意义？ - chris sun的回答 - 知乎</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span><a href="https://www.zhihu.com/question/25390536/answer/2510944114">并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决？ - invalid s的回答 - 知乎</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span><a href="https://www.zhihu.com/question/48153562/answer/109506150">多进程跟多线程如何取舍，在不同系统，不同场景下？ - 崔学彬的回答 - 知乎</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:5" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/125761836">关于多线程和多进程 - 飞鸟梦想的文章 - 知乎</a> <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:6" class="footnote-text"><span><a href="http://t.csdn.cn/c1L4E">java集合框架05——ArrayList和LinkedList的区别 武哥聊编程 CSDN</a> <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Web API设计方法</title>
    <url>/blog/posts/38977/</url>
    <content><![CDATA[<h2 id="api的基本形式">API的基本形式</h2>
<h3 id="http方法">HTTP方法</h3>
<h3 id="参数设计">参数设计</h3>
<h3 id="资源命名风格">资源命名风格</h3>
<h3 id="鉴权">鉴权</h3>
<h2 id="数据格式设计">数据格式设计</h2>
<h3 id="数据的封装与层级">数据的封装与层级</h3>
<h3 id="数据格式">数据格式</h3>
<h3 id="错误信息的处理">错误信息的处理</h3>
<h2 id="关于http协议">关于HTTP协议</h2>
<h3 id="状态码">状态码</h3>
<h3 id="缓存">缓存</h3>
<h3 id="媒体类型">媒体类型</h3>
<h3 id="同源策略与跨域请求">同源策略与跨域请求</h3>
<h2 id="开放api的优化">开放API的优化</h2>
<h3 id="面向不同服务的api">面向不同服务的API</h3>
<h3 id="版本信息">版本信息</h3>
<h3 id="https加密等安全策略">HTTPS加密等安全策略</h3>
<h3 id="浏览器端的小问题">浏览器端的小问题</h3>
<h3 id="如何应对大规模访问">如何应对大规模访问</h3>
<h2 id="公开api">公开API</h2>
<h3 id="api文档">API文档</h3>
<h3 id="沙盒api">沙盒API</h3>
<h3 id="api-console">API Console</h3>
<h3 id="sdk">SDK</h3>
<h2 id="参考">参考</h2>
<div id="referer-anchor-1">

</div>
<ul>
<li>[1] 水野贵明.Web API的设计与开发（Web API: The Good Parts）[M]北京：人民邮电出版社，2017</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
        <tag>API</tag>
        <tag>Golang</tag>
        <tag>RESTful API</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows蓝屏集锦</title>
    <url>/blog/posts/6db1da4e/</url>
    <content><![CDATA[<h2 id="x000000c2bad_pool_caller">0x000000C2：BAD_POOL_CALLER</h2>
<h3 id="官方解释">官方解释</h3>
<p>0x000000C2错误表示内核程序或硬件设备的驱动程序试图进行<strong>错误的内存操作</strong>。这个错误一般是因为<strong>应用软件或硬件设备驱动程序</strong>存在BUG引起的。 如果遇到0x000000C2错误，建议首先检查一下最近有没有安装新的应用软件或硬件设备驱动程序。如果有的话，请将最近安装过的应用软件或驱动程序逐一卸载，看看问题能否解决；其次请使用“替换法”检测计算机的内存及主板是否工作正常。</p>
<h3 id="错误原因">错误原因</h3>
<p>0x000000C2 错误发生在 Ntoskrnl.exe 文件中。在计算机启动时或在计算机运行正常时，可能会出现此问题。如果<strong>AppCompat高速缓存尝试释放具有空文件名的缓存项</strong>，则可能会出现此问题。</p>
<h3 id="处理">处理</h3>
<p>使用DiskGenius&gt;检测和修复硬盘坏道,</p>
<p>用橡皮擦擦内存条和显卡的金手指,再装回去</p>
<p>开机按F8---选择---“使用"最后一次正确的配置",</p>
<p>使用驱动精灵(驱动人生),会自动帮你更新适合的驱动程序.</p>
<p>电脑过热蓝屏,散热器和风扇彻底除尘,完全冷却后再开机,不成就换散热器+风扇.</p>
<p>全盘杀毒,然后系统还原或备份恢复系统.如做不到,可用原版镜像安装版修复安装或彻底重装.</p>
<h2 id="x000000d1driver_irql_not_less_or_equal">0x000000D1：DRIVER_IRQL_NOT_LESS_OR_EQUAL</h2>
<h3 id="官方解释-1">官方解释</h3>
<p>0x000000D1错误表示硬件设备的驱动程序遇到了问题。这个错误一般是因为硬件设备驱动程序存在BUG或安装不正确引起的。</p>
<h3 id="错误原因-1">错误原因</h3>
<p>如果遇到0x000000D1错误，建议检查一下完整的蓝屏故障提示，看看有没有提到引起错误的具体是哪个文件，如果在蓝屏故障提示中看到某驱动程序的文件名，则表示相应的驱动程序存在BUG或安装不正确。例如，假设引起0x000000D1蓝屏故障的文件名为NV4.SYS，则可能是nVIDIA Geforce显卡驱动程序引起的问题；假设引起0x000000D1蓝屏故障的文件名为ACPI.SYS，则可能是ACPI高级电源选项驱动程序引起的问题，等等。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwldupv6gtj31400u0789.jpg" alt="QQ20211120-0" /><figcaption aria-hidden="true">QQ20211120-0</figcaption>
</figure>
<h3 id="处理-1">处理</h3>
<ol type="1">
<li>上图可以发现出问题的是NETIO.SYS文件</li>
<li>检索后发现以下文章 https://answers.microsoft.com/zh-hant/windows/forum/all/windows-10/0f2b2c28-8849-4bc4-845c-26af40385b64 https://www.exefiles.com/zh-tw/sys/netio-sys/</li>
<li>可以发现该文件与Access、Trillian、WIndows10打包在一起，笔者有理由怀疑这与前两者的安装有关。</li>
<li>基于上述推测，笔者建议重新安装应用程序，或尝试在一台正常工作的Windows10系统下复制一份该文件进行覆盖</li>
</ol>
<blockquote>
<p>https://support.microsoft.com/zh-cn/topic/易宝典-windows常见蓝屏故障分析-mvp-撰稿-2412352e-18a0-35c3-860c-ca2acc6dbca0</p>
</blockquote>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/blog/posts/0/</url>
    <content><![CDATA[<h1 id="hello">Hello</h1>
]]></content>
  </entry>
  <entry>
    <title>《圆圈正义》读书笔记</title>
    <url>/blog/posts/42904/</url>
    <content><![CDATA[<p>罗翔老师在《圆圈正义》一书中分享了诸多对于人生、社会和法治的思考。与互联网上所刊登的视频相比，通过文字笔者得以细致品味罗翔老师的思想，并从中得到诸多收获和启发，尤其是对于人生、人性等问题的讨论。本文主要以书中圆圈正义、何为榜样与生命的尊严为据三章，分享我（下称“笔者”）的一些理解和思考。</p>
<h2 id="导言">导言</h2>
<p>罗翔老师是一位理论基础扎实、对法学有独到见解的法学家，是一位思想成熟的优秀教师。罗翔在书中指出他最喜欢的燕园校训——因真理、得自由、以服务，罗翔对其内涵的解读，与其在书中对人生、信仰的讨论相辅相成。笔者读罢深受启发，在此对书中内容进行一些分析和思考。</p>
<h2 id="何为真理">何为真理</h2>
<h3 id="哲学意义上的真理">哲学意义上的真理</h3>
<p>《圆圈正义》中多处对“真理”这一概念进行解释和探讨，笔者以为真理即是所指”圆圈“。所谓真理，在大众主管印象中应是一个极其崇高完美的概念，人们希望真理能解释所有自然现象、社会关系与主观意识，但这种认识仍然是较为模糊的。</p>
<p>初读《圆圈正义》中对真理的讨论时，笔者首先对此感到疑惑，疑惑为何要探讨似乎人尽皆知的“真理”。正如前文所讲，真理应是一个人尽皆知的词语，但事实是包括笔者在内的多数人只知其表不知其本。罗翔指出，真理本是一种观念。由于哲学家们认为观念有高低之分，因此将最为接近永恒、最为崇高的观念称为“真理”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Hellosda
">[1]</span></a></sup>。由此可见，客观上真理是人类加在自身的一层束缚，是一种主观认知构成的虚拟概念。但从长久的发展来看，正是因为这个阶段人们认为有最极致最永恒的存在，人类可以生活得有意义、有目的、有安全感。</p>
<p>不久后启蒙时代的到来戳破了这场追求永恒的梦，带领人们重新以理性去思考观念和人本身的关系，发现真理可能是相对的和主观的，一切观念都是由人创造，因为人的有限和不足，所以人们创造了无限和自由的概念[^2]。</p>
<h3 id="人生与真理">人生与真理</h3>
<p>读罢全书，笔者以为广义上的“因真理”百利而无一害，对真理的追求应当称为笔者的信念和人生价值之一。</p>
<p>此处所指真理，应当主要是永恒的知识和思维。真理所强调的一个关键点在于永恒，笔者以为知识与思维皆是永恒存在，且具有引导作用的。前者虽时常被推翻，但所推翻的并非知识本身，只是我们所发现理解的冰山一角，而在对其本质的思考和探索中，我们难免会对现有知识进行补充甚至推翻。这恰恰意味着真理远离自大和自傲，这是因为相信永恒的存在，能够带给学者敢于否定自己和他人的勇气和底气。至于后者，笔者一直以为人应当长思考、多思考。《致法学新人的第三封信》中，罗翔对“谨慎”一词进行了解释，慎是心字旁，经慎重思考的才会是你真实意思的表示，所以慎子的组合，是“真心”[^4]。</p>
<p>上文所提两点，是笔者对真理的一些浅薄理解，恰如《圆圈正义》中所说，唯有真理的光照，才能学会谦卑，走出自我的偏狭，从而自由不放纵，独立而不狂狷，尽责而不懈怠[^5]。</p>
<h2 id="自由与责任">自由与责任</h2>
<h3 id="自由的界定">自由的界定</h3>
<p>从《圆圈正义》来看，法律意义上自由与世俗意义上的自由并无太大区别。我们常常探讨思想是否自由，人的行为是否自由，国家是否自由，等等，由此可见自由所指很多，笔者认为自由可大致分为两类————思想的自由和身体的自由。</p>
<p>在笔者看来，诸如思想自由、言论自由都是思想的自由，这类自由很难由法律进行限制，或者说他们就是人性道德的反映。罗尔斯认为，所有公民应当享有平等的基本自由[^6]，自由应当是每个人生来就有的基本权利。但是这些自由仍有他们的边界，以表达自由为例，表达自由是思想自由的合理延伸，但思想自由是绝对自由的，言论等表达自由则是相对的[^8]。这是因为思想往往会向行动延伸，一旦一些思想落实成行动，或许就会带来反人类、反社会的后果，因此社会对这样的一些自由进行了限制。</p>
<p>至于另一种自由，其典型便是人身自由，这些自由是人作为生物的基本权利。在一种相对简单的观念看来，世间万物都应当享有一定程度的自由，这些自由应当保证生命能够存活、繁衍后代。对这种自由的限制，往往是剥夺他人同类自由的限制，那便是刑法中所列的种种人类社会的最底线，而与其对应的惩戒方式，也是限制其同类自由。</p>
<h3 id="为何限制自由">为何限制自由</h3>
<p>在笔者人生的前二十年，不止一次听闻有限的自由才是真正的自由，事实上，笔者至今仍对其内涵一知半解。一方面，笔者知道可为与不可为之事，另一方面，笔者时常思考自由的边界究竟在何处。</p>
<p>罗翔认为真正的自由是做正确事情的自由，人生最大的奴役就是无法实现“知道”和“做到”之间的跨越。笔者对人生之奴役这点十分赞同。</p>
<p>自懂事起，笔者常常因为“行动”与“想法”的矛盾而纠结困苦，也就是互联网上所说的“懒癌”，当我们严肃的去看待它时，会发现“懒癌”其实是一个非常痛苦的症状。它所带来的不仅是事情未能完成的挫败感和自责，往往还会带来对生命白白消逝的遗憾，有些人甚至会深陷其中无法自拔。对于另外一些人，或许他们可以坦然接受心中的幽暗，但这与被感官带来的快感要挟并无差异，正如前文所论述的，笔者以为缺少思考的人生或许单纯快乐，但一定是痛苦而不自由的。若一人思考停止，思想停滞，这样按下暂停键的人生何谈自由。或许，这种奴役也可算是自由的一个边界罢。</p>
<h2 id="服务人生">服务人生</h2>
<p>自由的目的是责任，一个越自由的人越懂得去服务大众，去成全他人的幸福[^9]。</p>
<p>至此，笔者希望暂时放下“写论文”的态度，用较为主观的方式来分享。</p>
<p>此处在此引用书中该章的一段，“一位北大学妹有一段话写得很好，她说她从小就生活在北京，拥有很多人这一生都无法拥有的东西，因此她只能前行”[^10]。《圆圈正义》一书，除却对法治的探讨，笔者对这两段文字感受最为深刻。或许是因为上海疫情，又或许是因为一年前的高考，引用的这句话很大程度上表达了笔者最近的一些感触。</p>
<p>首先，在这里“自由”可以阐释为一些更具体的范围，比如时间的自由，金钱的自由和成长的自由。笔者依稀记得2020年的春天，演讲《后浪》引发的激烈讨论，那时笔者羡慕拥有选择权利的后浪们，心想，他们是如此自由。</p>
<p>但笔者不知何时意识到，自己已经享有了很大程度的自由。笔者家庭关系和睦，学业至少也算顺利，尽管同龄人之前仍常常抱怨，但笔者深知自己在整个社会所处的位置。举个简单的例子，笔者享有一些知识，也会有向他人分享的欲望，笔者以为，这种分享欲或许便是“责任”的一种体现。</p>
<p>对于笔者来讲，责任是充满快乐和幸福的。或许责任是一种被依赖，因此能够带来一种虚荣感，但笔者认为这是一种精神上的高贵，一切责任都是我们与他人的联系，这种联系确实会带来压力和负担，但这就是笔者一直认为玄之又玄的人生价值的一种体现。</p>
<h2 id="结语">结语</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span>Hellosda <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>一些项目or框架的介绍和文档索引</title>
    <url>/blog/posts/34400/</url>
    <content><![CDATA[<h2 id="内容比较丰富的站点">内容比较丰富的站点</h2>
<ul>
<li><a href="https://csdiy.wiki">CS自学指南</a>: 来自燕园前辈的宝贵资料，一系列国外教程，非常值得静下心慢慢看，大部分可以在B站找到带字幕资源</li>
<li><a href="https://www.yijiyong.com/java/intro/01-java-intro.html">智能后端和架构</a>: Java和Spring生态的内容，以及数据库和大数据，算法和人工智能，还有框架和架构的一些解析</li>
<li><a href="https://www.runoob.com">菜鸟</a>: 不必多说</li>
<li><a href="https://www.liaoxuefeng.com">廖雪峰</a>: 主要还是Java语言、数据库和javascript，比较适合入门看</li>
<li><a href="https://edu.aliyun.com/course/explore/codelanguage">阿里云</a>: 资料蛮多的</li>
<li><a href="https://developer.huawei.com/consumer/cn/training/">华为开发者</a></li>
<li><a href="http://www.cyc2018.xyz/#java">CS-Notes</a>: 一份比经典的开源教程仓库，感觉挺好</li>
<li><a href="https://www.w3school.com.cn/index.html">W3school</a>: 涵盖了网站技术的方方面面，包括W3C标准技术：HTML、CSS、XML，以及其他技术，诸如 JavaScript、PHP、SQL 等。</li>
</ul>
<h2 id="语言">语言</h2>
<p><a href="https://www.sololearn.com/learning">SoloLearning</a>：交互式的编程语言教学网站，现在提供了Python、C/C++、JavaSE和JavaScript等语言的资料。提供交互式的教学和练习，非常适合快速上手。</p>
<h3 id="java">Java</h3>
<ul>
<li><a href="https://dunwu.github.io/java-tutorial/">JAVA-Tutorial</a>: 是一个 Java 教程，汇集一个老司机在 Java 领域的十年积累</li>
<li><a href="https://how2j.cn">HOW2J</a>: 讲的内容比较少，可以查缺补漏</li>
<li><a href="https://www.oracle.com/technetwork/topics/newtojava/gettingstarted-jsp-138588-zhs.html">Oracle</a>: Oracle官方的指南，一言难尽</li>
</ul>
<h3 id="cc">C/C++</h3>
<ul>
<li><a href="https://wangdoc.com/clang/">WangDoc</a></li>
<li><a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">现代C++教程：快速上手C++11/14/17/20</a></li>
<li><a href="https://github.com/Cpp-Club/Cxx_HOPL4_zh">在拥挤和变化的世界中茁壮成长：C++ 2006–2020</a>: Bjarne 在这篇论文中记录了C++从C++11、14、17到C++20的整个历史，被官方称为现代C++白皮书，对C++从业者具有绝对指导性的重要意义，而这篇论文的内容确实让人读起来流连忘返</li>
<li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/?view=msvc-170">微软C++语言文档</a></li>
<li><a href="https://github.com/rachitiitr/modern-cpp-tricks">Modern Cpp Tricks</a>: 微软前工程师Rachit Jain在GitHub上开源的一份C++知识库，里面整理了一些C++相关的开发技巧。</li>
</ul>
<h3 id="javascripttypescript">JavaScript/TypeScript</h3>
<ul>
<li><a href="https://wangdoc.com/javascript/">阮一峰javascript教程</a>: 比较全面实用的教程</li>
<li><a href="https://es6.ruanyifeng.com">ES6标准入门</a>: 阮一峰老师的经典，需要有基础</li>
<li><a href="https://zh.javascript.info">JAVASCRIPT.info</a>: Javascript.info 依托 learn.javascript.ru 而来，是俄罗斯最大的 JavaScript 教程和学习平台之</li>
</ul>
<h3 id="go">Go</h3>
<h3 id="rust">Rust</h3>
<ul>
<li><a href="https://zh.practice.rs/why-exercise.html">Rust语言实战</a></li>
</ul>
<h3 id="python">Python</h3>
<ul>
<li><a href="https://inventwithpython.com/bigbookpython/">The Big Book of Small Python Projects</a>书中收录了80多个Python项目，每个项目都是一个独立章节，其中包括项目实例、源码、进一步开发建议等内容。这本书还有配套的<a href="https://nostarch.com/download/BigBookPythonResources.zip">资源</a>和<a href="https://inventwithpython.com/bigbookpython/diff">代码比较工具</a></li>
<li><a href="https://mofanpy.com">莫烦Python</a>: 一个为科研人员设计的Python教程。</li>
<li><a href="https://superfastpython.com/multiprocessing-in-python/">Multiprocessing in Python: The Complete Guide</a>: Python 中的多进程机制：完整指南。</li>
</ul>
<h2 id="后端框架">后端框架</h2>
<h3 id="spring-boot">Spring Boot</h3>
<ul>
<li><a href="http://springboot.javaboy.org">江南一点雨</a>: 江南一点雨整理的Spring Boot教程合集，涉及到内容比较全面</li>
<li><a href="https://spring.io/projects/spring-boot">SpringBoot官方</a>: Spring官方资料，有一些快速上手的tutorial，而且不难理解</li>
<li><a href="https://www.springcloud.cc/spring-boot.html">官方指南翻译</a>: 官方文档的翻译，有点久远</li>
<li><a href="https://www.springboot.wiki">教程汇总</a>: 这个网站收集了很多资源</li>
<li><a href="http://www.ityouknow.com/spring-boot.html">纯洁的微笑</a>: 有时间可以慢慢看的样子，研究的比较深入</li>
<li><a href="https://www.yijiyong.com/spring/basic/01-intro.html">智能后端和架构</a>: 站点还有很多Java和Spring Cloud的资料</li>
</ul>
<h3 id="spring-cloud">Spring Cloud</h3>
<ul>
<li><a href="https://spring.io/projects/spring-cloud">官方</a>: 没什么可说的</li>
<li><a href="https://www.springcloud.cc">中文站</a>: 这个中文站东西比较齐全</li>
<li><a href="https://blog.didispace.com/spring-cloud-learning/">程序猿DD</a>: 比较浅显易懂</li>
<li><a href="https://github.com/macrozheng/springcloud-learning">macrozheng</a>: 一套涵盖大部分核心组件使用的Spring Cloud教程，包括Spring Cloud Alibaba及分布式事务Seata，基于Spring Cloud Greenwich及SpringBoot 2.1.7</li>
<li><a href="http://www.ityouknow.com/springcloud/2017/05/01/simple-springcloud.html">纯洁的微笑</a>: 挺好的</li>
</ul>
<h2 id="客户端开发">客户端开发</h2>
<h3 id="安卓原生">安卓原生</h3>
<ul>
<li><a href="https://developer.android.com/docs">官方文档</a>: 安卓官方文档写得非常好</li>
<li><a href="https://developer.android.com/jetpack">JetPack官方文档</a>: 详细介绍了JetPack和Compose</li>
<li><a href="https://edu.aliyun.com/course/813">阿里巴巴手册</a>: 阿里的开发手册，总结了很多值得参考的规范</li>
<li><a href="https://blog.51cto.com/u_4042309/3601572">一份资源汇总</a>: 汇总了国内外一些网站和博客</li>
</ul>
<h3 id="ios">iOS</h3>
<ul>
<li><a href="https://www.cnswift.org">cnswift</a>：Swift语言的中文翻译</li>
<li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md">30分钟上手iOS</a></li>
<li><a href="https://sspai.com/post/67428">从不懂iOS到App Store上架</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1387518">iOS开发教程集锦</a></li>
<li><a href="https://juejin.cn/post/6981393327807528974">信哥开发入门</a></li>
</ul>
<h3 id="flutter">Flutter</h3>
<ul>
<li><a href="https://docs.flutter.dev">官方文档</a></li>
<li><a href="https://flutter.cn/docs">官方支持文档</a></li>
<li><a href="https://www.yuque.com/xytech/flutter/?utm_source=flutter_dot_cn&amp;utm_medium=website&amp;utm_campaign=flutter_cn_landing_highlight">闲鱼团队博客</a></li>
<li><a href="https://flutter-io.cn">Flutter-io</a></li>
<li><a href="https://pub.flutter-io.cn">pub.dev</a></li>
<li><a href="https://guoshuyu.cn/home/wx/Flutter-1.html">GSY</a></li>
<li><a href="https://www.devio.org/2020/11/08/How-should-architects-learn-Flutter-efficiently/">CrazyCodeBoy</a></li>
<li><a href="http://laomengit.com">老孟Flutter</a>: 《Fluuter实战》作者，组件和实战两个系列很适合快速上手</li>
<li><a href="https://github.com/dahliaOS/pangolin_desktop">dahliaOS</a>: 一个使用 Flutter 开发的 Desktop Environment</li>
<li><a href="https://flet.dev">Flet</a>: The fastest way to build Flutter apps in Python.</li>
</ul>
<h2 id="web前端">web前端</h2>
<h3 id="html">HTML</h3>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web">Mdn Web Docs</a>: 提供了一系列HTML、CSS和javascript教程，还有几大框架的简介，可以快速上手</li>
<li><a href="https://deerchao.cn/tutorials/html/html.htm">deerchao</a></li>
<li><a href="https://wangdoc.com/html/">WangDoc</a></li>
</ul>
<h3 id="css">CSS</h3>
<ul>
<li><a href="https://wizardforcel.gitbooks.io/liyanhui-tutorials/content/1.html">李炎恢</a>: 除CSS外，还有很多BootStrap的教程</li>
<li><a href="https://www.feiniaomy.com/tags-4.html">飞鸟慕鱼</a></li>
<li><a href="https://www.idcnote.com/css/">IDC笔记</a></li>
<li><a href="https://www.cdoop.com/css/">CDOOP</a></li>
</ul>
<h2 id="前端框架">前端框架</h2>
<h3 id="vue.js">Vue.js</h3>
<ul>
<li><a href="https://vuejs.bootcss.com/guide/">官方文档</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/windows/dev-environment/javascript/vue-beginners-tutorial">微软提供的文档</a></li>
<li><a href="https://laravelacademy.org/books/vue-tutorial">Laravel学院</a></li>
<li><a href="https://www.liujiangblog.com/course/vue3/">刘江</a></li>
</ul>
<h3 id="taro">Taro</h3>
<h3 id="uni-app">uni-app</h3>
<h2 id="操作系统">操作系统</h2>
<ul>
<li><a href="github.com/LearningOS/rust-based-os-comp2022%20​​​">2022年操作系统训练营</a>：教程共分为八章，主要展示如何从零开始，用 Rust 语言写一个基于 RISC-V 架构的 类 Unix 内核 。</li>
<li><a href="https://www.kernel.org/doc/html/v4.13/translations/zh_CN/coding-style.html">Linux 内核代码风格</a></li>
</ul>
<h2 id="数据库">数据库</h2>
<h3 id="sql语言">SQL语言</h3>
<h3 id="数据库原理">数据库原理</h3>
<ul>
<li><a href="https://cstack.github.io/db_tutorial/">Let's Build a Simple Database</a></li>
</ul>
<h2 id="人工智能">人工智能</h2>
<h3 id="机器学习">机器学习</h3>
<ul>
<li><a href="https://mqshen.gitbooks.io/prml/content/">prml翻译</a></li>
<li><a href="https://www.cnblogs.com/young978/">Christopher·Yougn Blog</a></li>
<li><a href="https://zhangzhenhu.github.io/blog/glm/source/index.html">张振虎的博客</a>: 介绍了很多AI领域的知识</li>
<li><a href="https://easyai.tech/ai-definition/">AI 知识库</a></li>
</ul>
<h3 id="强化学习">强化学习</h3>
<ul>
<li><a href="https://rl.qiwihui.com/zh_CN/latest/">强化学习导论 第二版 中文版</a></li>
<li><a href="https://spinningup.qiwihui.com/zh_CN/latest/">深度强化学习 Spining Up</a></li>
</ul>
<h3 id="计算机视觉">计算机视觉</h3>
<h3 id="推荐系统">推荐系统</h3>
<ul>
<li><a href="https://github.com/gorse-io/gorse">Gorse</a>: Gorse是一个用Go编写的开源推荐系统。 Gorse旨在成为一个通用的开源推荐系统，可以快速引入各种在线服务。通过将项目、用户和交互数据导入Gorse，系统将自动训练模型为每个用户生成推荐。</li>
</ul>
<h2 id="软件开发理论">软件开发理论</h2>
<h3 id="软件工程">软件工程</h3>
<ul>
<li><a href="github.com/qiangmzsx/Software-Engineering-at-Google">Software Engineering at Google</a>: 该指南覆盖了团队管理、效率测量、代码风格规范、项目测试、版本控制、静态分析、依赖管理、持续交付与集成等内容。</li>
</ul>
<h3 id="设计模式">设计模式</h3>
<ul>
<li><a href="https://www.patterns.dev">patterns.dev</a>: 一个教你学习设计模式的网站，也可以下载免费电子书，它主要面向Web前端程序员，通过学习设计模式，让你可以更好的设计和构建现代web应用程序。</li>
</ul>
<h2 id="杂文">杂文</h2>
<ul>
<li><a href="https://blog.frankel.ch/hard-things-computer-science/">Hard things in Computer Science</a></li>
<li><a href="https://thenewstack.io/an-engineers-best-tips-for-writing-documentation-devs-love/">An Engineer’s Best Tips for Writing Documentation Devs Love</a>: 一名工程师关于编写开发者喜欢的文档的建议</li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git</title>
    <url>/blog/posts/30151/</url>
    <content><![CDATA[<h2 id="git简介">Git简介</h2>
<h3 id="git是什么">Git是什么</h3>
<h3 id="为什么要有git">为什么要有Git</h3>
<h3 id="我必须要用git吗">我必须要用Git吗</h3>
<h3 id="git的安装与配置">Git的安装与配置</h3>
<h2 id="githubgitee和gitlab">Github、Gitee和GitLab</h2>
<h2 id="使用git">使用Git</h2>
<h3 id="基本操作">基本操作</h3>
<h3 id="merge和rebase">merge和rebase</h3>
<h3 id="冷门命令">冷门命令</h3>
<h4 id="stash3">stash<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Git 不能只会 pull 和 push，试试这5条提高效率的命令吧！
">[3]</span></a></sup></h4>
<h2 id="开源许可证">开源许可证</h2>
<h3 id="什么是开源许可证">什么是开源许可证</h3>
<p>世界上的开源许可证（Open Source License）大概有上百种，大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等#</p>
<h4 id="简单分类">简单分类</h4>
<p>大致分为两大类：<strong>宽松自由软件许可协议（“Permissive free software licence”）和著佐权许可证（“copyleft license”）</strong>。</p>
<blockquote>
<p>Permissive free software licence 是一种对软件的使用、修改、传播等方式采用<strong>最低限制的自由软件许可协议条款类型</strong>。这种类型的软件许可协议将不保证原作品的派生作品会继续保持与原作品完全相同的相关限制条件，从而为原作品的自由使用、修改和传播等提供更大的空间。</p>
<p>而 Copyleft License 是在有限空间内的自由使用、修改和传播，且不得违背原作品的限制条款。如果一款软件使用 Copyleft 类型许可协议规定软件<strong>不得用于商业目的，且不得闭源，</strong>那么后续的衍生子软件也必须得遵循该条款。</p>
</blockquote>
<p><strong>两者最大的差别在于</strong>，在软件被修改并再发行时， Copyleft License 仍然强制要求公开源代码（衍生软件需要开源），而 Permissive free software licence 不要求公开源代码（衍生软件可以变为专有软件）。</p>
<blockquote>
<p>其中，Apache、MIT、BSD 都是宽松许可证，GPL 是典型的强著佐权（copyleft ）许可证，LGPL、MPL 是弱著佐权（copyleft ）许可证。SSPL 则是近年来 MongoDB 创建的一个新许可证，存在较大争议，开放源代码促进会 OSI 甚至认为 SSPL 就不是开源许可协议。</p>
</blockquote>
<p>此外，还有一类是 Creative Commons（CC）知识共享协议。严格意义上说该协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。</p>
<blockquote>
<p>CC 协议种类繁多，每一种都授权特定的权利。大多数的比较严格的 CC 协议会声明 “署名权，非商业用途，禁止衍生” 条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的 CC 协议类型当属 “署名” 协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p>
</blockquote>
<figure>
<img src="https://img1.www.pingcap.com/prod/_8670ba8cf1.webp" alt="协议列表.webp" /><figcaption aria-hidden="true">协议列表.webp</figcaption>
</figure>
<h4 id="开源与开源许可证的历史">开源与开源许可证的历史</h4>
<p>开源这个词最初其实是指开源软件（OSS）。开源软件是源代码可以任意获取的计算机软件，任何人都能查看、修改和分发他们认为合适的代码。</p>
<p><strong>在开源领域中，存在着两大阵营</strong>：FSF（Free Software Foundation，自由软件基金会) 和 OSI（Open Source Initiative，开放源代码促进会），<strong>他们对开源有着不同的理念</strong>。</p>
<blockquote>
<p>FSF 是开源泰斗 RMS 创立的重要的开源软件基金会 (1985/10/04), FSF 创立之初主要是为了筹集资金来建设 GNU 的内核 Hurd 项目及工具链，虽然 GNU 项目本身没有完成，但是该过程中创造出的大量软件工具，日后成为了 GNU/Linux 的重要组成部分。为了<strong>贯彻 RMS 对 “自由” 和 “开源” 的理解</strong>，FSF 建立了开源领域的第一个 “copyleft” 属性的许可证 - GPL (GNU Public License) 。</p>
<p>OSI 由开源界泰斗 Bruce Perens 和 Eric S. Raymond (ESR) 在 1998 年组建，目的是在原教旨主义开源 (最早的开源运动发起和推动者们) 与软件工业/商业之间激烈矛盾中，寻求<strong>更平衡的体系和治理机制</strong>。OSI 组织批准过的许可大概有 80 种，包括 Apache License v2、GPL v2、MIT/BSD 等。</p>
</blockquote>
<p>FSF 与 OSI 是推广和维护开源秩序的非盈利组织，维护着 “开源” 的定义以及主要的开源软件协议递交、讨论与审核。只要条款被审核通过是符合开放源代码定义的，就可以称之为开放源码授权条款，采用开放源码条款散布授权的软件即是开放源码软件，若一份商业产品中包含有开放源码软件，其包装上可以标上开放源码促进会的证明标章，认识这个标章的消费者就可以知道产品中有使用到开放源码软件，进而因为开放源码软件特有的优点而购买产品。</p>
<figure>
<img src="https://img1.www.pingcap.com/prod/_e1f8e1d3bd.webp" alt="开源标识.webp" /><figcaption aria-hidden="true">开源标识.webp</figcaption>
</figure>
<h3 id="常见开源许可证">常见开源许可证</h3>
<h4 id="apache-license">Apache License</h4>
<p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p>
<p>Apache License 最初为 Apache http 服务器而撰写。此许可证最新版本为 “版本 2”，于 2004 年 1 月发布。<strong>Apache 许可证鼓励代码共享和最终原作者的著作权，允许源代码修改和再发布</strong>。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。</p>
<blockquote>
<p>例如，在一个使用 Apache 许可证的开源项目中，其下游 Fork 的企业不仅没有回馈上游开源项目，反而将衍生的代码更改为不受 OSI 认可的 SSPL Licence，另行宣布成为一个新的开源项目，误导了很多不明真相的人，以为又涌现出一个新的开源项目。但该行为其实已经对原开源项目的合法权益造成了侵害，也有背开源精神。</p>
</blockquote>
<p>但是也需要遵循以下条件：</p>
<ul>
<li>需要给<strong>代码的用户</strong>一份Apache Licence。</li>
<li>如果修改了代码，需要在被修改的文件中说明。</li>
<li>在<strong>衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明</strong>。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
<li>Apache Licence也是<strong>对商业应用友好</strong>的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li>
</ul>
<p>它有这些好处</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<h4 id="bsd">BSD</h4>
<p>BSD是"Berkeley Software Distribution"的缩写，意思是"伯克利软件发行版"。</p>
<p>BSD开源协议是一个给于使用者很大自由的协议。可以<strong>自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布</strong>。</p>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的<strong>公司企业在选用开源产品的时候都首选BSD协议</strong>，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<p>当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li><strong>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广</strong>。</li>
</ul>
<h4 id="gpl">GPL</h4>
<p>GPL （GNU General Public License） ：GNU通用公共许可协议。<strong>Linux 采用了 GPL</strong>。</p>
<p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但<strong>不允许修改后和衍生的代码做为闭源的商业软件发布和销售</strong>。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了</p>
<h4 id="lgpl">LGPL</h4>
<p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<h4 id="mit">MIT</h4>
<p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。</p>
<p><strong>作者只想保留版权,而无任何其他限制</strong>。MIT与BSD类似，但是比BSD协议更加宽松，是<strong>目前最少限制的协议</strong>。</p>
<p>这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。</p>
<p>使用MIT的软件项目有：jquery、Node.js。</p>
<p>有许多团体均采用 MIT 许可证。例如著名的 ssh 连接软件 PuTTY 与 X Window System (X11) 即为例子。Expat 、Mono 开发平台库、Ruby on Rails、 Lua 5.0 onwards 等等也都采用 MIT 授权条款。</p>
<h3 id="如何选择开源许可证">如何选择开源许可证</h3>
<p>一些思维导图</p>
<figure>
<img src="https://pic1.zhimg.com/80/v2-bc54a5e176e1ff9d75dda56da5472366_1440w.jpg?source=1940ef5c" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<p>从左到右越来越严格</p>
</blockquote>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2018/03/61590003177751b9d5bd.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://www.runoob.com/wp-content/uploads/2018/03/f1989e42b25bb73fead5cb1d09036e6f.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="仓库规范">仓库规范</h2>
<h2 id="参考资料">参考资料</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span>(https://www.runoob.com/w3cnote/open-source-license.html) <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span>(https://pingcap.com/zh/blog/introduction-of-open-source-license) <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/vCcmCWhNsDdQXJQwT6AZOQ">Git 不能只会 pull 和 push，试试这5条提高效率的命令吧！</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南 - 阮一峰的网络日志</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>分层和解耦</title>
    <url>/blog/posts/63603/</url>
    <content><![CDATA[<h1 id="耦合">耦合</h1>
<p>我们所探讨的耦合、解耦，到底是在说什么？</p>
<h2 id="到底什么是耦合">到底什么是耦合</h2>
<h2 id="什么是解耦">什么是解耦</h2>
<h1 id="why">Why</h1>
<h2 id="所谓的解耦如何发展">所谓的解耦如何发展</h2>
<h2 id="高耦合和低耦合的区别">高耦合和低耦合的区别</h2>
<h2 id="具体例子">具体例子</h2>
<h1 id="how">How</h1>
<h2 id="分包">分包</h2>
<h2 id="分层">分层</h2>
<h2 id="设计模式">设计模式</h2>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Android</tag>
        <tag>设计模式</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机原理与应用</title>
    <url>/blog/posts/33533/</url>
    <content><![CDATA[<h1 id="引论">引论</h1>
<h2 id="发展简史">发展简史</h2>
<p>Intel设计最早的微处理器有4004、8080/8085、8088/8086、80286、80386、80486、Pentium、Pentium II、Pentium III、Pentium IV、Core（众核时代）</p>
<h3 id="dspdigital-signal-processor和arm">DSP（Digital Signal Processor）和ARM</h3>
<p>DSP主要用于数字信号的处理，ARM用于通信领域</p>
<h2 id="名词解释">名词解释</h2>
<h3 id="微机微型计算机">微机（微型计算机）</h3>
<ul>
<li>CPU
<ul>
<li>运算器</li>
<li>控制器</li>
<li>寄存器</li>
</ul></li>
<li>内存
<ul>
<li>ROM</li>
<li>RAM</li>
</ul></li>
<li>IO接口（IO设备&amp;总线）</li>
</ul>
<h3 id="单片机">单片机</h3>
<h3 id="微机系统">微机系统</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>选修</tag>
      </tags>
  </entry>
  <entry>
    <title>又有一个idea</title>
    <url>/blog/posts/12000/</url>
    <content><![CDATA[<h2 id="产品文档">产品文档</h2>
<h3 id="需求分析">需求分析</h3>
<h4 id="多出发地-目的地和交通方式">多出发地-目的地和交通方式</h4>
<p>假设我们现在要有两个人，要去一个目的地，一般会希望在相近的时间到达。</p>
<ol type="1">
<li>第一是每个人都要知道自己的票的情况（有没有，评价这个列车的热门程度，结合出行的时间给出一个建议）</li>
<li><strong>这几个人，凑一个最接近的方案</strong></li>
</ol>
<h3 id="产品逻辑">产品逻辑</h3>
<h3 id="交互设计">交互设计</h3>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>四级备考</title>
    <url>/blog/posts/29820/</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<p>主要在知乎尝试了一下寻找有价值的资料，但几乎都是软文和吹牛逼的</p>
<p>算是找到一个对题型性价比的分析，整篇贴过来参考一下</p>
<h2 id="扫盲">扫盲</h2>
<p>四级题型和分值配比如下</p>
<figure>
<img src="https://pic2.zhimg.com/v2-2f81f9e4338e06cbd1071101e2638ba1_b.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>考试时间安排如下</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14qcqik98j20vc0ek0ud.jpg" alt="image-20220410165859933" /><figcaption aria-hidden="true">image-20220410165859933</figcaption>
</figure>
<h3 id="作文题型">作文题型</h3>
<blockquote>
<p>写作部分测试学生用英语进行书面表达的能力，所占分值比例为15%，考试时间30分钟。写作测试选用考生所熟悉的题材，要求考生根据所提供的信息及提示(如：提纲、情景、图片或图表等)写出一篇短文，四级120-180词。</p>
</blockquote>
<h3 id="听力题型">听力题型</h3>
<blockquote>
<p>为了适应新的形势下社会对大学生英语听力能力需求的变化，进一步提高听力测试的效度，取消短对话和短文听写，新增了3篇短篇新闻，其余测试内容不变。调整后的CET4听力时间为25分钟，考试起止时间调整为9:00-11:20。</p>
</blockquote>
<ol type="1">
<li>短篇新闻3段 （单选 7%）共七个小题</li>
<li>长对话2篇 （单选 8%）共八个小题</li>
<li>听力篇章3篇 （单选 20%）共十个小题</li>
</ol>
<h3 id="阅读题型">阅读题型</h3>
<blockquote>
<p>阅读理解部分包括1篇长篇阅读和3篇仔细阅读，测试大家在不同层面上的阅读理解能力。这一部分所占分值比例为35%，其中长篇阅读占10%，仔细阅读占20%，选词填空占5%，考试时间40分钟。</p>
</blockquote>
<ol type="1">
<li>词汇理解（选词填空 5%）</li>
<li>长篇阅读（匹配 10%）</li>
<li>仔细阅读（单项选择 20%）</li>
</ol>
<p>各自有十个题</p>
<h3 id="翻译题型">翻译题型</h3>
<blockquote>
<p>翻译部分测试学生把汉语所承载的信息用英语表达出来的能力，所占分值比例为15%，考试时间30分钟。翻译题型为段落汉译英。翻译内容涉及中国的历史、文化、经济、社会发展等。四级长度为140-160个汉字。</p>
</blockquote>
<h2 id="题型分析">题型分析</h2>
<p><strong>题目的性价比：听力&gt;阅读&gt;作文&gt;翻译</strong></p>
<p><strong>提分简易程度：听力&gt;阅读&gt;作文&gt;翻译</strong></p>
<p>然而……</p>
<p><strong>题型难度系数：翻译&gt;作文&gt;阅读&gt;听力</strong></p>
<p>这下一目了然了吧！翻译和作文不仅性价比最低，而且难度系数最高，提分最难；而听力和阅读不仅性价比高，而且难度降低，提分最快！</p>
<p>所以，先攻听力，再攻阅读，最后再搞作文和翻译。</p>
<p>听力和阅读是占分数最多的部分，也是复习的重点，同时也是需要集中复习的部分</p>
<p>写作和翻译有想通之处，考察的都是句子，可以一起复习。</p>
<h1 id="复习技巧">复习技巧</h1>
<h1 id="作文">作文</h1>
<h1 id="应试技巧">应试技巧</h1>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理</title>
    <url>/blog/posts/58979/</url>
    <content><![CDATA[<h1 id="简述">简述</h1>
<h2 id="经典力学">经典力学</h2>
<p>经典力学部分包括运动学和动力学，基本上发展到1990年代</p>
<h1 id="运动学">运动学</h1>
<h2 id="质点和质点运动的描述">质点和质点运动的描述</h2>
<h3 id="质点">质点</h3>
<p>没有体积和形状, 只具有一定质量的理想物体。</p>
<blockquote>
<p>当两物体之间的距离（l）大于大于物体自身线度（r）时，物体可以视为一个质点；否则就不能视为一个质点。</p>
</blockquote>
<h3 id="参考系坐标系">参考系、坐标系</h3>
<h4 id="参考系和坐标系">参考系和坐标系</h4>
<p>为了描述物体的机械运动，必须选择另一个物体或者物体系作参照物，被选作参照的物体或者物体系称为参考系。只有选择了参考系，才能明确地表示被研究物体的运动情形。</p>
<p>坐标系是指固定在参考系上的数学坐标，它的作用是把运动物体在每一时刻相对于参考系的位置定量地表示出来。</p>
<h4 id="位置矢量">位置矢量</h4>
<p>位置矢量，简称位矢，用<span class="math inline">\(\vec{OP}\)</span>表示</p>
<p>位置矢量矢关于时间<span class="math inline">\(t\)</span>的函数，即<span class="math inline">\(\textbf{r} = \textbf{r}(t)\)</span></p>
<p>该式被称为<strong>轨道参量方程</strong>or<strong>运动学方程</strong>，表示了质点的轨迹和任意时刻所处的位置</p>
<h4 id="路程和位移">路程和位移</h4>
<p>二者存在关系 <span class="math display">\[
\lim_{\Delta{t}\rightarrow{0} }{|\Delta{\textbf{r} }|}=\lim_{\Delta{t}\rightarrow{0} }{\Delta{s} }
\]</span></p>
<h4 id="直角坐标系">直角坐标系</h4>
<p>选定一个直角坐标系，指定两两互相垂直的单位矢量<span class="math inline">\(i,j,k\)</span>，可以将任意位置矢量表示为 <span class="math display">\[
\textbf{r} = x\textbf{i}+y\textbf{j}+z\textbf{k}
\]</span> 其方向角和存在的关系为 <span class="math display">\[
cos\alpha={ {x}\over{r} },cos\beta={ {y}\over{r} },cos\gamma = { {z}\over{r} },\\
{cos\alpha}^2+{cos\beta}^2+{cos\gamma}^2=1
\]</span> <strong>运动叠加原理</strong>可以在直角坐标系下进行一系列表示</p>
<h4 id="平面极坐标系">平面极坐标系</h4>
<p>在平面选择一个点O作为<strong>极点</strong>，沿某方向作一条射线OA作为极轴</p>
<p>对平面内一点P，连线OP称为点P的极径，用<span class="math inline">\(\rho\)</span>表示；OA到OP转过的角称为点P的极角，用<span class="math inline">\(\theta\)</span>表示；<span class="math inline">\(\rho\)</span>和<span class="math inline">\(\theta\)</span>组成点P的极坐标</p>
<p>对任一位置矢量，有 <span class="math display">\[
\textbf{r}{(t)}={\rho{(t)} }{\textbf{e}_{\rho}{(t)} }
\]</span> 其中<span class="math inline">\(\rho{(t)}\)</span>表示沿极径方向的长度，<span class="math inline">\(\textbf{e}_{\rho}{(t)}\)</span>表示单位矢量的变化率，即极角的变化</p>
<h4 id="自然坐标系">自然坐标系</h4>
<p>沿质点运动的方向，我们可以规定切向单位矢量<span class="math inline">\(\textbf{e}_t\)</span>和法向单位矢量<span class="math inline">\(\textbf{e}_{\tau}\)</span></p>
<h3 id="时刻和时间">时刻和时间</h3>
<h3 id="速度和速率">速度和速率</h3>
<h4 id="径向速度横向速度和角速度">径向速度、横向速度和角速度</h4>
<p>对于上面给出的极坐标系下位置矢量的表示，进一步可以得到 <span class="math display">\[
\textbf{v}{(t)}={ {d\rho}\over{dt} }{\textbf{e}_{\rho} }+{\rho}{ {d\textbf{e_{\rho} }\over{dt} } }
\]</span> 在一段时间内，我们可以取出<span class="math inline">\(\textbf{e}_{\rho}{(t)},\textbf{e}_{\rho}{(t+\Delta{t})},\Delta{\textbf{e}_{\rho} }\)</span>组成三角形<span class="math inline">\(O&#39;A&#39;B&#39;\)</span></p>
<p>对于矢量<span class="math inline">\(\Delta{\textbf{e}_{\rho} }\)</span>，他可以视作一个垂直于单位矢量<span class="math inline">\(\textbf{e}_{\rho}\)</span>的单位矢量<span class="math inline">\(\textbf{e}_{\theta}\)</span>，在三角形中，可以近似的认为<span class="math inline">\(tan(\theta)\approx sin(\theta) \approx \theta\)</span>，那么<span class="math inline">\(\textbf{e}_{\rho}=\Delta{\theta}{\textbf{e}_{\theta} }\)</span>，可以得到 <span class="math display">\[
{ {d\theta}\over{dt} }=\lim_{\Delta{t}\rightarrow 0}{ {\Delta \textbf{e}_{\rho} }\over{\Delta t} }
\]</span> ...</p>
<blockquote>
<p>参考P16</p>
</blockquote>
<p>总之就是可以得到径向速度和横向速度，分别为 <span class="math display">\[
v_{\rho}={ {d\rho}\over{dt} },v_{\theta}={\rho{ {d\theta}\over{dt} } }
\]</span> 特别的，另径向速度为0，对横向速度可以得到 <span class="math display">\[
v_{\theta}={\rho{ {d\theta}\over{dt} } }={ {ds}\over{dt} }=v
\]</span> 定义角速度<span class="math inline">\(\omega={ {d\theta}\over{dt} }\)</span>，横向速度可以表示为<span class="math inline">\(v_{\theta}=\rho\omega\)</span></p>
<h3 id="加速度">加速度</h3>
<p>简单记录一下如何用微积分的方式书写加速度的定义 <span class="math display">\[
\textbf{a} = {\lim_{\Delta{t}\rightarrow{0} } }{ {\Delta{\textbf{v} } }\over{\Delta{t} } }={ {d\textbf{v} }\over{dt} }={ { {d^2}\textbf{r} }\over{d{t^2} } }
\]</span></p>
<blockquote>
<p>不得不说Markdown写公式还是需要时间重新熟悉一下。。</p>
</blockquote>
<h4 id="径向加速度和横向加速度">径向加速度和横向加速度</h4>
<p>继续讨论<span class="math inline">\(\Delta{\textbf{e}_{\theta} }\)</span></p>
<p>通过推导可以得到 <span class="math display">\[
a_{\rho}={ { {d^2\rho}\over{dt^2} }-\rho({ {d\theta}\over{dt} })^2},a_\theta={\rho{ {d^2\rho}\over{dt^2} }+2{ {d\rho}\over{dt} }{ {d\theta}\over{dt} } }
\]</span></p>
<h4 id="向心加速度切向加速度和角加速度">向心加速度、切向加速度和角加速度</h4>
<h3 id="曲线运动">曲线运动</h3>
<h4 id="曲率和曲率半径">曲率和曲率半径</h4>
<p>对一段曲线运动，从A到B，<span class="math inline">\(\Delta{s}=\widehat{AB}\)</span>，定义平均曲率为 <span class="math display">\[
\bar{k}={ {\Delta{\theta} }\over{\Delta{s} } }
\]</span> 定义曲率 <span class="math display">\[
k={\lim_{\Delta{t}\rightarrow{0} } }{ {\Delta \theta}\over{\Delta{t} } }={ {d\theta}\over{dt} }
\]</span> 定义曲率半径 <span class="math display">\[
R={ {1}\over{k} }
\]</span></p>
<h2 id="相对运动和相对坐标系">相对运动和相对坐标系</h2>
<p>牛顿运动定律成立的参考系叫做惯性系，不能成立的叫做非惯性系</p>
<p>伽利略/力学相对性原理：对于描述力学规律而言，所有惯性系都是等价的</p>
<p>可以通过引入惯性力来使用牛顿定律处理非惯性系的问题 <span class="math display">\[
\textbf{F_{i} }=-m\textbf{a}
\]</span></p>
<h3 id="坐标的变换">坐标的变换</h3>
<p>若用两个坐标系对同一个物体的运动进行描述，则将该物体的坐标从一个坐标系变换到另一个坐标系的操作，就称为坐标变换。</p>
<p>如果将描述物体的某个物理量在一个坐标系中的各个分量用它在另一个坐标系中的各个分量表达出来，那么这组表达式就称为该物理量的变换法则</p>
<h3 id="伽利略变换">伽利略变换</h3>
<p>对于一切惯性系，时间是相同的，或者说，时间与参考系的运动状态无关，即:<span class="math inline">\(t&#39;=t\)</span></p>
<p>引入时间变换后，完整的伽利略变换为 <span class="math display">\[
\begin{cases}
x&#39;=x-vt\\
y&#39;=y\\
z&#39;=z\\
t&#39;=t
\end{cases}
\]</span></p>
<h2 id="常见问题和思路">常见问题和思路</h2>
<h1 id="动力学">动力学</h1>
<h2 id="牛顿运动定律">牛顿运动定律</h2>
<h3 id="第一定律">第一定律</h3>
<p>任何物体都要保持其静止状态或匀速直线运动 状态, 直到其它物体所作用的力迫使它改变为止。</p>
<p>数学形式记为 <span class="math display">\[
\textbf{v}=恒矢量(\textbf{F}=\textbf{0})
\]</span></p>
<p>惯性是物体所具有的一种固有特性，保持静止状态或匀速直线运动状态。</p>
<p>牛顿第一定律也称为惯性定律。</p>
<p>要改变物体所处的状态, 外界必须对物体施加影响或作用, 也就是力。</p>
<h3 id="第二定律">第二定律</h3>
<p>质点加速度的大小与所受合力的大小成正比 , 与质点自身的质量成反比; 加速度方向与合力方向相同。</p>
<p>数学形式为 <span class="math display">\[
\textbf{F}=m\textbf{a}
\]</span> 期中质量是为了描述惯性而引入的，被称为惯性质量</p>
<h3 id="第三定律">第三定律</h3>
<p>物体 A 以力FAB 作用于物体B时, 物体 B也必定同时以力FBA 作用于物体 A , FAB与FBA 大小相等, 方向相反, 并处于同一条直线上</p>
<h2 id="力学中常见的力">力学中常见的力</h2>
<p>自然界存在四种基本力，即万有引力、电磁力、强力和弱力（或者叫做强相互作用和弱相互作用）。</p>
<h3 id="万有引力">万有引力</h3>
<p>有万有引力的空间内存在一种物质，称为引力场， 物体间(万有)引力相互作用通过引力场传递。粒子物理学认为引力相互作用通过引力子传递。</p>
<p>任意两质点间都存在引力, 方向沿着两质点连线；大小与两质点的质量的乘积成正比, 与两质点间距离r12 的平方成反比 <span class="math display">\[
F_{12}=G{ { {m_1}{m_2}\over{r_{12} }^2} }
\]</span> 矢量形式可以记为 <span class="math display">\[
\textbf{F_{12} }=-G{ { {m_1}{m_2} }\over{ {r_{12} }^2} }({ {\textbf{r_{12} }\over{r_{12} } } })
\]</span> r12表示从质点m1到质点m2所引的有向线段, 负号表示F12的方向与r12的方向相反。</p>
<p>万有引力中引入的质量叫做引力质量，引力质量与在牛顿运动定律中引入的惯性质量一样, 也是物体自身的一种属性的量度, 它表征了物体之间引力作用的强度。</p>
<h3 id="弹性力">弹性力</h3>
<p>形变物体，由于力图恢复原状，对与它接触的物体产生的作用力</p>
<p>物体受力要发生形变, 当把力撤除后, 物体若完全恢复到原来的形状，称为弹性形变。</p>
<p>如果作用于物体的力超过一定限度, 物体就不能完全恢复原状了, 这个限度称为弹性限度。</p>
<p>弹簧未形变时物体的位置, 称为平衡位置 <span class="math display">\[
F=-kx
\]</span></p>
<h3 id="摩擦力">摩擦力</h3>
<p>物体在另一个物体表面滑动或有滑动趋势时, 接触面上产生阻碍物体作相对滑动的力即摩擦力。</p>
<p>在两个物体之间发生的摩擦现象称外摩擦现象。在物体内部各部分之间, 若有相对移动, 发生的摩擦现象称为内摩擦。</p>
<p>摩擦力产生与接触面凹凸不平而互相嵌合, 与分子之间的引力作用和静电作用有关。</p>
<p>当物体有滑动趋势但尚未滑动时, 作用在物体上的摩擦力称为静摩擦力。 <span class="math display">\[
f_{max}=\mu_{0}{F_{n} }
\]</span></p>
<p>一个物体在另一个物体表面上滑动时,接触面上产生的摩擦力, 称为滑动摩擦力。 <span class="math display">\[
f=\mu{F_{n} }
\]</span></p>
<h2 id="能量守恒">能量守恒</h2>
<h3 id="功和功率">功和功率</h3>
<p>功是力在空间上的累积，被定义为作用于质点的力沿力的方向所做位移的乘积 <span class="math display">\[
\Delta{A}=\textbf{F}·\Delta\textbf{r}=F\Delta{r}\cos{\phi}
\]</span> 对于一段过程，总功可以表示为 <span class="math display">\[
dA= \textbf{F}d\textbf{r}\\
A=\int_{P}^{Q}{dA}=\int_{P}^{Q}{\textbf{F}d\textbf{r} }=\int_{P}^{Q}{F\cos{\phi}dr}
\]</span> 功率可以表示为 <span class="math display">\[
P={ {dA}\over{dt} }=\textbf{F}{ {d\textbf{r} }\over{dt} }=\textbf{F}\textbf{v}
\]</span> 在实际问题中，物体的位移和力的作用点的位移并不是一回事，这时为计算功就必须考察力的作用点的位移。</p>
<h3 id="动能">动能</h3>
<p>动能定义为 <span class="math display">\[
E_{k}={1\over2}mv^2
\]</span></p>
<h3 id="动能定理">动能定理</h3>
<p>动能定理：作用于质点的合力所作的功，等于质点动能的增量</p>
<p>由于物体的运动速度与参考系的选取有关，所以同一运动物体相对于不同的参考系(惯性系)，可能有不同的动能。</p>
<h3 id="势能">势能</h3>
<p>势能：由物体间的相互作用和相对位置决定的能量</p>
<blockquote>
<p>弹性力、万有引力和重力所作的功与路径无关，仅与始终位置有关——<strong>保守力</strong></p>
</blockquote>
<h3 id="机械能守恒">机械能守恒</h3>
<h2 id="动量守恒">动量守恒</h2>
<h3 id="动量和冲量">动量和冲量</h3>
<p>质点的动量是质点质量与其速度的乘积</p>
<p>可以得到牛顿第二定律的微分表示 <span class="math display">\[
\textbf{F}={ {d\textbf{p} }\over{dt} }
\]</span> 该式在微观高速情况下同样适用</p>
<p>冲量表示为动量在时间上的积分 <span class="math display">\[
\textbf{I}=\int_{t_0}^{t}{\textbf{p}dt}
\]</span></p>
<h3 id="动量定理动量守恒定律">动量定理、动量守恒定律</h3>
<p>动量定理：在运动过程中，作用于质点的合力在一段时间内的冲量等于质点动量的增量——动量定理</p>
<p>质点系动量定理：在一段时间内，作用于质点系的外力的矢量和的冲量等于质点系动量的增量 <span class="math display">\[
\Sigma_{i=1}^{n}{\textbf{F_{i} } }={d\over{dt} }\Sigma_{i=1}^{n}{ {m_{i}\textbf{v_{i} } } } (微分形式)
\]</span></p>
<h3 id="求质心位置">求质心位置</h3>
<p>质心：质点系的质量中心</p>
<p>n个质点质点系质心的位矢 <span class="math display">\[
\textbf{r_c}={ {\Sigma_{i=1}^{n}m_i{\textbf{r_i} } }\over{\Sigma_{i=1}^{n} }m_i}
\]</span> 连续体的质心 <span class="math display">\[
\textbf{r_c}={ {}\int{\textbf{r}dm}\over{\int{dm} } }
\]</span></p>
<blockquote>
<p>质量分布均匀、形状对称的实物，质心位于其<strong>几何中心</strong>处； 不太大的实物，质心与重心相重合； <strong>质点到质心的距离之比与其质量成反比</strong>； 质心可以不在物体之内。</p>
</blockquote>
<p>质点系的质量与质心速度的乘积(可称为质心的动量)，等于质点系的总动量</p>
<h3 id="碰撞">碰撞</h3>
<p>当两个或两个以上的物体互相接近时, 在极短的时间内, 它们之间的相互作用达到相当大的数值, 致使它们的运动状况突然发生显著变化, 这种现象称为碰撞</p>
<p>碰撞一般可以分为完全弹性碰撞、非弹性碰撞和完全非弹性碰撞</p>
<h3 id="火箭发射的推导">火箭发射的推导</h3>
<h2 id="角动量和角动量守恒">角动量和角动量守恒</h2>
<h3 id="力矩和角动量">力矩和角动量</h3>
<blockquote>
<p>对于一静止的质点，当它受到外力作用时，将开始运动；但对于物体的转动而言，当它受到外力作用时，可能转动也可能不转动，这决定于此外力是否产生力矩。外力产生力矩，物体就转动，否则，物体不会转动。因此，为了描述引起物体转动的原因，我们要引入力矩。</p>
</blockquote>
<p>力矩被定义为 <span class="math display">\[
\textbf{N}=\textbf{r}\times \textbf{F}=rF\sin{\theta}
\]</span> 角动量被定义为 <span class="math display">\[
\textbf{L}=\textbf{r}\times m\textbf{v}
\]</span> 如果质点是在一个平面上运动，可以将此平面取为xy平面，则： <span class="math display">\[
\textbf{L}={(xmv_y-ymv_x)}\textbf{k}=L_z \textbf{k}
\]</span></p>
<h3 id="角动量定理和角动量守恒">角动量定理和角动量守恒</h3>
<p>角动量定理：作用于质点的合力对某参考点的力矩，等于质点对同一参考点的角动量随时间的变化率 <span class="math display">\[
\textbf{M}={ {d\textbf{L} }\over{dt} }（微分形式）
\]</span> 质点角动量守恒定律：若作用于质点的合力对参考点的力矩<span class="math inline">\(\textbf{M}=\textbf{0}\)</span>，有 <span class="math display">\[
\textbf{M}={ {d\textbf{L} }\over{dt} }=\textbf{0}\\
\Rightarrow \textbf{L}=\textbf{0}
\]</span> 若作用于质点的合力对参考点的力矩始终为零, 则质点对同一参考点的角动量将保持恒定</p>
<h3 id="质点系的角动量定理和角动量守恒">质点系的角动量定理和角动量守恒</h3>
<h2 id="从质点到刚体">从质点到刚体</h2>
<h2 id="振动和波动">振动和波动</h2>
<h3 id="简谐振动及其合成">简谐振动及其合成</h3>
<h4 id="简谐振动的描述">简谐振动的描述</h4>
<ul>
<li>任何一个物理量在一个值附近作反复变化，都能被称为振动。</li>
</ul>
<p>任何物理量<span class="math inline">\(x\)</span>如果满足方程式</p>
<p><span class="math display">\[
{\frac{d^2x}{dt^2} }+{ {\omega}^2x}=0
\]</span></p>
<p>且<span class="math inline">\(\omega\)</span>是取决于系统自身的变量，这个变化过程就是简谐振动。</p>
<p>根据简谐振动的初始条件，我们可以推导出</p>
<p><span class="math display">\[
\begin{array}{l}
A={\sqrt{ {x^2_0}+{\frac{v^2_0}{\omega^2} } } }\\
{\phi}={arctan({-{\frac{v_0}{ {\omega}{x_0} } } })}
\end{array}
\]</span></p>
<h4 id="简谐振动的能量">简谐振动的能量</h4>
<p>简谐振动的过程中能量是守恒的，在质点动能和势能之间来回转换</p>
<p>他们的最大值分别为</p>
<p><span class="math display">\[
\begin{array}{l}
{E_k}={\frac{1}{2} }m{\omega}^2{A^2}\\
{E_p}={\frac{1}{2} }kA^2
\end{array}
\]</span></p>
<p>利用上面两个式子还可以得到</p>
<p><span class="math display">\[
v={\plusmn}{\omega}{\sqrt{A^2-x^2} }
\]</span></p>
<h4 id="同一直线上同频率的合成">同一直线上同频率的合成</h4>
<p>对两个振动</p>
<p><span class="math display">\[
\begin{array}{l}
{x_1}={A_1}cos({ {\omega}t+{\phi_1} })\\
{x_2}={A_2}cos({ {\omega}t+{\phi_2} })\\
\end{array}
\]</span></p>
<p>他们的合振动的振幅为</p>
<p><span class="math display">\[
A={\sqrt{ {A_1^2}+{A_2^2}+2{A_1}{A_2}{cos({ {\phi_2}-{\phi}_1})} } }
\]</span></p>
<p>合振动的初相位为</p>
<p><span class="math display">\[
{\phi}={\frac{ {A_1}{sin{\phi_1} }+{A_2}{sin{\phi_2} } }{ {A_1}{cos{\phi_1} }+{A_2}{cos{\phi_2} } } }
\]</span></p>
<p>特别的，</p>
<ul>
<li>当相位差是<span class="math inline">\(\pi\)</span>的偶数倍时，<span class="math inline">\(A={A_1}+{A_2}\)</span></li>
<li>当相位差是<span class="math inline">\(\pi\)</span>的奇数倍时，<span class="math inline">\(A=|{A_1}-{A_2}|\)</span></li>
</ul>
<h4 id="同一直线上相近频率的合成">同一直线上相近频率的合成</h4>
<p>对两个振动</p>
<p><span class="math display">\[
\begin{array}{l}
{x_1}={A_1}cos({ {\omega_1}t+{\phi_1} })\\
{x_2}={A_2}cos({ {\omega_2}t+{\phi_2} })\\
\end{array}
\]</span></p>
<p>他们的合振动的振幅为</p>
<p><span class="math display">\[
A={\sqrt{ {A_1^2}+{A_2^2}+2{A_1}{A_2}{cos[{({\omega_2}-{\omega_1})t}+{({\phi_2}-{\phi}_1})}]} }
\]</span></p>
<blockquote>
<p>不难看出，此时合振动的振幅是呈周期性变化的。</p>
</blockquote>
<p>此时会出现规律的加强、减弱现象，我们称之为拍现象。合振动一秒内减弱或加强的次数被称为拍频，为</p>
<p><span class="math display">\[
v={v_2}={v_1}
\]</span></p>
<p>假设两个振动有相同的振幅和初相位，通过和差化积可以得到</p>
<p><span class="math display">\[
x={2A{cos({ {\frac{ {\omega_2}-{\omega_1} }{2} }t})}{cos({ {\frac{ {\omega_2}+{\omega_1} }{2} }+{\phi} })} }
\]</span></p>
<p>此时，周期</p>
<p><span class="math display">\[
T={ {\pi}({\frac{2}{ {\omega_2}-{\omega_1} } })}={\frac{2{\pi} }{ {\omega_2}-{\omega_1} } }
\]</span></p>
<p>拍频</p>
<p><span class="math display">\[
v={\frac{1}{T} }={\frac{ {\omega_2}-{\omega_1} }{2{\pi} } }={ {v_2}-{v_1} }
\]</span></p>
<h4 id="互相垂直的振动的合成">互相垂直的振动的合成</h4>
<p>对两个简谐振动</p>
<p><span class="math display">\[
\begin{array}{l}
x=Acos({ {\omega}t+{\alpha} })\\
y=Bcos({ {\omega}t+{\beta} })\\
\end{array}
\]</span></p>
<p>合成后的轨迹方程为</p>
<p><span class="math display">\[
{\frac{x^2}{A^2} }+{\frac{y^2}{B^2} }-{ {\frac{2xy}{AB} }cos({ {\beta}-{\alpha} })}={sin^2({\beta}-{\alpha})}
\]</span></p>
<ul>
<li>当两分振动相位相同或相反时，方程变为</li>
</ul>
<p><span class="math display">\[
({\frac{x}{A} }{\plusmn}{\frac{y}{B} })^2=0
\]</span></p>
<ul>
<li>当两方程相位差为<span class="math inline">\(\plusmn{\frac{\pi}{2} }\)</span>时</li>
</ul>
<p><span class="math display">\[
{\frac{x^2}{A^2} }+{\frac{y^2}{B^2} }=1
\]</span></p>
<ul>
<li>当两方程频率相差较大，但有整数比关系，其构成有一定规律的稳定的闭合曲线，被称为李萨如图形。</li>
</ul>
<h3 id="其他形式的振动">其他形式的振动</h3>
<h4 id="阻尼振动">阻尼振动</h4>
<blockquote>
<p>阻尼振动损失的能量被以波的形式散失</p>
</blockquote>
<h4 id="受迫振动">受迫振动</h4>
<h4 id="共振">共振</h4>
<h3 id="波动的基本知识">波动的基本知识</h3>
<h4 id="横波和纵波">横波和纵波</h4>
<h3 id="简谐波">简谐波</h3>
<h3 id="波的干涉">波的干涉</h3>
<h3 id="多普勒效应">多普勒效应</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>大学物理</tag>
        <tag>微积分</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理会用到的一些数学知识</title>
    <url>/blog/posts/53564/</url>
    <content><![CDATA[<h1 id="微积分相关的">微积分相关的</h1>
<h1 id="矢量运算">矢量运算</h1>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>大学物理</tag>
        <tag>微积分</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>如何度过期末</title>
    <url>/blog/posts/3855f6eb/</url>
    <content><![CDATA[<h2 id="英语">英语</h2>
<h3 id="平时分">平时分</h3>
<ul>
<li>出勤</li>
<li>回答问题</li>
<li><strong>Pre</strong>：影响印象分，好好做准备和PPT</li>
<li>作业</li>
</ul>
<h3 id="口语考试">口语考试</h3>
<ul>
<li><p>上学期：读课文&amp;无组织讨论</p>
<p>针对单元主题进行讨论，轮流发言，发表观点和意见。建议<strong>选一个老本忘得慢的leader</strong>，及时救场说两句，调动一下现场气氛。会有一个五到十分钟的准备时间。</p></li>
<li><p>下学期：论文+<strong>报告</strong></p>
<p>根据选题写论文，每个人负责一部分。每个论文写完要做报告，介绍论文内容，可能需要卷。</p></li>
</ul>
<h3 id="网课">网课</h3>
<ul>
<li>建议认真搞 可能有用</li>
</ul>
<h3 id="期末考试">期末考试</h3>
<ul>
<li>感受感受听力</li>
<li>选词填空：不需要变形 纯选择</li>
<li>快速阅读：也有可能选多次或者不选；先读题目再读题（老本儿老本儿）</li>
<li>翻译：背答案</li>
</ul>
<h3 id="tips">Tips</h3>
<ul>
<li>刷脸熟</li>
<li>但凡稍微学一点儿。。。</li>
</ul>
<h2 id="java">Java</h2>
<h3 id="读程序">读程序</h3>
<ul>
<li>选择分支</li>
<li>递归</li>
<li>异常</li>
<li>多态</li>
</ul>
<h3 id="写程序">写程序</h3>
<h2 id="高等数学i">高等数学I</h2>
<hr />
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>当代大学牲实录</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言与微服务初步</title>
    <url>/blog/posts/57343/</url>
    <content><![CDATA[<blockquote>
<p>参考资料</br> 《Go语言高并发与微服务实战》；朱荣鑫，黄迪璇，张天；中国铁道出版社</p>
</blockquote>
<h2 id="云原生架构简介">云原生架构简介</h2>
<blockquote>
<p>云原生是在云的基础上提供了各种能力的一种方式</p>
</blockquote>
<h3 id="云计算">云计算</h3>
<p>云计算可以说是云原生的基础。</p>
<p>云计算与计算机相伴相生，可以说计算机的多终端设计，特别是后期通过外部网络访问大型机这种方式粗略描绘出了云计算的基本形式。</p>
<p>但是云计算在2000年前后才真正快速发展起来，这主要是由虚拟化和容器技术的发展所决定。因此，我们可以认为的将云计算分为几个阶段</p>
<ol type="1">
<li>虚拟化的出现</li>
<li>虚拟化在云计算中的应用</li>
<li>容器化的出现</li>
</ol>
<h4 id="虚拟化与云计算">虚拟化与云计算</h4>
<p>1955-1978年，学界确定了云计算所依赖的所有底层技术</p>
<ul>
<li>操作系统，管理物理计算资源</li>
<li>虚拟化技术，将硬件资源分配给多个用户</li>
<li>互联网，及逆行远程接入</li>
</ul>
<p>不过在这之后一段时间，分布式和小型机发展更为显眼。直到2001年，VMware带来X86虚拟化计划。</p>
<p>通常认为，2006年的亚马逊AWS代表云计算的到来。</p>
<p>在此之后，虚拟设备服务商提供计算资源的方式也逐渐出现分化。主要有三种模式</p>
<ol type="1">
<li>IaaS（Infrastructure as a Service），基础设施既是服务</li>
<li>SaaS（Software-as-a-Service），提供开箱即用的软件服务</li>
<li>PaaS（Platform-as-aService），直接提供软件部署平台</li>
</ol>
<p>可以使用一个表格来展示它们之间的差异（1表示提供功能）</p>
<table>
<thead>
<tr class="header">
<th>资源</th>
<th>传统IT</th>
<th>IaaS</th>
<th>SaaS</th>
<th>PaaS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>应用程序</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>数据</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>运行</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>中间件</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>操作系统</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>虚拟化</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>服务器</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>存储</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>网络</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以看得出来，比如阿里云的ECS服务器属于IaaS服务，使用者可以控制的最底层就是操作系统，其实这与使用一台物理机学习、开发差异并不大；一些Serveless服务大概应该归类为PaaS，提供了一个完整的、说走就走的运行环境</p>
</blockquote>
<h4 id="容器化的到来">容器化的到来</h4>
<p>Docker是PaaS的经典开源产品，它带来了一次云计算的巨大革命，是具有里程碑意义的产品。</p>
<p>其实Docker是对虚拟化的一种实现，简单地说，虚拟化在硬件级别分离出不同的操作系统，容器化在操作系统层面分理处不同的硬件程序。容器化避免了虚拟出完整的操作系统，而是在操作系统的基础上进行一层容器化的隔离。</p>
<p>至于如何编排一台设备上的Docker、乃至众多物理机组成的容器集群就需要Kubernates这种容器编排工具。</p>
<p>如今，PaaS领域完全是Kubernates+Docker的天下。</p>
<h3 id="云原生">云原生</h3>
<h4 id="云原生究竟是什么">云原生究竟是什么</h4>
<blockquote>
<p>云原生是云计算的下半场。</p>
</blockquote>
<p>云原生应当先被视作一种<strong>基础设施</strong>，运行在这些设施上的被称为“<strong>云原生应用</strong>”，符合云原生设计哲学的应用架构才叫做“<strong>云原生应用架构</strong>”。</p>
<p>互联网应用，特别是移动互联网的高速发展带来业务快速迭代、团队规模不断扩大降低沟通成本和加快交付速度的新要求，因此，微服务和云原生开始流行。</p>
<p>康威定律是微服务架构的理论基础，将单个服务分解为若干微服务，提高开发效率、迭代速度；云原生通过工具和方法减少更新导致的故障问题，保证服务的高可用。</p>
<p>根据Pivotal公司的概念，云原生应用架构应当有几个主要特征：符合12因素应用、面向微服务架构、敏捷架构、基于API的协作和康脆弱性。同时，他们提出云原生包含四个要点：DevOps、CI/CD、微服务架构和容器化。</p>
<p>云原生实际上是一种理念或者说方法论，云原生应用就是为了在云上运行而开发的应用。</p>
<p>目前，由Pivotal和Google共同建立的云原生计算基金会（Cloud Native Calculating Funcation，CNCF）成为事实上的云原生技术主要推动者</p>
<figure>
<img src="https://jimmysong.io/kubernetes-handbook/images/006tNbRwly1fxmx633ymqj31dp0u0kjn.jpg" alt="CNCF landscape" /><figcaption aria-hidden="true">CNCF landscape</figcaption>
</figure>
<h4 id="云原生的12因素">云原生的12因素</h4>
<p><a href="https://12factor.net">参考链接，12因素</a></p>
<p>方法论和核心思想。这是适用于所有后端程序的思想，主要为构建SaaS应用提出</p>
<ol type="1">
<li>使用声明式格式搭建自动化</li>
<li>降低对操作系统依赖，保持高移植性</li>
<li>适配云平台部署</li>
<li>最小化开发和生产之间的分歧，实现持续部署</li>
<li>在工具架构不发生重大改变的情况下实现扩展</li>
</ol>
<p>编码、部署和运维原则。12因素在三个方便提出具体的要求</p>
<ol type="1">
<li>编码，Codebase、Build、release、run、Dev/prod parity</li>
<li>部署，Dependencies、Config、Process、Backing services、Port binding</li>
<li>运维，Concurrency、Disposability、Logs、Admin process··</li>
</ol>
<h3 id="云原生的基础架构">云原生的基础架构</h3>
<blockquote>
<p>云原生既包含了实现应用云原生化的方法论，也包含了微服务、服务网格、容器、DevOps和声明式API等落地实践的关键性技术</p>
</blockquote>
<ul>
<li><p>微服务 微服务旨在解决单体应用的复杂度问题。</p></li>
<li><p>容器 容器旨在解决微服务架构下大量应用部署问题。 容器技术具体涉及到运行时和编排技术两个层面，一个负责实现对具体应用的管理，另一个负责对大量应用进行维护。</p></li>
<li><p>服务网格 Service Mesh主要实现了对应用的网络、IO操作的分离，进一步使应用专注于自身业务。</p></li>
<li><p>DevOps DevOps旨在增加开发者和运维者之间的沟通，包含三个部分：开发、测试和运维。 DevOps的一个重要特点是持续性，持续集成、持续测试、持续交付和持续部署，能够有效缩短开发周期、增加部署频率。</p></li>
</ul>
<h4 id="关于cicd">关于CI/CD</h4>
<p>CI/CD的具体内涵曾困扰了笔者许久。简单的说，传统应用开发的流程是比较完整、笨拙的，先完成所有开发然后测试、部署上线，CI/CD鼓励持续集成（开发完一部分就提上单元测试）、持续测试（集成测试结束就进入测试环境内测试）、持续部署（测试通过直接部署上线）。</p>
<p>其中“持续”两个字主要体现在这样的工作流程会使用CI/CD工具来代替人工管理。举个例子<a href="#refer-anchor-1"><sup>1</sup></a></p>
<figure>
<img src="https://pica.zhimg.com/80/c5c8e6f40c7c133e22402c00bb7e1a25_1440w.jpg?source=1940ef5c" alt="持续集成" /><figcaption aria-hidden="true">持续集成</figcaption>
</figure>
<p>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p>
<figure>
<img src="https://pic3.zhimg.com/80/db7198e3c39e4656e18efcb4bd1b20b1_1440w.jpg?source=1940ef5c" alt="持续交付" /><figcaption aria-hidden="true">持续交付</figcaption>
</figure>
<p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。</p>
<figure>
<img src="https://pica.zhimg.com/80/f96f19e4d567aad5006d841963a86e41_1440w.jpg?source=1940ef5c" alt="持续部署" /><figcaption aria-hidden="true">持续部署</figcaption>
</figure>
<p>持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。</p>
<h2 id="微服务概述">微服务概述</h2>
<h3 id="常见系统架构">常见系统架构</h3>
<h4 id="单体架构">单体架构</h4>
<p>传统Web开发通常将所有功能打包成一个jar或war包运行，缺点在于开发、拓展难度很大，而且不支持多语言技术栈。</p>
<h4 id="垂直分层架构">垂直分层架构</h4>
<p>垂直架构将单体应用根据功能模块层级进行划分，各层之间通常使用网络接口通信。</p>
<p>MVC就是典型的分层模式。</p>
<h4 id="soa面向服务架构">SOA面向服务架构</h4>
<p>垂直架构进一步拓展，会出现被多个服务同时依赖的单个服务，而且服务之间的沟通会变的异常繁多和复杂。</p>
<p>SOA架构做的最重要的一件事就是将功能模块抽象为服务，并保证服务的通用性，这使得一个服务可以同时向多个项目、多个团队乃至多个公司同时提供服务。在具体实现过程中，公司内通常会使用ESB企业服务总线进行沟通，同时提供一个服务管理基础架构（Service Management Infrastructure）进行服务的审核、列表、日志扽功能。</p>
<p>通常SOA架构被大公司拿来构建稳定、通用的大型公共API服务。</p>
<h4 id="微服务架构">微服务架构</h4>
<p>简单来说，微服务架构相比SOA架构更关注单个服务的自洽性。</p>
<p>对于SOA服务架构来讲，很多应用是要依靠其他应用和一个ESB企业服务总线才能工作，共同构成一个完整的应用；微服务架构则希望这些应用自身就能独立运行。</p>
<p>因此，微服务架构更加轻量化，着重于分散管理、代码再利用与自动化执行。</p>
<figure>
<img src="https://www.dtstack.com/wp-content/uploads/2021/07/111.jpg" alt="sda" /><figcaption aria-hidden="true">sda</figcaption>
</figure>
<h4 id="云原生架构">云原生架构</h4>
<h3 id="常见微服务框架">常见微服务框架</h3>
<h4 id="spring-cloud">Spring Cloud</h4>
<h4 id="dubbo">Dubbo</h4>
<h4 id="go-kit与go-micro">Go kit与Go Micro</h4>
<h3 id="微服务设计六大原则">微服务设计六大原则</h3>
<ol type="1">
<li>高内聚低耦合</li>
<li>高度自治</li>
<li>以业务为中心</li>
<li>弹性设计</li>
<li>日志与监控</li>
<li>自动化</li>
</ol>
<h3 id="领域驱动设计">领域驱动设计</h3>
<h2 id="参考">参考</h2>
<div id="refer-anchor-1">

</div>
<ul>
<li>[1] <a href="https://www.zhihu.com/question/23444990/answer/89426003">如何理解持续集成、持续交付、持续部署？ - yumminhuang的回答 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓原生开发</title>
    <url>/blog/posts/ff1d1c47/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>开源工具收藏</title>
    <url>/blog/posts/15209/</url>
    <content><![CDATA[<h2 id="开发工具">开发工具</h2>
<h3 id="正则表达式">正则表达式</h3>
<h4 id="regex-vis">Regex-vis</h4>
<blockquote>
<p>github</p>
<p><a href="https://github.com/Bowen7/regex-vis" class="uri">https://github.com/Bowen7/regex-vis</a></p>
<p>介绍</p>
<p><a href="https://www.bowencodes.com/post/regex-vis" class="uri">https://www.bowencodes.com/post/regex-vis</a></p>
</blockquote>
<p>regex-vis.com 是一个辅助学习、编写和验证正则的工具。它不仅能对正则进行可视化展示，而且提供可视编辑正则的能力</p>
<p>简单来说，你输入一个正则表达式后，会生成它的可视化图形。然后可以点选或框选图形中的单个或多个节点，再在右侧操作面板对其进行操作，具体操作取决于节点的类型，比如在其右侧插入空节点、为节点编组、为节点增加量词等</p>
<p><a href="https://regex-vis.com/" class="uri">https://regex-vis.com/</a></p>
<h3 id="低代码">低代码</h3>
<h4 id="tooljet">ToolJet</h4>
<blockquote>
<p>github</p>
<p><a href="https://github.com/ToolJet/ToolJet" class="uri">https://github.com/ToolJet/ToolJet</a></p>
<p>官网</p>
<p><a href="https://tooljet.com" class="uri">https://tooljet.com</a></p>
</blockquote>
<h3 id="网络">网络</h3>
<h4 id="httpie">httpie</h4>
<blockquote>
<p><a href="https://github.com/httpie/httpie">GitHub</a></p>
</blockquote>
<p>一个命令行 HTTP 客户端，支持 JSON、自定义颜色、会话、下载、插件等特性。它为测试、调试和与 API 和 HTTP 服务器交互而设计的，其中 <code>http</code> 和 <code>https</code> 命令允许创建和发送任意的 HTTP 请求。</p>
<h4 id="proxyman">Proxyman</h4>
<blockquote>
<p><a href="https://proxyman.io/" class="uri">https://proxyman.io/</a> <a href="https://mp.weixin.qq.com/s/r1EA2e2Lep5uHuhjvNYqow" class="uri">https://mp.weixin.qq.com/s/r1EA2e2Lep5uHuhjvNYqow</a></p>
</blockquote>
<p>作为 Mac 上一款较为知名的 HTTP/HTTPS 网络调试工具，Proxyman 拥有多重请求过滤、SSL 代理、断点调试、注释添加等多种功能，并内置了脚本运行、请求变更记录溯源等多款使用工具。</p>
<h3 id="数据处理">数据处理</h3>
<h4 id="json-visio">JSON visio</h4>
<blockquote>
<p><a href="https://github.com/AykutSarac/jsonvisio.com">GitHub</a></p>
</blockquote>
<p>JSON Visio，一个开源的 JSON 数据可视化工具，可通过图表节点，完美呈现 JSON 数据间的结构关系与详情。</p>
<h4 id="dasel">Dasel</h4>
<blockquote>
<p>github:</p>
<p><a href="https://github.com/TomWright/dasel" class="uri">https://github.com/TomWright/dasel</a></p>
</blockquote>
<p>Dasel，一个比较实用的 JSON 命令行工具，可通过类似链式语法的方式，对 JSON、YAML、CSV 等文件进行增删改查、转换等操作。</p>
<h4 id="form-create">Form Create</h4>
<blockquote>
<p>GitHub：</p>
<p><a href="https://github.com/xaboy/form-create" class="uri">https://github.com/xaboy/form-create</a></p>
</blockquote>
<p>基于Json数据自动生成的表单，可具备动态渲染、数据收集、验证和提交功能等功能。另外还内置了 20 种常用表单组件和自定义组件，再复杂的表单都可以轻松搞定。</p>
<h4 id="data-station">Data Station</h4>
<blockquote>
<p><a href="https://github.com/multiprocessio/datastation" class="uri">https://github.com/multiprocessio/datastation</a></p>
<p><a href="https://github.com/multiprocessio/dsq" class="uri">https://github.com/multiprocessio/dsq</a></p>
</blockquote>
<p>DataStation，是一款面向开发者的开源数据 IDE。</p>
<p>简单来说，就是可通过 SQL 语句，快速查询 JSON、CSV、Excel、日志记录库等文件中的数据，并为之创建可视化图表。</p>
<p>此外，作者还提供了命令行工具：DSQ，除了数据查询外，还支持多个文件合并查询，不同格式的数据源文件转化（比如将 CSV 转为 JSON）等功能。</p>
<h3 id="小型框架">小型框架</h3>
<h4 id="文本编辑框架lexical">文本编辑框架Lexical</h4>
<blockquote>
<p><a href="https://github.com/facebook/lexical" class="uri">https://github.com/facebook/lexical</a></p>
</blockquote>
<p>一个可扩展的 JavaScript 网页文本编辑器框架，旨在提供可靠性、可访问性和高性能的文本编辑服务。你可以将它当作你的网页文本编辑器，通过 <a href="https://lexical.dev/" class="uri">https://lexical.dev/</a> 在线体验它的特性。</p>
<h4 id="实体映射工具类mapstruct">实体映射工具类MapStruct</h4>
<blockquote>
<p><a href="http://blog.csdn.net/qq122516902" class="uri">http://blog.csdn.net/qq122516902</a></p>
</blockquote>
<p><code>MapStruct</code>可以用于辅助制作<code>DTO</code>。它承担了由实体类构建<code>DTO</code>对象的过程，可以省去一系列冗杂的<code>setter/getter</code>调用。</p>
<h2 id="ai与机器学习">AI与机器学习</h2>
<h3 id="语音相关">语音相关</h3>
<h4 id="语音模型库paddlespeech">语音模型库PaddleSpeech</h4>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/DrIQx0LNJmKbHDFZphW6wQ" class="uri">https://mp.weixin.qq.com/s/DrIQx0LNJmKbHDFZphW6wQ</a> <a href="https://github.com/PaddlePaddle/PaddleSpeech">GitHub</a></p>
</blockquote>
<p>该项目为开发者提供了语音识别、语音合成、声纹识别、声音分类等多种语音处理能力，代码全部开源，各类服务一键部署，并附带保姆级教学文档，让开发者轻松搞定产业级应用。</p>
<h2 id="日常">日常</h2>
<h3 id="ppt">PPT</h3>
<h4 id="sli.dev">Sli.dev</h4>
<blockquote>
<p>Github</p>
<p><a href="https://github.com/slidevjs/slidev" class="uri">https://github.com/slidevjs/slidev</a></p>
</blockquote>
<p>Slidev (slide + dev, <code>/slʌɪdɪv/</code>) 是<strong>基于 Web 的幻灯片制作和演示工具</strong>。它旨在让开发者专注在 Markdown 中编写内容，同时拥有支持 HTML 和 Vue 组件的能力，并且能够呈现像素级完美的布局，还在你的演讲稿中内置了互动的演示样例。</p>
<p>它使用了功能丰富的 markdown 文件来生成精美的幻灯片，具有即时重载的体验。它还拥有很多内置的集成功能，如实时编码、导出 PDF、演讲录制等。由于 Slidev 是由 web 驱动的，因此你可以使用它进行任何操作 —— 具有无限的可能性。</p>
<h3 id="写作">写作</h3>
<h4 id="论文资料检索">论文资料检索</h4>
<h4 id="简历相关的仓库">简历相关的仓库</h4>
<h4 id="mermaid用markdown画图">mermaid——用markdown画图</h4>
<h3 id="文件操作">文件操作</h3>
<h4 id="fd">fd</h4>
<blockquote>
<p><a href="https://github.com/sharkdp/fd" class="uri">https://github.com/sharkdp/fd</a></p>
</blockquote>
<p>fd 是一个命令行工具，提供了多种方便的选项进行文件的搜索，而且默认是彩色输出。项目本身是由 Rust 语言编写的，作为系统级编程语言 Rust 拥有媲美 C++ 的运行速度，那 fd 的速度自然也不在话下，更优秀的是，它提供了强大功能方便用户按照各种条件进行搜索。</p>
<h2 id="带劲的骚东西">带劲的骚东西</h2>
<h3 id="操作系统">操作系统</h3>
<h3 id="小游戏">小游戏</h3>
<h4 id="马里奥">马里奥</h4>
<blockquote>
<p><a href="https://github.com/a-little-org-called-mario/a-little-game-called-mario" class="uri">https://github.com/a-little-org-called-mario/a-little-game-called-mario</a></p>
</blockquote>
<h3 id="dddd">dddd</h3>
<ul>
<li><a href="https://github.com/casual-silva/NewsCrawl">TLNewsSpider-舆情信息获取</a></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分</title>
    <url>/blog/posts/c6a6fb5e/</url>
    <content><![CDATA[<h1 id="概览">概览</h1>
<h2 id="一元函数和多元函数">一元函数和多元函数</h2>
<p>微积分讨论的一大基本问题就是函数的极限、微分（导数）和积分</p>
<p>从一元函数拓展到多元函数时会有一些有趣的概念，这里可以列出一个表格对比一下</p>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>一元函数</th>
<th>多元函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>极限</td>
<td>只能从两个方向逼近</td>
<td>可以有无数种方式逼近</td>
</tr>
<tr class="even">
<td>微分（导数）</td>
<td>可导就是微分</td>
<td>偏导</br>全微分</br>方向导数</br>梯度</td>
</tr>
<tr class="odd">
<td>积分</td>
<td>不定积分</br>定积分</td>
<td>二重、三重积分</br>曲线积分（还是一元函数积分）</br>曲面积分</td>
</tr>
</tbody>
</table>
<h2 id="向量和空间代数">向量和空间代数</h2>
<p>提供了多元函数的直观印象。</p>
<h3 id="向量">向量</h3>
<h4 id="向量的内积">向量的内积</h4>
<p>不妨先考虑一下如何证明（说到底还是投影）</p>
<blockquote>
<p>根据@李天意Providence的解释，能够被拆分并运算的量和运算，就是所谓的“线性”，也就构成了向量内积和线性代数的基础前提。</p>
</blockquote>
<p>向量<span class="math inline">\(\mathbb{a}\)</span>在向量<span class="math inline">\(\mathbb{b}\)</span>上的正交分解，其实就是施密特正交化</p>
<p><span class="math display">\[
\begin{array}{l}
{\mathbb{a_1} }={\frac{ {\mathbb{a} }{\cdot}{\mathbb{b} } }{ {\mathbb{b} }{\cdot}{\mathbb{b} } } }\\
{\mathbb{a_2} }={\mathbb{a} }-{\mathbb{a_1} }
\end{array}
\]</span></p>
<p>也就是分解出来两个相互垂直的向量。</p>
<blockquote>
<p>向量内积也可以体现梯度和方向导数的关系</p>
</blockquote>
<h4 id="向量的外积">向量的外积</h4>
<p>向量外积的方向描述了转轴的方向。</p>
<p>对于手头的两个直线的标准式，二者联立意味着以他俩为方向向量的两个平面相交，此时，二者作为法向量的叉乘结果就是这个交线的方向向量。</p>
<h4 id="空间曲线和曲面">空间曲线和曲面</h4>
<blockquote>
<p>至少掌握写出旋转曲面的方程的能力</p>
</blockquote>
<p>求旋转曲面时，旋转轴不变，其余轴（如沿x轴旋转，原曲线在xOy平面）的<span class="math inline">\(y\)</span>改写为<span class="math inline">\({\plusmn}\sqrt{ {y^2}+{z^2} }\)</span></p>
<h2 id="多元函数微分学">多元函数微分学</h2>
<h3 id="极限">极限</h3>
<p>逼近方式的不同会导致不同的极限值。</p>
<blockquote>
<p>基本只会出现<span class="math inline">\({\lim}{\frac{0}{0} }\)</span>类型的极限，而且不建议使用洛必达硬干，合理运用等价无穷小、分子分母有理化等变形即可。</p>
</blockquote>
<p>可以按照下面的顺序来考虑处理方法</p>
<ol type="1">
<li>代入</li>
<li>分子分母有理化</li>
<li>等价无穷小代换</li>
<li>指定变量的逼近方式（常用<span class="math inline">\(y=kx\)</span>和<span class="math inline">\(y=kx^2\)</span>的方式）</li>
</ol>
<h3 id="偏导数">偏导数</h3>
<p><span class="math display">\[
{\frac{\partial{z} }{\partial{x} } },{\quad}{\frac{\partial{z} }{\partial{y} } }
\]</span></p>
<p>偏导数连续是最高级的条件，偏导数连续则函数是可微的，可微则存在偏导数且函数连续。</p>
<h3 id="全微分">全微分</h3>
<p><span class="math display">\[
dz={\frac{\partial{z} }{\partial{x} }dx}+{\frac{\partial{z} }{\partial{y} }dy}
\]</span></p>
<h3 id="方向导数">方向导数</h3>
<p><span class="math display">\[
{\frac{\partial{z} }{\partial{l} } }={\frac{\partial{z} }{\partial{x} }{cos{\theta} } }+{\frac{\partial{z} }{\partial{y} }{sin{\theta} } }
\]</span></p>
<h3 id="梯度">梯度</h3>
<p><span class="math display">\[
({\frac{\partial{z} }{\partial{x} } },{\frac{\partial{z} }{\partial{y} } })
\]</span></p>
<h2 id="重积分">重积分</h2>
<h3 id="积分的基本技巧">积分的基本技巧</h3>
<ul>
<li>第一类换元（凑微分、凑常数）</li>
<li>第二类换元</li>
<li>分部积分（反对幂三指，分离不同类型的函数）</li>
</ul>
<h3 id="二重积分">二重积分</h3>
<p>二重积分变成二次积分。</p>
<p>借助极坐标求二重积分。</p>
<p><span class="math display">\[
\begin{align}
\iint\limits_{D}{f(x,y)}{\mathrm{d}x\mathrm{d}y} &amp; = \int_{a}^{b}{\mathrm{d}x}\int_{\phi_1(x)}^{\phi_2(x)}{f(x,y)}{\mathrm{d}y}\\
\iint\limits_{D}{f(x,y)}{\mathrm{d}\sigma} &amp; =  \iint\limits_{D}{f({r\cos{\theta} },r\sin{\theta})}{r\mathrm{d}r\mathrm{d}\theta}
\end{align}
\]</span></p>
<h3 id="三重积分">三重积分</h3>
<p>投影代替想象空间，非投影轴保证有两个约束作为上下底。</p>
<h2 id="曲线积分和曲面积分">曲线积分和曲面积分</h2>
<h2 id="无穷级数">无穷级数</h2>
<h1 id="无穷级数-1">无穷级数</h1>
<h2 id="常数项级数的概念和性质">常数项级数的概念和性质</h2>
<h3 id="基本概念">基本概念</h3>
<blockquote>
<p>无穷级数是由计算的需求产生的</p>
</blockquote>
<ul>
<li><p>(常数项)(无穷)级数的定义，注意无穷级数的记法<span class="math inline">\(\sum^{\infty}_{i=1}{u_i}\)</span>，其中<span class="math inline">\(u_n\)</span>被称为通项或一般项</p>
<blockquote>
<p>这个定义是不可以计算的，因为无法实现无穷多项的相加，这里继续引入逼近的思想</p>
</blockquote></li>
<li><p>定义级数的前n项和<span class="math inline">\(S_n=\sum^{n}_{i=1}{u_i}\)</span>，称为级数的部分和，由此得到部分和数列</p></li>
<li><p>对于上面定义的部分和，如果<span class="math inline">\(\lim_{n\rightarrow\infty}{S_n}=S\)</span>，那么成这个级数是收敛的，否则是发散的</p></li>
<li><p>级数收敛时，定义<span class="math inline">\(r_n=S-S_n\)</span>为级数第n项后的余项，定义误差为余项的绝对值</p></li>
</ul>
<h3 id="性质">性质</h3>
<ul>
<li><p>对收敛级数<span class="math inline">\(\sum^{\infty}_{i=1}{u_n}=S\)</span>，有<span class="math inline">\(\sum^{\infty}_{i=1}{ku_n}=k\sum^{\infty}_{i=1}{u_n}=kS\)</span></p></li>
<li><p>两个收敛级数，可以逐项相加或逐项相减</p></li>
<li><p>若原级数收敛，对各项按原来的次序，任意分组加括号后，所形成的新技术收敛且级数的和不变</p>
<blockquote>
<p>该命题的逆不为真</p>
</blockquote>
<blockquote>
<p>以上是对级数之间运算的性质的讨论</p>
</blockquote></li>
<li><p>如果加括号后的级数发散，原级数一定也发散</p></li>
<li><p>级数的每一项同时乘一个非零常数，其敛散性不变</p></li>
<li><p>级数的无穷多项同时去掉或添加有限项，级数的敛散性不变；若原技术收敛，有可能改变级数的和</p></li>
<li><p>改变级数的有限项，级数的敛散性不变</p>
<blockquote>
<p>以上是几个对级数敛散性性质的讨论</p>
</blockquote></li>
<li><p>（级数收敛的必要条件）如级数收敛，则<span class="math inline">\(\lim_{n\rightarrow\infty}{u_n}=0\)</span></p></li>
<li><p>（级数发散的充要条件）若<span class="math inline">\(\lim_{n\rightarrow\infty}{u_n}\neq0\)</span>，原级数发散</p></li>
</ul>
<h3 id="常见级数">常见级数</h3>
<h4 id="几何等比级数">几何/等比级数</h4>
<ul>
<li><p>几何级数：</p></li>
<li><p>当<span class="math inline">\(q\lt{|1|}\)</span>，级数收敛，<span class="math inline">\(S={ {a}\over{1-q} }\)</span></p></li>
</ul>
<h4 id="调和级数">调和级数</h4>
<h4 id="p-级数">p-级数</h4>
<ul>
<li>通项：<span class="math inline">\({1}\over{n^p}\)</span></li>
<li>当<span class="math inline">\(p\le1\)</span>时发散，<span class="math inline">\(p\gt1\)</span>时收敛</li>
</ul>
<h4 id="莱布尼茨级数">莱布尼茨级数</h4>
<h2 id="审敛法">审敛法</h2>
<p>审敛法就是为了方便讨论函数的敛散性，收敛函数的和的一系列方法</p>
<h3 id="正项级数">正项级数</h3>
<p>每项均非负的级数被称为正项级数，其部分和数列是一个单调增加的数列</p>
<h4 id="基本定理">基本定理</h4>
<ul>
<li>正项级数收敛的充要条件是其部分和数列有界</li>
</ul>
<h4 id="比较审敛法">比较审敛法</h4>
<ul>
<li>级数的每个通项小于某个收敛级数的对应通项，那么这个收敛收敛；同理。。。</li>
<li>根据上面的性质，若从某一项开始，有<span class="math inline">\({u_n}\le{k{v_n} }\)</span>，且<span class="math inline">\(\sum^{\infty}_{i=1}{v_i}\)</span>收敛，那么<span class="math inline">\({\sum^{\infty}_{i=1}{u_i} }\)</span>收敛；同理。。。</li>
<li>进一步利用p-级数，可以特殊化上一个推论</li>
</ul>
<blockquote>
<p>比较判别法的特点是要已知若干级数的敛散性。一般来说，我们可以<strong>选择p-级数或者几何级数作为“标准函数”</strong></p>
</blockquote>
<h4 id="比较审敛法的极限形式">比较审敛法的极限形式</h4>
<ul>
<li>假设<span class="math inline">\(\lim_{n\rightarrow\infty}{ {u_n}\over{v_n} }=l\)</span>，有
<ul>
<li><span class="math inline">\(l=0\)</span>，若<span class="math inline">\(v_n\)</span>收敛，则<span class="math inline">\(u_n\)</span>收敛；若<span class="math inline">\(v_n\)</span>发散，则<span class="math inline">\(u_n\)</span>发散</li>
<li><span class="math inline">\(0\lt{l}\lt{+\infty}\)</span>，则二者有相同的敛散性</li>
<li><span class="math inline">\(l=+\infty\)</span>，若<span class="math inline">\(v_n\)</span>发散，则<span class="math inline">\(u_n\)</span>发散</li>
</ul></li>
<li>常常会涉及到学极限时接触到的<strong>等价0</strong></li>
</ul>
<h4 id="柯西判别法根值审敛法">柯西判别法/根值审敛法</h4>
<ul>
<li>设<span class="math inline">\(\lim_{n\rightarrow\infty}{\sqrt[n]{u_n} }=\rho\)</span>，有
<ul>
<li><span class="math inline">\(0\le\rho\lt1\)</span>，级数收敛</li>
<li><span class="math inline">\(\rho=1\)</span>级数可能收敛也可能发散</li>
<li><span class="math inline">\(1\lt\rho\le+\infty\)</span>，级数发散</li>
</ul></li>
<li>对于含<span class="math inline">\((-1)^n\)</span>项的一些级数，可能会使用到<strong>夹逼定理</strong></li>
</ul>
<h4 id="达朗贝尔判别法比值审敛法">达朗贝尔判别法/比值审敛法</h4>
<ul>
<li>设<span class="math inline">\({\lim_{n\rightarrow\infty}{ {u_{n+1} }\over{u_n} } }=\rho\)</span>，有
<ul>
<li><span class="math inline">\(0\le\rho\lt1\)</span>，级数收敛</li>
<li><span class="math inline">\(\rho=1\)</span>级数可能收敛也可能发散</li>
<li><span class="math inline">\(1\lt\rho\le+\infty\)</span>，级数发散</li>
</ul></li>
</ul>
<h3 id="交错级数">交错级数</h3>
<p>正负项<strong>间隔出现</strong>的级数，称为交错级数</p>
<h4 id="莱布尼茨准则交错级数审敛法">莱布尼茨准则/交错级数审敛法</h4>
<ul>
<li>对于任意交错级数，如果满足 <span class="math display">\[
(1){ {u_{n+1} }\le{u_n} };(2)\lim_{n\rightarrow\infty}{u_n}=0
\]</span> 那么这个交错级数收敛，级数的和<span class="math inline">\(S\le{|u_1|}\)</span>，余项<span class="math inline">\({|r_n|}\le{u_{n+1} }\)</span></li>
</ul>
<h3 id="任意项级数">任意项级数</h3>
<p>正负项<strong>任意出现</strong>的级数，称为任意项级数</p>
<p>任意项级数的收敛性可以通过正正项级数判断，交错级数可以看做是特殊的任意项级数</p>
<p>对于任意项级数<span class="math inline">\(\sum_{i=1}^{\infty}{u_n}\)</span>，如果<span class="math inline">\(\sum_{i=1}^{\infty}{|u_n|}\)</span>收敛，则称这个级数<strong>是绝对收敛</strong>；如果原级数收敛，但其正项级数不收敛，称其为<strong>条件收敛</strong></p>
<p>不难证明级数的绝对收敛一定有收敛</p>
<p>一般来说，正项级数的收敛不能导出原级数的收敛，但比值审敛法、根值审敛法可以导出这个结论</p>
<h4 id="绝对收敛级数">绝对收敛级数</h4>
<p>对于绝对收敛级数，有两条性质</p>
<ul>
<li><p>绝对收敛级数的各项任意交换后所得到的级数也绝对收敛</p></li>
<li><p>对于两个绝对收敛级数，记他们的和分别为<span class="math inline">\(S\)</span>和<span class="math inline">\(\sigma\)</span>，他们的柯西乘积也绝对收敛，和为<span class="math inline">\(S·\sigma\)</span></p></li>
</ul>
<h2 id="反常积分审敛法和tau函数">反常积分审敛法和<span class="math inline">\(\tau\)</span>函数</h2>
<h3 id="反常积分审敛法">反常积分审敛法</h3>
<blockquote>
<p>反常积分的审敛法算是来自上面的审敛法，其证明也是基于比值审敛法</p>
</blockquote>
<p>对于反常积分敛散性的判断，我们原本是通过求其原函数，再根据定义判断极限是否存在来进行判断</p>
<p>利用上面给出的审敛法，可以更方便的判断敛散性</p>
<ul>
<li>（反常积分的比较审敛原理）是对前面比较审敛法的推广，内容基本一样</li>
<li>如果反常积分的函数的绝对值积分收敛，则该积分绝对收敛</li>
</ul>
<h4 id="比较审敛法1">比较审敛法1</h4>
<p>利用函数<span class="math inline">\(g(x)={ {1}\over{x^p} }\)</span>来进行判断</p>
<ul>
<li>当存在<span class="math inline">\(M&gt;0,p&gt;1\)</span>使得<span class="math inline">\(f(x)\leq{Mg(x)}\)</span>，反常积分收敛</li>
<li>存在常数<span class="math inline">\(N\)</span>，使得<span class="math inline">\(f(x)\geq{Ng(x)}\)</span>，反常积分发散</li>
</ul>
<p>相应的还有极限审敛法</p>
<ul>
<li>如果<span class="math inline">\(p\gt{1}\)</span>，<span class="math inline">\(\lim_{x\rightarrow{\infty} }{x^pf(x)}\)</span>存在，不定积分收敛</li>
<li>如果<span class="math inline">\(\lim_{x\rightarrow{\infty} }xf(x)=d\gt{0}\)</span>，反常积分发散</li>
</ul>
<h4 id="比较审敛法2">比较审敛法2</h4>
<p>利用函数<span class="math inline">\(g(x)={1\over{(x-a)^q} }\)</span>来进行判断</p>
<ul>
<li>当存在<span class="math inline">\(M\gt{0},q\lt{1}\)</span>，有<span class="math inline">\(f(x)\leq{Mg(x)}\)</span>，反常积分收敛</li>
<li>存在<span class="math inline">\(N\gt{0},q\geq{1}\)</span>，使得<span class="math inline">\(f(x)\geq{Ng(x)}\)</span>，反常积分发散</li>
</ul>
<p>同样也有其对应的极限审敛法</p>
<ul>
<li>对于<span class="math inline">\(0\lt{1}\lt{1}\)</span>，<span class="math inline">\(\lim_{x\rightarrow{\infty} }{x^pf(x)}\)</span>存在，不定积分收敛</li>
<li>如果<span class="math inline">\(q\geq{1}\)</span>,<span class="math inline">\(\lim_{x\rightarrow{\infty} }xf(x)=d\gt{0}\)</span>，反常积分发散</li>
</ul>
<h3 id="tau-函数"><span class="math inline">\(\tau-\)</span>函数</h3>
<p><span class="math inline">\(\tau-\)</span>函数是个特殊的函数，具有以下一系列性质和结论</p>
<ul>
<li>递推关系: <span class="math inline">\(\Tau(s+1)=s\Tau(s)\)</span></li>
<li>阶乘推广: <span class="math inline">\(\Tau(n+1)=n!\)</span></li>
<li>在<span class="math inline">\(x\rightarrow{0^+}\)</span>时，极限为<span class="math inline">\(+\infty\)</span></li>
<li>余元公式：<span class="math inline">\(\Tau(x)\Tau(1-s)={ {\pi}\over{sin(\pi s)} }\)</span> 代入<span class="math inline">\(s=1\over{2}\)</span>,可以得到<span class="math inline">\(\Tau(1/2)=\sqrt{\pi}\)</span></li>
<li>变换形式</li>
</ul>
<h2 id="幂级数和函数展开">幂级数和函数展开</h2>
<h3 id="函数项级数和收敛域">函数项级数和收敛域</h3>
<blockquote>
<p>常数项级数和函数项级数可以看做是平等的级数分类，函数项级数在给定自变量的取值后退化到常数项级数，二者大多数性质是相似或相同的</p>
</blockquote>
<p>在讨论幂函数之前，首先要定义函数项级数</p>
<p>对于级数<span class="math inline">\(\sum_{i=1}^{\infty}{u_n(x)}\)</span>，他的每一项都是函数<span class="math inline">\(u_n(x)\)</span>，我们称其为函数项级数。区别于常数项级数，他的每一项都是函数。</p>
<ul>
<li>当给定<span class="math inline">\(x=x_0\)</span>，如果上面的级数收敛，我们称<span class="math inline">\(x_0\)</span>为函数项级数的收敛点，所有收敛点的集合称为收敛域；相应的，还有发散点和发散域</li>
<li>同样可以定义函数项级数的和函数和余项</li>
</ul>
<h3 id="幂级数及其运算和性质">幂级数及其运算和性质</h3>
<p>幂级数是最简单的函数项级数</p>
<ul>
<li>（阿贝尔定理）如果一个幂级数在点<span class="math inline">\(x_0\)</span>处收敛，那么对于<span class="math inline">\(|x|\lt{x_0}\)</span>都收敛，<span class="math inline">\(|x|{x_0}\)</span>都发散</li>
<li>进一步，对于任意幂函数我们可以通过平移进行移动，由此可以确定一个非负数<span class="math inline">\(R\)</span>，使得<span class="math inline">\(R\)</span>以内的级数都绝对收敛，<span class="math inline">\(R\)</span>以外都发散，<span class="math inline">\(x=R\)</span>不确定；称$R为收敛半径</li>
<li>有时级数只含有偶数或级数次幂，这是不能直接使用阿贝尔定理，但可以根据证明阿贝尔定理的方法使用比值审敛法证明</li>
</ul>
<h4 id="四则运算">四则运算</h4>
<p>对于幂级数，满足以下三个运算</p>
<ul>
<li>加减法，需要注意其和级数的收敛半径为较小的一个</li>
<li>乘法，即柯西乘积</li>
<li>除法，收敛半径不确定</li>
</ul>
<p>对和函数逐项求导、逐项积分后，其断点处的敛散性可能改变</p>
<p>若端点处收敛，那么和函数在端点处单侧可导</p>
<h3 id="泰勒级数">泰勒级数</h3>
<p>根据泰勒定理，不难理解泰勒级数及其余项的定义</p>
<ul>
<li>函数可以展开成泰勒级数的充分必要条件是余项趋近于0</li>
</ul>
<p>同样可以定义麦克劳林级数</p>
<h3 id="函数展开成幂级数">函数展开成幂级数</h3>
<blockquote>
<p>虽然说是幂级数，但都是展开成泰勒、或者麦克劳林级数更为方便</p>
</blockquote>
<h4 id="直接展开">直接展开</h4>
<ul>
<li>写出函数的泰勒展开形式</li>
<li>验证收敛条件</li>
</ul>
<h4 id="逐项积分求导">逐项积分、求导</h4>
<ul>
<li>寻找目标函数的相关函数进行拼凑</li>
</ul>
<h4 id="变量代换">变量代换</h4>
<ul>
<li>不必多说</li>
</ul>
<h3 id="幂级数的应用">幂级数的应用</h3>
<h4 id="求解近似值">求解近似值</h4>
<p>首先要定义误差</p>
<ul>
<li>截断误差</li>
<li>舍入误差</li>
</ul>
<p>以下有一些可能会经常见到的级数</p>
<ul>
<li>用来构造自然对数表的级数</li>
</ul>
<p><span class="math display">\[
ln{ {1+x}\over{1-x} } = {2({x+{ {x^3\over{3} }+{ {x^5\over{5} }+{\dots} } } })}
\]</span></p>
<ul>
<li><p>用来求解三角函数的级数</p></li>
<li><p>求解非初等函数的积分</p></li>
</ul>
<h2 id="傅里叶级数和正余弦级数">傅里叶级数和正余弦级数</h2>
<blockquote>
<p>傅立叶级数和泰勒级数的目的是一样的，都是旨在将函数向级数变换进行计算。但是泰勒级数的条件太强，他需要函数n阶可导连续，这对很多函数来讲并不现实。傅里叶级数只需要函数连续，具有有限个第一类间断点或极值点即可</p>
</blockquote>
<h3 id="三角函数系及其正交性">三角函数系及其正交性</h3>
<p>对三角级数进行<span class="math inline">\(\omega t=x\)</span>这个代换后，可以得到傅里叶级数的一般形式</p>
<ul>
<li>三角函数系具有互异函数乘积的积分为零，相同函数积分不为零的特征，我们称为正交</li>
<li>对于同名函数的乘积的积分，除1是<span class="math inline">\(2\pi\)</span>外，都是<span class="math inline">\(\pi\)</span></li>
</ul>
<h3 id="函数展开成傅里叶级数">函数展开成傅里叶级数</h3>
<p>要得到傅里叶级数的系数，只需要进行三个运算分别去求三个系数</p>
<ol type="1">
<li>对等式两边在<span class="math inline">\((-\pi,\pi)\)</span>积分，即可得到<span class="math inline">\(a_0\)</span></li>
<li>使用<span class="math inline">\(cos(x)\)</span>去乘后积分，利用正交性消去多余项即可得到<span class="math inline">\(a_n\)</span></li>
<li>同理可以求得<span class="math inline">\(b_n\)</span></li>
</ol>
<blockquote>
<p>这一组公式的名称为优菈-傅里叶公式</p>
</blockquote>
<p>对于间断点，我们定义他们的值是两侧极限的算数平均值</p>
<p>由此可见，傅里叶级数对函数的要求相对泰勒级数很弱，大部分函数都可以展开为傅里叶级数</p>
<p>而且与幂级数不同，傅里叶级数具有全局逼近的性质，幂级数则是在一个点的收敛半径内逼近</p>
<p>但是傅里叶级数还是有一些约束，首先他展开的定义域是<span class="math inline">\((-\pi,\pi)\)</span>，对于一些函数，我们需要进行延拓拓展他们的定义域；对于另一些函数，我们需要进行伸缩使其周期变为<span class="math inline">\(2\pi\)</span>；对于奇函数、偶函数，他们还可以进一步简化为正弦级数和余弦级数；最后，傅里叶级数可以推广到复数</p>
<h3 id="奇函数和偶函数的傅里叶级数">奇函数和偶函数的傅里叶级数</h3>
<ul>
<li>傅里叶正弦级数：也就是奇函数的展开，只包含系数为<span class="math inline">\(b_n\)</span>的项，</li>
<li>傅里叶余弦级数：也就是偶函数的展开，包含<span class="math inline">\(a_0\)</span>和<span class="math inline">\(b_n\)</span></li>
</ul>
<h3 id="函数的延拓">函数的延拓</h3>
<p>当函数定义域只有一半，不足以支持傅里叶级数时，我们可以对其进行<strong>延拓</strong></p>
<ul>
<li>偶延拓：</li>
<li>奇延拓</li>
</ul>
<blockquote>
<p>个人感觉延拓提供的只是一个理论基础，对函数展开时的条件进行补足。实际计算时并没有涉及到延拓出的部分函数，因此我们可以略去延拓后的函数直接进行系数的计算，但在计算系数时确实进行了延拓才使得函数可以展开成傅里叶级数</p>
</blockquote>
<h3 id="函数的放缩">函数的放缩</h3>
<p>对于周期不是<span class="math inline">\(2\pi\)</span>的函数，可以进行代换<span class="math inline">\(x={ {\pi}\over{l} }t\)</span>，进行一些推导后可以得到在区间<span class="math inline">\((-l,l)\)</span>上傅里叶级数的展开公式</p>
<h2 id="小节和体会">小节和体会</h2>
<p>级数除了解决计算，比如将函数展开到幂级数、傅里叶级数；积分原函数不易求出时展开成级数再计算，似乎没有get到太多用处 ——2022.4.23</p>
<h1 id="向量代数与空间解析几何">向量代数与空间解析几何</h1>
<h2 id="向量和空间">向量和空间</h2>
<h2 id="空间的平面和直线">空间的平面和直线</h2>
<h2 id="空间的曲面和曲线">空间的曲面和曲线</h2>
<h1 id="多元函数微分学-1">多元函数微分学</h1>
<blockquote>
<p>对多元函数的讨论一方面是对一元函数的延伸推广，但确实要多出很多内容；但是对于多元函数，只需研究二元函数即可对更多元的函数使用相同方法研究</p>
</blockquote>
<h2 id="多元函数及其上的极限和连续">多元函数及其上的极限和连续</h2>
<h3 id="讨论范围的推广">讨论范围的推广</h3>
<blockquote>
<p>这里的工作主要是由点、区间推广到点、区域</p>
</blockquote>
<ul>
<li>可以很形象的定义<strong>平面点集</strong></li>
<li>定义平面上的<strong>邻域</strong><span class="math inline">\(U(P_0,\epsilon)\)</span>和<strong>去心邻域</strong><span class="math inline">\(U({P_0})\)</span>。除了变成圆形，这和一元函数的定义没有理解上的差异</li>
<li>定义存在一个完全在集合内的点为<strong>内点</strong>，和全部为内点的集合为<strong>开集</strong> &gt; 对于内点的邻域，只要给定一个足够小的<span class="math inline">\(\epsilon\)</span>，一定可以保证其全在集合内，因此我们称其为内点</li>
<li>对应的，对于邻域内既有集合内的点、也有集合外的点的点为<strong>边界点</strong>，边界点的集合为<strong>边界</strong></li>
<li>对于给定的任意一个<span class="math inline">\(\delta\)</span>，总存在<span class="math inline">\(U(P_0,\delta)\)</span>内的点在集合<span class="math inline">\(E\)</span>内，那么<span class="math inline">\(P_0\)</span>是集合<span class="math inline">\(E\)</span>的一个<strong>聚点</strong></li>
<li>如果一个点集的每一点都是集合的内点，且任意两点之间均可以用一条折线连接起来，这个集合被称为<strong>（开）区域</strong>；区域中所有的点，及其边界的并集为<strong>闭区域</strong></li>
<li>如果一个点集能够被包含在原点的一个邻域内，称它为<strong>有界</strong>的，否则就是<strong>无界</strong>的</li>
</ul>
<h3 id="二元函数和多元函数">二元函数和多元函数</h3>
<h3 id="极限-1">极限</h3>
<ul>
<li>对于二元函数，点与点之间的逼近方式很多（一元函数只有左右两种情况）</li>
<li>往往会使用到不等式进行放缩</li>
<li>二元/多元函数极限继承了一元极限的运算性质、等价无穷小</li>
</ul>
<h3 id="连续性">连续性</h3>
<ul>
<li>连续的二元函数在空间中是一张连续曲面</li>
<li>一般来说，二元函数的间断点可以形成一张曲面</li>
<li>二元函数连续性继承了一元函数的一系列性质，比如
<ul>
<li>连续函数加减乘除运算后仍连续</li>
<li>连续函数复合后仍连续</li>
<li>最值定理</li>
<li>介值定理</li>
</ul></li>
<li>常量及两个以上变量基本初等函数，经过有限次四则运算和复合得到的函数被称为多元初等函数</li>
</ul>
<h2 id="偏导数全导数和全微分">偏导数、全导数和全微分</h2>
<h3 id="偏导数-1">偏导数</h3>
<p>由一个自变量变化，其他自变量固定不变而产生的变化率被称为多元函数的偏导数</p>
<ul>
<li><p>如果函数对每个自变量的偏导数都存在，才称这个函数的偏导数存在</p></li>
<li><p>函数存在偏导数不一定连续</p>
<blockquote>
<p>这是因为偏导数只描述了函数在一个方向上的变化率</p>
</blockquote></li>
<li><p>对偏导数求导得到的是二阶偏导数，同理定义二阶以上的为高阶偏导数</p></li>
<li><p>求导过程中，针对不同变量求偏导得到的称为混合偏导数</p></li>
<li><p>如果一个函数的两个混合偏导数连续，他们他们必定相等</p>
<blockquote>
<p>也就是说，对于混合偏导数，先求哪个自变量的导数效果相同</p>
</blockquote></li>
</ul>
<h3 id="全微分-1">全微分</h3>
<ul>
<li>定义函数对于增量<span class="math inline">\(\Delta{x},\Delta{y}\)</span>的全增量为<span class="math inline">\(\Delta{z}\)</span></li>
<li>对全增量进行线性情况下的的化简，我们定义全微分<span class="math inline">\(dS=y\Delta{x}+x\Delta{y}\)</span></li>
<li>对于一般的二元连续函数，存在<span class="math inline">\(A,B\)</span>有<span class="math inline">\(\Delta{z}=A\Delta{x}+B\Delta{y}+o{(\rho)}\)</span>，全微分<span class="math inline">\(d{f({x_0},y_0)}=d|_{(x_0,y_0)}=A\Delta{x}+B\Delta{y}\)</span>,此时显然有<span class="math inline">\(\Delta{z}=dz+o{(\rho)}\)</span></li>
<li>存在全微分必定连续</li>
<li>（可微的必要条件）存在全微分必定存在偏导数</li>
<li>（可微的充分条件）偏导数存在，且连续，一定可微</li>
</ul>
<h3 id="多元复合函数微分">多元复合函数微分</h3>
<blockquote>
<p>除链式法则和形式不变性之外，多元复合函数由于复合函数形式的差异，带来了一些讨论</p>
</blockquote>
<ul>
<li>多元复合函数的链式法则</li>
<li>多元复合函数微分的形式不变性</li>
</ul>
<p>由于复合函数的变量可能是一个或多个，有几种可能出现的情况</p>
<ul>
<li>中间变量都是关于相同变量的一元函数，对于函数<span class="math inline">\(z=f(u,v)\)</span>，<span class="math inline">\(u=\phi(x),v=\Phi(x)\)</span>，那么复合函数z有</li>
</ul>
<p><span class="math display">\[
{ {dz}\over{dx} }={ {\partial{z}\over{\partial{u} } } }·{ {\mathrm{d}u}\over{\mathrm{d}x} }+{ {\partial{z}\over{\partial{v} } } }·{ {\mathrm{d}v}\over{\mathrm{d}x} }
\]</span></p>
<blockquote>
<p>我们在这里称<span class="math inline">\({ {dz}\over{dx} }\)</span>为z对x的全导数</p>
</blockquote>
<ul>
<li>中间变量只有一个</li>
</ul>
<p><span class="math display">\[
{ {\partial{z} }\over{\partial{x} } }={ {dz}\over{du} }·{ {\partial{u} }\over{\partial{x} } }
\]</span></p>
<blockquote>
<p>到这里可以看粗来全微分记号就是针对多元函数使用的，其实没有必要区分这几种情况，只是书写格式的不同，其道理是一样的</p>
</blockquote>
<ul>
<li>中间变量既有一元也有多元函数</li>
</ul>
<h2 id="多元函数的几何意义">多元函数的几何意义</h2>
<p>对二元函数来讲，由于空间的扩张，切线、法线推广成了切线、法平面和法线、切平面</p>
<blockquote>
<p>感觉基本都是计算，有时间cv一下公式，摆</p>
</blockquote>
<p>其中，切平面充分反映了在其他自变量增加时，某个自变量的变化的含义</p>
<h3 id="切线和法平面">切线和法平面</h3>
<h3 id="法线和切平面">法线和切平面</h3>
<h2 id="多元函数的极值与最值">多元函数的极值与最值</h2>
<h3 id="多元函数的极值">多元函数的极值</h3>
<ul>
<li>可微函数取极值的必要条件是当函数的各个偏导数均为<span class="math inline">\(0\)</span>。满足条件的点被称为驻点。</li>
<li>令<span class="math inline">\(A={f^{&#39;&#39;}_{xx} },B={f^{&#39;&#39;}_{xy} },C={f^{&#39;&#39;}_{yy} }\)</span>，如果
<ol type="1">
<li><span class="math inline">\(B^2-AC{\lt}0,且A{\gt}0\)</span>，则<span class="math inline">\(f({x_0},{y_0})\)</span>为极小值。</li>
<li><span class="math inline">\(B^2-AC{\lt}0,且A{\lt}0\)</span>，则<span class="math inline">\(f({x_0},{y_0})\)</span>为极大值。</li>
<li>若<span class="math inline">\(B^2-AC{\gt}0\)</span>，则<span class="math inline">\(f({x_0},{y_0})\)</span>不是极值。</li>
<li>若<span class="math inline">\(B^2-AC=0\)</span>，则不确定<span class="math inline">\(f({x_0},{y_0})\)</span>是否为极值。</li>
</ol></li>
</ul>
<h3 id="拉格朗日乘数法">拉格朗日乘数法</h3>
<ul>
<li>前面所说的极值都是无条件极值，当有<span class="math inline">\({\phi{(x,y)} }=0\)</span>约束时，<span class="math inline">\(f(x,y)\)</span>的极值被称为约束极值，此时常使用拉格朗日乘数法解决。</li>
</ul>
<p>拉格朗日乘数法使用很简单，大概只需要套用以下几步</p>
<ol type="1">
<li><p>构造函数<span class="math inline">\(L=L(x,y,{\lambda})=f(x,y)+{\lambda}{\phi(x,y)}\)</span>。问题转化为求<span class="math inline">\(L\)</span>的无约束变量</p></li>
<li><p>只需保证 <span class="math display">\[
\begin{array}{l}
{L^{&#39;}_x}={f^{&#39;}_{x}(x,y)}+{\lambda}{\phi^{&#39;}_{x}(x,y)}=0\\
{L^{&#39;}_y}={f^{&#39;}_{y}(x,y)}+{\lambda}{\phi^{&#39;}_{y}(x,y)}=0\\
{L^{&#39;}_{\lambda} }={\phi(x,y)}=0
\end{array}
\]</span></p></li>
<li><p>验证是否为极值点</p></li>
</ol>
<h3 id="最值">最值</h3>
<ul>
<li>简单来讲，拿所有极值和端点处的函数值比较即可得到最值，这与一元函数是相似的。</li>
</ul>
<h2 id="拉普拉斯方程">拉普拉斯方程</h2>
<p>拉普拉斯方程是指偏微分方程 <span class="math display">\[
{\frac{\partial^2{u} }{\partial{x^2} } }+{\frac{\partial^2{u} }{\partial{y^2} } }=0
\]</span></p>
<h1 id="重积分-1">重积分</h1>
<h2 id="二重积分的概念和性质">二重积分的概念和性质</h2>
<h2 id="计算二重积分">计算二重积分</h2>
<h2 id="计算三重积分">计算三重积分</h2>
<h3 id="直角坐标系下的累次积分">直角坐标系下的累次积分</h3>
<h3 id="柱面坐标系下的累次积分">柱面坐标系下的累次积分</h3>
<p>柱面坐标系下，体积元素 <span class="math display">\[
dV=rd{\theta}drdz=rdrd{\theta}dz
\]</span></p>
<h3 id="球面坐标系下的累次积分">球面坐标系下的累次积分</h3>
<p>取<span class="math inline">\(\theta\)</span>为与<span class="math inline">\(x\)</span>轴的夹角，<span class="math inline">\(\phi\)</span>为与<span class="math inline">\(z\)</span>轴的夹角，有 <span class="math display">\[
x=r{sin(\phi)}{cos(\theta)},y=r{sin(\phi)}{sin(\theta)},z=r{cos(\phi)}
\]</span> 体积元素为 <span class="math display">\[
dV={rd{\phi} }{\cdot}{r{sin{\phi} }d{\theta} }{\cdot}{dr}={r^2sin{\phi} }drd{\phi}d{\theta}
\]</span></p>
<h3 id="重积分的一般变量代换">重积分的一般变量代换</h3>
<h1 id="曲线曲面积分">曲线/曲面积分</h1>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
        <tag>小习题儿</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模知识</title>
    <url>/blog/posts/50307/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>保持每天更新一类模型的理论基础，第二天更新相关算法的代码实现</p>
<p>参考材料</p>
<ul>
<li>《数学模型（第五版）》（简称小蓝）</li>
</ul>
<h1 id="优化模型">优化模型</h1>
<h2 id="简单规划">简单规划</h2>
<h3 id="效用最大化模型小蓝2.3和3.5">效用最大化模型（小蓝2.3和3.5）</h3>
<blockquote>
<p><strong>引入效用函数和效用最大化原理</strong></p>
</blockquote>
<h4 id="效用函数">效用函数</h4>
<ul>
<li><p>为了研究人在生理、心理上的满足程度，我们引入<strong>效用</strong>这个概念。并定义数量<span class="math inline">\(x\)</span>的商品所带来的效用为效用函数<span class="math inline">\(U(x)\)</span></p>
<blockquote>
<p>这里的U来源于Utility function，因此该函数有时被称作utils</p>
</blockquote></li>
<li><p>通常的，效用函数满足如下形式 <span class="math display">\[
U(x)=ax^{\alpha},a&gt;0,0&lt;\alpha&lt;1
\]</span></p></li>
<li><p>定义效用函数的变化率<span class="math inline">\({dU(x)\over{dx} }\)</span>为<strong>边际效用</strong></p></li>
<li><p>显然边际效用递减且恒正，有<span class="math inline">\({ {d^2U}\over{dx^2} }&lt;0\)</span></p></li>
</ul>
<h4 id="无差别曲线">无差别曲线</h4>
<ul>
<li><p>无差别曲线对效用的形象表示，在同一条无差别曲线上效用是相同的</p></li>
<li><p>对于多元函数的无差别曲线，如 <span class="math display">\[
已知无差别曲线U(x,y)=u是y=y(x)的隐函数，其中U(x,y)=ax^{\alpha}y^{\beta}\\
y=y(x)={({ {u}\over{a} })^{1\over\beta} }x^{-{ {\alpha}\over{\beta} } }
\]</span></p></li>
<li><p>所有无差别曲线都是下降且下凸的</p></li>
<li><p>定义边际替代率</p></li>
</ul>
<h4 id="效用最大化原理">效用最大化原理</h4>
<ul>
<li><p>建立效用最大化模型 <span class="math display">\[
已知效用函数U(x,y)，两种商品的单价p1,p2，消费者准备付出的钱为s，则满足以下条件\\
maxU(x,y)\\
s.t.   p_1x+p_2y=s\\
\]</span></p>
<blockquote>
<p>其中<span class="math inline">\(s.t.\)</span>是受约束于(subject to)的符号</p>
</blockquote></li>
<li><p>引入拉格朗日算子，略去求解过程</p></li>
<li><p>效用最大化原理：当两种商品的边际效用之比等于其价格之比时，效用函数达到最大</p></li>
</ul>
<h4 id="应用">应用</h4>
<ul>
<li>首先确定价格和边际效用</li>
</ul>
<ol type="1">
<li><p>构造模式函数直接求解</p>
<p>套用效用函数的模型建立函数并求解，得到最优解条件</p>
<p>需要注意的是，这里认为函数是连续的</p></li>
<li><p>先确定边际效应绘制表格求解</p>
<p>这种思路假定了边际效用是离散的</p></li>
</ol>
<h3 id="样本-总体估计的五种模型小蓝2.5">样本-总体估计的五种模型（小蓝2.5）</h3>
<blockquote>
<ul>
<li><strong>综合来看，平均间隔模型是最优解</strong></li>
<li><strong>引入了数值模拟来评估模型</strong></li>
</ul>
</blockquote>
<h4 id="平均值模型">平均值模型</h4>
<h4 id="中位数模型">中位数模型</h4>
<h4 id="两段间隔对称模型">两段间隔对称模型</h4>
<h4 id="区间均分模型">区间均分模型</h4>
<h4 id="平均间隔模型">平均间隔模型</h4>
<ul>
<li><p>将所有样本排列，得到n个间隔并取其平均值</p></li>
<li><p>认为<span class="math inline">\(x-x_n\)</span>与所求相等，即 <span class="math display">\[
{x-x_n}={1\over{n} }{[(x_1-1)+\sum_{i=2}^{n}{(x_i-x_{i-1}-1)}]}={1\over{n} }{(x_n-n)}
\]</span></p></li>
<li><p>由此可得 <span class="math display">\[
x={({1+{ {1}\over{n} } })x_n-1}
\]</span></p></li>
</ul>
<blockquote>
<p>详见小蓝p29</p>
</blockquote>
<h4 id="数值模拟">数值模拟</h4>
<ul>
<li>数值模拟是指给定一个总体,从中抽取若千样本，根据 5 个模型分别对样本进行计算，估计总体，将估计结果与给定总体作对比，根据各个模型的估计值与总体比较的结果做出评价</li>
<li>对于总体11，2，…，×,设定x=1000,从总体中随机取口=10个数为一个样本，对每个样本用5 个模型分别估计 ，（估计值记作<span class="math inline">\(x\)</span>），如此取m=200 个样本，计算由m个样本估计 的a的平均值和标准差，以及平均值与真值(1-000)间的误差.为了进一步分析m 个样本估计的文的分布情况，可以面出文的直方图</li>
</ul>
<h3 id="核威慑模型小蓝2.8">核威慑模型（小蓝2.8）</h3>
<h3 id="存贮模型小蓝3.1">存贮模型（小蓝3.1）</h3>
<h3 id="扔铅球小蓝3.4">扔铅球（小蓝3.4）</h3>
<h2 id="线性规划">线性规划</h2>
<h3 id="线性规划模型的基本形式">线性规划模型的基本形式</h3>
<ul>
<li>线性规划问题是求一个多元一次多项式的最值问题，其中的每一个未知数都有一定条件约束</li>
<li>从几何上讲，这就是高中所学的线性规划问题，他们的求解方法是一样的，只是扩展到了N维空间</li>
<li>典型例子有：
<ol type="1">
<li>指派问题（小蓝4.3）</li>
</ol></li>
</ul>
<h3 id="相关算法">相关算法</h3>
<h4 id="interior-point内点法">interior-point（内点法）</h4>
<ul>
<li>是一种求解线性规划或非线性凸优化问题的算法</li>
</ul>
<h2 id="非线性规划">非线性规划</h2>
<h3 id="罚函数法小红7.2.3">罚函数法（小红7.2.3）</h3>
<ul>
<li>又称序列无约束最小化技术（Sequential Unconstrained Minimization Techinique,SUMT）</li>
<li>利用问题中的约束函数做出适当的罚函数，由此构造出带参数的增广目标函数，把问题转化为无约束非线性规划问题</li>
<li>有外罚函数法和内罚函数法两种</li>
</ul>
<h4 id="数学推导">数学推导</h4>
<p><span class="math display">\[
现在有如下条件：\\
min \ f(x)\\
s.t. \\
{ {g_i(x) \le 0 \ (i=1,...,r)} }\\
{ {h_i(x) \ge 0 \ (i=1,...,s)} }\\
{ {k_i(x) = 0 \ (i=1,...,t)} }\\
取一个充分大的数M&gt;0，构造函数\\
P(x,M)=f(x)+M{\sum_{i=1}^{r}max({g_i(x),0})}-M{\sum_{i=1}^{s}max({h_i(x),0})}+M{\sum_{i=1}^{t}|k_i(x)|}\\
{或者\quad }P(x,M)=f(x)+{\mathbf{M}_1 max({\mathbf{G}(x),0})}+{\mathbf{M}_2 min({\mathbf{H}(x),0})}+{ {\mathbf{M}_3}||{\mathbf{K}(x)}||}\\
{其中，}{\mathbf{G}(x)=\left[\begin{matrix}g_1(x) \\\vdots  \\g_r(x) \end{matrix}\right]}{;}
{\mathbf{H}(x)=\left[\begin{matrix}h_1(x) \\\vdots  \\g_s(x) \end{matrix}\right]}{;}
{\mathbf{K}(x)=\left[\begin{matrix}k_1(x) \\\vdots  \\k_t(x) \end{matrix}\right]}{;}\\
{\mathbf{M_1} },{\mathbf{M_2} },{\mathbf{M_3} }为适当的行向量\\
\]</span></p>
<h2 id="整数规划">整数规划</h2>
<ul>
<li>对于很多情况下，我们限制解必须为整数，这种条件下就满足整数规划</li>
</ul>
<blockquote>
<p>对于有这种形式 <span class="math display">\[
x_1,x_2,x_3 = 0 或 \ge n
\]</span> 的问题，通常有三种解决思路</p>
<ol type="1">
<li><p>化为多个LP子模型</p></li>
<li><p>引入0-1变量，化为整数规划 <span class="math display">\[
80y_1 \le x_1 \le My_1,M为一个很大的数，y_1 \in {0,1} 
\]</span></p></li>
<li><p>化为非线性规划</p></li>
</ol>
</blockquote>
<h2 id="目标规划">目标规划</h2>
<h3 id="目标规划的一个例子小蓝4.4">目标规划的一个例子（小蓝4.4）</h3>
<ul>
<li><p>在这个问题中，选课的目标函数和学分条件全都是线性条件</p></li>
<li><p>但是某些课程需要先修课程，这里进行了处理</p>
<blockquote>
<p>对于课程x和y，记0为未选1为选修，其中x是y的先导课程，可以采用这种方式表述 <span class="math display">\[
x \le y
\]</span></p>
</blockquote></li>
<li><p>在第二小问中，优化的目标有两个，这种多余两个优化目标的问题被称为<strong>多目标规划</strong></p>
<p>我们将规划的目标函数视作一个向量使用<span class="math inline">\(V-min(x_1,x_2,...,x_n)\)</span>来表示</p></li>
</ul>
<h2 id="多目标规划">多目标规划</h2>
<h2 id="动态规划">动态规划</h2>
<h1 id="评价模型">评价模型</h1>
<p>层次分析法，模糊综合评价，熵值法，TOPSIS法，数据包络分析，秩和比法，灰色关联分析</p>
<h1 id="预测模型">预测模型</h1>
<p>回归拟合，灰色预测，马尔可夫预测，时间序列分析</p>
<h1 id="统计模型">统计模型</h1>
<p>分布检验，均值T检验，方差分析，协方差分析，相关分析，卡方检验，秩和检验，回归分析，Logistic回归，聚类分析，判别分析，关联分析</p>
<h1 id="动态模型">动态模型</h1>
<p>微分方程模型，差分方程模型，元胞自动机，排队论，蒙特卡罗随机模拟</p>
<h1 id="图论模型">图论模型</h1>
<p>最短路径，最小生成树，最小费用最大流，指派问题，旅行商问题</p>
<h1 id="智能算法">智能算法</h1>
<p>模拟退火，神经网络，遗传算法，蚁群算法，粒子群算法，支持向量机，决策树，随机森林</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>又一个小小的idea</title>
    <url>/blog/posts/64819/</url>
    <content><![CDATA[<h2 id="idea">IDEA</h2>
<p>最近学的东西有点杂，乱七八糟的。</p>
<p>学一门新技术的时候其实要考虑的问题蛮多的，第一是这门技术有没有前置要求，就像学Android开发多少得有点儿Java基础；第二是这门技术对其他技术依赖性强不强，开发说实话和数学关系不是太大，学物理就不一样了；再者，有时候一个技术的大迭代会带来一堆技术的升级。</p>
<p>这些问题。。和包管理器要解决的是不是有点像？</p>
<p>或许可以设计一个技术，或者知识的包管理器，嗯由于知识的更新或许也需要引入版本管理。</p>
<p>大概就是这样一个想法吧。</p>
<h2 id="产品文档">产品文档</h2>
<blockquote>
<p>做一次自己的产品经理？</p>
</blockquote>
<h3 id="需求分析">需求分析</h3>
<h3 id="产品逻辑">产品逻辑</h3>
<h3 id="交互设计">交互设计</h3>
<h2 id="技术选型">技术选型</h2>
<h3 id="技术架构">技术架构</h3>
<h3 id="多端开发和定位">多端开发和定位</h3>
<h3 id="接口设计">接口设计</h3>
<h3 id="引入一点智能算法">引入一点智能算法</h3>
<blockquote>
<p>类似。。学习路线设计？智能补全（指提醒学习前置知识？</p>
</blockquote>
<h3 id="数据库的设计">数据库的设计</h3>
<blockquote>
<p>要管理这些内容，组织一个又一个“环境”对数据库压力还是蛮大的</p>
</blockquote>
<h2 id="展望">展望</h2>
<h3 id="简历生成系统">简历生成系统</h3>
<blockquote>
<p>这大概是没什么难度的。</p>
</blockquote>
<h3 id="接入职场需求">接入职场需求</h3>
<blockquote>
<p>都是要打工的啦。。为了岗位学习有错吗？没有。</br> 如果可以的话，希望AI能帮助将HR的“需求黑化”转译成更直接的说法，生成知识簇</p>
</blockquote>
<h3 id="教育系统">教育系统</h3>
<blockquote>
<p>既然可以接入职场的需求设计知识簇，为什么不可以优化国内安排的一塌糊涂的本科课程呢？对一些课程的安排提前，该深入的深入就好，这大概也和智能算法有些关系了</p>
</blockquote>
<h3 id="用户设计的知识簇">用户设计的知识簇</h3>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/blog/posts/29139/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<h3 id="different-types">Different Types</h3>
<ul>
<li>Regression: outputs a scalar.</li>
<li>Classification: outputs one of the <strong>given options</strong>.</li>
<li>Structed Learning: create something with structure(e.g.document, image).</li>
</ul>
<p>通常来说, 机器学习的方法包括<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="多种多样的机器学习 - 莫烦 - 莫烦Python
">[6]</span></a></sup></p>
<ul>
<li>Supervised Learning</li>
<li>Unsupervised Learning</li>
<li>Semi-supervised Learning</li>
<li>Reinforcement Learning</li>
<li>Genetic Algorithm, 遗传算法</li>
</ul>
<h3 id="steps-to-train-a-model">Steps to Train a Model</h3>
<p>Training:</p>
<ol type="1">
<li>Function with unknown parameters(based on domain knowledge, to guess a model with some parameters), also called <strong>Model</strong></li>
<li>Define loss(a function inside of the model) from training data to describe how good a set of value is.</li>
<li>Optimization(e.g. Gradient Descent).</li>
</ol>
<blockquote>
<p>习惯上，从数学的角度，我们取weight为w表示具有权重内涵的参数，bias为b表示具有偏移内涵的参数。</p>
</blockquote>
<p>Loss function <span class="math inline">\(L\)</span> such as</p>
<ul>
<li>Mean Absolute Error(MAE),  <span class="math inline">\(e=|y-\hat{y}|\)</span></li>
<li>Mean Square Error(MSE),  <span class="math inline">\(e=(y-\hat{y})^2\)</span></li>
</ul>
<p>将<span class="math inline">\(L\)</span>绘制成图，称为Erroe Surface.</p>
<p>训练时自行指定的参数称为hyperparameter.</p>
<h3 id="sigmoid-function">Sigmoid Function</h3>
<p>线性方程能拟合的非常有限，这个问题有一个专有的称呼，Model Bias。</p>
<p><strong>All Piecewise Linear Curve = Constant + Sum of a Set of Polylines.</strong></p>
<p>Sigmoid Function可以构造各种曲线或模拟折线</p>
<p><span class="math display">\[
y=c{\frac{1}{1+e^{-(b+w{x_1})} } }=c{\cdot}sigmoid(b+w{x_1})
\]</span></p>
<ul>
<li>w: 改变形状，或者说倾斜程度</li>
<li>b: 改变水平偏移</li>
<li>c: 改变高度范围</li>
</ul>
<p>讲自变量扩展到<span class="math inline">\(j\)</span>个，这样任何一个曲线可以表示为</p>
<p><span class="math display">\[
y={b_0}+\sum_i{ {c_i}{\cdot}sigmoid({b_i}+{\sum_j{w_{ij}{x_j} } })}
\]</span></p>
<p><span class="math inline">\(\mathbf{x}\)</span> is called <strong>features</strong>; others are called <span class="math inline">\(\mathbf{\theta}\)</span>.</p>
<p>通过引入sigmoid函数可以更好的设计第一步的方程(function with unknown)。</p>
<h3 id="optimization-of-new-model">Optimization of New Model</h3>
<p>目标是通过Loss function <span class="math inline">\(L(\mathbf{\theta})\)</span> 找到一个<span class="math inline">\(\mathbf{\theta^*}={\mathit{arg}{\underset{\mathbf{\theta} }{\mathrm{min} } }L}\)</span></p>
<p>数据集可以分为若干个batch，使用某个batch也可以进行一次update，这样逐一通过每个batch进行一次运算的过程称为epoch。</p>
<h2 id="神经网络简介">神经网络简介</h2>
<h3 id="neural-network">Neural Network</h3>
<h3 id="convolutional-neural-network-cnn">Convolutional Neural Network, CNN</h3>
<h3 id="recurrent-neural-network-rnn">Recurrent Neural Network, RNN</h3>
<h4 id="long-short-term-memory-lstm">Long-short Term Memory, LSTM</h4>
<h3 id="autoencoder">Autoencoder</h3>
<h3 id="generative-adversarial-nets">Generative Adversarial Nets</h3>
<h3 id="transfer-learning">Transfer Learning</h3>
<h2 id="introduction-to-deep-learning">Introduction to Deep Learning</h2>
<h3 id="history-and-models">History and Models</h3>
<ul>
<li>1958: Perceptron</li>
<li>1980: Multi-layer Percrptron，与现在的DNN没啥区别</li>
<li>1986: Backpropagation</li>
<li>2006: RBM initialization</li>
<li>2009: GPU</li>
<li>2011: 引入语音电视</li>
</ul>
<p>所谓的Deep Learning就是指有很多隐藏层的神经网络模型。</p>
<h3 id="backpropagation">Backpropagation</h3>
<p><span class="math display">\[
\frac{\partial{C} }{\partial{\mathbf{w} } }={\frac{\partial{\mathbf{z} } }{\partial{\mathbf{w} } } }\cdot {\frac{\partial{C} }{\partial{\mathbf{z} } } }
\]</span></p>
<p>前半部分就被叫做forward pass，每一个<span class="math inline">\(w\)</span>对<span class="math inline">\(z\)</span>的偏微分值与他的输入相等。</p>
<p>另一个部分被称为backward pass</p>
<p><span class="math display">\[
\begin{array}{l}
  {\frac{\partial{C} }{\partial{z} } }&amp;={\frac{\partial{a} }{\partial{z} } }{\frac{\partial{C} }{\partial{a} } }\\
  {\frac{\partial{a} }{\partial{z} } }&amp;={\sigma}&#39;(z)\\
  {\frac{\partial{C} }{\partial{a} } }&amp;=\sum_i{\frac{\partial{z^{(n)} } }{\partial{a} } }{\frac{\partial{C} }{\partial{z^{(n)} } } }\\
  &amp;=...
\end{array}
\]</span></p>
<h3 id="overfitting">Overfitting</h3>
<p>我们使用的输入数据显然是不完备的，基于不完备信息得出的pattern也自然是不准确的，这种不准确表达出来就是两种，一种是欠拟合, underfitting，另一种是过拟合, overfitting<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="什么是 L1/L2 正则化 (Regularization) - 莫烦的文章 - 知乎
">[3]</span></a></sup>。</p>
<ul>
<li>Underfitting通常是针对训练集，例如我们的预测pattern过于平滑（e.g 直线来拟合多个输入点），也就是模型过于简单，这个通常可以通过引入多项式，或者神经网络等复杂模型来解决。</li>
<li>Overfitting则通常是说训练习得的model对于测试集性能很差，而对训练集性能很好，也就是对训练集是overfitting，有很差的Generalization（泛化能力）。</li>
</ul>
<h3 id="regularization">Regularization</h3>
<p><span class="math display">\[
L=\sum{({\hat{y}^n}-(b+\sum{ {w_i}{x_i} }))^2}\;+\;\lambda\sum{(w_i)^2}
\]</span></p>
<p>目的是为了得到更加平滑的模型。</p>
<p>正规化（regularization)：也就是在loss function中增加一个regularization term来平衡generalization和overfitting，<span class="math inline">\(\lambda\)</span>是正则变量，也是一个hyperparameter，是我们自己来设定的<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="什么是 L1/L2 正则化 (Regularization) - 莫烦的文章 - 知乎
">[3]</span></a></sup>。</p>
<p>有了这个term，我们可以发现，<span class="math inline">\(\lambda\)</span>越大，这个term的权重也越大，那么相应的w参数权重越小，也就是曲线越平滑，极端情况，<span class="math inline">\(\lambda\)</span>很大，那么w的各个参数趋近于0，从而使得pattern接近于一条直线（underfitting）；<span class="math inline">\(\lambda\)</span>越小，整个term的权重也越小，相应的w的权重越大，曲线则越不平滑，极端情况<span class="math inline">\(\lambda=0\)</span>则退化为没有正规化的loss function，从而overfitting。</p>
<blockquote>
<p>lambda这样的hyperparameter的选取通常是得不到数学的保障的，所以为什么很多人将ML的model选取和古代道士炼丹一样（更多的是经验和运气）。当然我们可以plot不同的lambda的选择形成的loss function，从而选择合适的lambda（似乎比道士高不了多少）。</p>
</blockquote>
<h3 id="classification">Classification</h3>
<p>Loss function</p>
<p><span class="math display">\[
L(f)=\sum_n{\delta(f(x^n)\neq{\hat{y} }^n)}
\]</span></p>
<p>Generative model</p>
<p><span class="math display">\[
P(x)=P(x|C_1)P(C_1)+P(x|C_2)P(C_2)+{\dotsb}
\]</span></p>
<p>分类任务可以使用一个Gaussian Distribution <span class="math inline">\(L(\mu,\sum)\)</span>模拟。可以得到</p>
<p><span class="math display">\[
{\mu^*}={\frac{1}{79} }(\sum_{n=1}^{79}{x^n}),\;
{\sum^*}={\frac{1}{79} }{\sum_{n=1}^{79} }({x^n}-{\mu^*})({x^n}-{\mu^*})^T
\]</span></p>
<p>通常对于不同的分类，会选择给所有分类同一个covarience matrix减少参数数量，避免过拟合。</p>
<h3 id="logistic-regression">Logistic Regression</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4248fflsnj213q0tz78i.jpg" alt="image-20220710204333711" /><figcaption aria-hidden="true">image-20220710204333711</figcaption>
</figure>
<p>一般Linear Regression是解决回归问题，而 Logistic Regression是应用于分类问题。Logistic Regression除了可以解决二分类问题外，还可以解决多分类问题<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[机器学习笔记] Logistic Regression与Linear Regression的区别 - 梅森上校 - CSDN
">[5]</span></a></sup>。</p>
<p>采用 Logistic Regression进行多分类的思路是：选取某个分类作为正样本，其他分类作为负样本建立一个二分类模型；以此类推建立多个（有几个分类就建几个）二分类模型；对多个二分类模型的输出值进行大小比较，把样例归为输出值最大的那类<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Linear Regression 与 Logistic Regression的几点不同 - jingyi130705008 - CSDN
">[4]</span></a></sup>。</p>
<h2 id="convolutional-neural-network">Convolutional Neural Network</h2>
<h2 id="模型拟合失败">模型拟合失败</h2>
<h3 id="local-minima-and-saddle-point">Local Minima and Saddle Point</h3>
<p>Local minima和saddle point被称为critical point。</p>
<h4 id="tayler-series-approximation">Tayler Series Approximation</h4>
<p><span class="math display">\[
{L(\theta)}\; \approx \;{L(\theta^*)\,+\,{ {(\theta-\theta^*)^T}g}\,+\,{ {\frac{1}{2} }{(\theta-\theta^*)^T}H{(\theta-\theta^*)} } }
\]</span></p>
<p>实际上，由于训练的模型维度往往非常高，所以并不会经常陷入局部最优的陷阱。</p>
<p>要说起来，卡在Saddle Point的可能性还是有的。</p>
<h3 id="batch-and-momentum">Batch and Momentum</h3>
<h4 id="batch">Batch</h4>
<p>一般称为批次。每次运算后会刷新一次batch，这个过程被称为 shuffle。</p>
<p>合适的batch可以减少每次计算梯度的运算量，并且其期望与计算所有梯度相等，在大训练数据的情况下是十分有效的一种方式。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h439yhzqz5j21p60owgnx.jpg" alt="image-20220711204707803" /><figcaption aria-hidden="true">image-20220711204707803</figcaption>
</figure>
<p>由于GPU具有强大的并行运算能力，所以从左图可以发现一定数量的batch并不会带来运算时间的显著增长；反而是过小的batch会导致更多的update，而update是同步进行的，所以在总时间消耗上反而会更长。</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43a1be0drj21sa0tmq5y.jpg" alt="image-20220711204953301" /><figcaption aria-hidden="true">image-20220711204953301</figcaption>
</figure>
<p>这个比较反映出大batch有更低的精确度，这或许与陷入局部最优有关。较大的batch相当于添加了一定噪声，这些噪声是有效果带领模型摆脱陷阱的。</p>
<blockquote>
<p>这种噪声类似进化模型里的随机变量。</p>
</blockquote>
<h4 id="momentum">Momentum</h4>
<p>Momentum，动量，算是对梯度下降的改进。</p>
<p>在计算每次参数变化时，引入了上一次变化值作为参数</p>
<p><span class="math display">\[
m^t={\lambda m^{t-1} }-{\eta {g^{t-1} } }
\]</span></p>
<h3 id="auto-learning-rate">Auto Learning Rate</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43adoyljhj20fo0fcdfx.jpg" alt="image-20220711210148269" /><figcaption aria-hidden="true">image-20220711210148269</figcaption>
</figure>
<p>有时候。。会陷入这种摇摆的情况。显然，在Loss越小的情况下，Learning rate就应该越小，不然可能步子迈大了扯着蛋。</p>
<p>可以使用这种形式改进</p>
<p><span class="math display">\[
{\theta^{t+1}_{i} }={\theta^{t}_{i} }-{\frac{\eta}{\sigma^{t}_{i} }{g^{t}_{i} } }
\]</span></p>
<h4 id="root-mean-square">Root Mean Square</h4>
<p><span class="math display">\[
\begin{array}{l}
  {\sigma^{0}_{i} }={\sqrt{({g^{0}_{i})}^2} }\\
  {\sigma^{1}_{i} }={\sqrt{ {\frac{1}{2} }[({g^{0}_{i})^2+({g^{1}_{i} })^2]} } }\\
  {\sigma^{n}_{i} }={\sqrt{ {\frac{1}{n+1} }{\sum_{j=0}^n{(g^{j}_{i})^2 } } } }
\end{array}
\]</span></p>
<h4 id="rmsprop">RMSProp</h4>
<p><span class="math display">\[
{\sigma^{n}_i}=\sqrt{ {\alpha{(\sigma^{n-1}_i)^2} }+{(1-\alpha){(g^{n}_i)^2} } }
\]</span></p>
<h4 id="learning-rate-scheduling">Learning Rate Scheduling</h4>
<p><span class="math display">\[
{\theta^{t+1}_{i} }={\theta^{t}_{i} }-{\frac{\eta^t}{\sigma^{t}_{i} }{g^{t}_{i} } }
\]</span></p>
<ul>
<li>Learning rate decay: 随次数增加 Learning rate 减小</li>
<li>Warm Up: Learning rate increase and then decrease.</li>
</ul>
<h3 id="influence-of-loss-function">Influence of Loss Function</h3>
<p>主要影响分类问题</p>
<h4 id="one-hot-vector">One-hot Vector</h4>
<p>使用 One-hot vector 来表示分类，而不是 <code>1, 2</code> 这样的序号，可以排除数字大小的影响。</p>
<p>此时模型的结构需要加入softmax函数</p>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h43bco6arnj21j00m8q52.jpg" alt="image-20220711213524697" /><figcaption aria-hidden="true">image-20220711213524697</figcaption>
</figure>
<p>此时的 Loss Function，由于 output 是一对 one-hot vector，使用 MSE 计算就显得不太好了。应该使用 cross entropy 计算。</p>
<blockquote>
<p>Minimizing cross entropy is equivalent to maxmizing likelihood.</p>
</blockquote>
<h3 id="summary-of-optimization">Summary of Optimization</h3>
<p>最后的update模型为</p>
<p><span class="math display">\[
{\theta^{t+1}_i}\; =\; {\theta^t_i} - { {\frac{\eta^t}{\sigma^t_i} } {m^t_i} }
\]</span></p>
<ul>
<li><span class="math inline">\(\eta^t\)</span>: Learning rate scheduling.</li>
<li><span class="math inline">\(\sigma^t_i\)</span>: Root mean square of the gradients.</li>
<li><span class="math inline">\(m^t_i\)</span>: Weighted sum of the previous gradients.</li>
</ul>
<h2 id="references">References</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1JK4y1D7Wb?p=2&amp;share_source=copy_web">李宏毅2022机器学习深度学习课程</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/25720278">机器学习之过拟合(overfitting) - 朱涛的文章 - 知乎</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/25707761">什么是 L1/L2 正则化 (Regularization) - 莫烦的文章 - 知乎</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span><a href="http://t.csdn.cn/y8ANf">Linear Regression 与 Logistic Regression的几点不同 - jingyi130705008 - CSDN</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:5" class="footnote-text"><span><a href="http://t.csdn.cn/rHAnh">[机器学习笔记] Logistic Regression与Linear Regression的区别 - 梅森上校 - CSDN</a> <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:6" class="footnote-text"><span><a href="https://mofanpy.com/tutorials/machine-learning/ML-intro/machine-learning/">多种多样的机器学习 - 莫烦 - 莫烦Python</a> <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RL</tag>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>SL</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>概率统计建模方法</title>
    <url>/blog/posts/23003/</url>
    <content><![CDATA[<h2 id="数学知识基础">数学知识基础</h2>
<h3 id="概率论">概率论</h3>
<h4 id="常见概率公式">常见概率公式</h4>
<ol type="1">
<li>条件概率公式<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span></li>
<li>概率乘法公式<span class="math inline">\(P(AB)=P(A)P(B)\)</span></li>
<li>概率加法公式<span class="math inline">\(P(A\cup B)=P(A)+P(B)-P(AB)\)</span></li>
<li>全概率公式 <span class="math display">\[
P(A)=\sum_{k=1}^{\infin}P(A|{B_k})P(B_k)
\]</span></li>
<li>贝叶斯公式（逆概率公式） <span class="math display">\[
P({B_k}|A)=\frac{P(A|{B_k})P(B_k)}{\sum_{k=1}^{\infin}P(A|{B_k})P(B_k)}
\]</span></li>
</ol>
<h3 id="常见概率分布">常见概率分布</h3>
<h4 id="二项分布xbnp">二项分布<span class="math inline">\(X~B(n,p)\)</span></h4>
<p><span class="math display">\[
\begin{array}{l}
  P\{X=k\} = {C_n^k}{p^k}{(1-p)}^{n-k},{\quad}k=0,1,2,{\dotsc},n\\
  EX=np,DX=np(1-p)
\end{array}
\]</span></p>
<p><span class="math inline">\(n=1\)</span>时被称为两点分布或伯努利分布</p>
<h4 id="泊松poisson分布xplambda">泊松（Poisson）分布<span class="math inline">\(X~P(\lambda)\)</span></h4>
<p><span class="math display">\[
\begin{array}{l}
  P\{X=k\} = \frac{ {\lambda}^k{e}^{-\lambda} }{k!},{\quad}k=0,1,2,{\dotsc}\\
  EX=DX=\lambda
\end{array}
\]</span></p>
<blockquote>
<p>常用于研究服务领域中柏松流的分布规律。如单位时间内设备发生故障的次数、公共场所的客流量</p>
</blockquote>
<h4 id="负二项巴斯卡pascal分布">负二项（巴斯卡，Pascal）分布</h4>
<p>设每次实验事件<span class="math inline">\(A\)</span>发生的概率为<span class="math inline">\(p\)</span>，记<span class="math inline">\(A_k\)</span>为<span class="math inline">\(\{事件的第r次发生出现在第k次试验中\}\)</span>，则 <span class="math display">\[
\begin{array}
  P(A_k)=f(k;r,p)={C_{k-1}^{r-1} }{p^r}{q^{k-r} }\\
  记X为直到事件A发生所进行的试验次数，则\\
  P(X=k)={q^{k-1} }p\\
  EX=\frac{1}{p},DX=\frac{q}{p^2}
\end{array}\]</span></p>
<blockquote>
<p>常用语计算产品备用件消耗概率，试验成功或失败概率等。</p>
</blockquote>
<p><span class="math inline">\(r=1\)</span>时即为几何分布（等待分布），具有无记忆性</p>
<h4 id="均匀分布">均匀分布</h4>
<p><span class="math display">\[
X
\]</span></p>
<h4 id="伽马分布">伽马分布</h4>
<blockquote>
<p>计算产品可靠度、失效率应用较广泛</p>
</blockquote>
<h4 id="正态分布">正态分布</h4>
<h2 id="简单示例">简单示例</h2>
<h3 id="传送带">传送带</h3>
<h3 id="航空公司的预定票策略">航空公司的预定票策略</h3>
<h4 id="问题">问题</h4>
<p>在预订票业务中，航空公司为争取客源开展优质服务，预先订票的乘客如果未能按时乘机,可乘坐下一航班或退票而无需附加任何费用若公司限制预订票教量等于飞机容量,由子部分订票乘客不按时来机,致使飞机不满员而利润降低。若公司不限制預订票数量,则持票按时来的乘客数给公司声誉带来损失。公司需要综合考虑经济利益和社会声誉,如何确定预订票数量的最佳限額.</p>
<h4 id="问题分析">问题分析</h4>
<p>公司的经济利益可用机票收入扣除飞行费用和賠偿金后的利润来衡量．社会声誉可用持票按时来乘机、因满员不能走的来客(被挤掉者限制在一定数量为标准．预订票的乘客是否按时前来乘机是一个随机因素,经济利益和社会声誉两个指标都应该在平均意义下衡量.这是两目标优化问題，决策变量是预订票数量的限额。</p>
<h4 id="楧型假设">楧型假设</h4>
<ol type="1">
<li>飞机容量<span class="math inline">\(n\)</span>;飞行费用<span class="math inline">\(r\)</span>(与乘容数量无关)：机票价格<span class="math inline">\(g=\frac{r}{\lambda n}\)</span>，其中<span class="math inline">\(\lambda(\lt 1)\)</span>是利润调节因子，<span class="math inline">\(\lambda\)</span>表示飞机达到60%满员率就不亏本</li>
<li>预订票教量限额<span class="math inline">\(m\gt n\)</span>：每位乘容不按时前来乘机的概率<span class="math inline">\(p\)</span>;"各位来客是否按时前来"相互独立</li>
<li>每位被挤掉者获得的賠偿金为常数<span class="math inline">\(b\)</span></li>
</ol>
<h2 id="马尔可夫链与">马尔可夫链与</h2>
<h3 id="马尔可夫链">马尔可夫链</h3>
<p>三个特点</p>
<ol type="1">
<li>系统在每个时期的状态是随机的。指不知道将来的状态。</li>
<li>从某一时期到下个时期的状态按照一定概率来转移。</li>
<li>下一时期只取决于本时期状态和转移概率。即已知现在，将来与过去无关，也就是无后效性。</li>
</ol>
<h3 id="转移概率矩阵和柯尔莫哥洛夫定理">转移概率矩阵和柯尔莫哥洛夫定理</h3>
<h4 id="柯尔莫哥洛夫-开普曼定理">柯尔莫哥洛夫-开普曼定理</h4>
<p><span class="math display">\[
p_{ij}(n+m)=\sum_{k\in E}{p_{ij}(n)}{p_{kj}(m)}
\]</span></p>
<h4 id="马尔科夫预测模型">马尔科夫预测模型</h4>
<p><span class="math inline">\(P\)</span>是一个转换矩阵，<span class="math inline">\(p^{(0)}\)</span>是初始分布行向量，则</p>
<p><span class="math display">\[
P^{(n)} = {P^{(0)} }{P^n}
\]</span></p>
<h3 id="极限概率分布">极限概率分布</h3>
<p>设<span class="math inline">\(P\)</span>是一个概率转移矩阵，若存在某一正整数<span class="math inline">\(k\)</span>，使<span class="math inline">\(P^k\)</span>的每一元素都为正数，則称<span class="math inline">\(P\)</span>为正则矩阵。</p>
<p>设<span class="math inline">\(P\)</span>是一个概率转移矩阵，若存在行向量<span class="math inline">\(\mathbf{u}\)</span>使得<span class="math inline">\(\mathbf{u}P=\mathbf{u}\)</span>，即<span class="math inline">\(\mathbf{u}\)</span>是<span class="math inline">\(P\)</span>的特征值为<span class="math inline">\(1\)</span>的特征向量,則称<span class="math inline">\(\mathbf{u}\)</span>为<span class="math inline">\(P\)</span>的不动点向量。</p>
<p>若<span class="math inline">\(P^n\)</span>的极限矩阵的每一行向量均等于不动点向量<span class="math inline">\(\mathbf{u}\)</span>，则称对应的马氏链具有遍历性,若不动点向量<span class="math inline">\(\mathbf{u}\)</span>的各分量非负且和为<span class="math inline">\(1\)</span>，则称<span class="math inline">\(\mathbf{u}\)</span>为马氏链的极限分布。</p>
<p>若<span class="math inline">\(P\)</span>是一个马氏链的正则矩阵，則</p>
<ol type="1">
<li><span class="math inline">\(P\)</span>有唯一的不动点向量<span class="math inline">\(\mathbf{u}\)</span>，<span class="math inline">\(\mathbf{u}\)</span>的每个分量为正.</li>
<li><span class="math inline">\(P^n\)</span>的极限短阵的每一行向量均等于不动点向量么</li>
</ol>
<p>设时齐（齐次）马氏链<span class="math inline">\(\{ {X_n},n=1,2,\dotsb,n\}\)</span>的状态空问为<span class="math inline">\(E=\{ {a_1},{a_2},{\dotsb},{a_n}\}\)</span>，<span class="math inline">\(P=p(ij)\)</span>是其一步转移概率矩阵，若存在正整数<span class="math inline">\(m\)</span>，使对任意的<span class="math inline">\(a_i,a_j\in E\)</span>都有<span class="math inline">\({p_{ij}(m)\gt 0,i,j=1,\dotsb,N}\)</span>则此链具有遍历性，且有唯一的极限分布<span class="math inline">\(u={u_1},{u_2},\dotsb,{u_n}\)</span></p>
<h3 id="吸收链">吸收链</h3>
<h2 id="统计推断方法">统计推断方法</h2>
<h3 id="数据预处理">数据预处理</h3>
<blockquote>
<p>利用Matlab Statics Toolbox</p>
</blockquote>
<h4 id="一些数据统计量">一些数据统计量</h4>
<p>平时数据总体分布的统计量</p>
<ul>
<li>平均值</li>
<li>中位数</li>
<li>方差，标准差</li>
<li>极差</li>
</ul>
<p>表示分布情况的统计量</p>
<ul>
<li>标准偏度：一般用<span class="math inline">\(g_1\)</span>表示</li>
<li>标准峰度：一般用<span class="math inline">\(g_2\)</span>表示</li>
</ul>
<blockquote>
<p>正态分布峰度为3，大于3时数据的尾巴会更大</p>
</blockquote>
<h3 id="四个主要的概率分布">四个主要的概率分布</h3>
<p>分别是正态分布、卡方分布、t分布和F分布。</p>
<p>在Matlab中，对于任何一个分布，有五个相关函数</p>
<ul>
<li>概率密度函数(PDF)</li>
<li>分布函数(CDF)</li>
<li>分布函数的反函数(INV)</li>
<li>均值与方差(STAT)</li>
<li>随机数生成(RND)</li>
</ul>
<h3 id="参数估计">参数估计</h3>
<h4 id="矩估计法">矩估计法</h4>
<h4 id="极大似然估计法">极大似然估计法</h4>
<h4 id="衡量估计效果的指标">衡量估计效果的指标</h4>
<ul>
<li>无偏性</li>
<li>有效性</li>
<li>一致性</li>
</ul>
<h3 id="估计模型">估计模型</h3>
<ul>
<li>平均值模型：样本平均值=总体平均值。有偏。</li>
<li>中位数模型：样本中位数=总体中位数。有偏。</li>
<li>极大似然估计：</li>
<li>两端间隔对称模型：</li>
<li>区间均分模型：</li>
<li>平均间隔模型</li>
<li>序列号模型</li>
</ul>
<p>也可以以一定的概率（置信度或置信水平），给出参数的估计区间的区间估计模型</p>
<h3 id="假设检验">假设检验</h3>
<p>有一个原假设/零假设<span class="math inline">\(H_0\)</span>，对立假设<span class="math inline">\(H-1\)</span>。</p>
<p>检验有三种情况，双侧检验、右侧检验和左侧检验</p>
<p>这种情况使用u检验法，方差已知，检验均值</p>
<p><span class="math display">\[
检验统计量u=\frac{\bar{x}-\mu}{\sigma/\sqrt{n} }
\]</span></p>
<p>方差未知时，应当使用t检验法。</p>
<p>检验后。如果<span class="math inline">\(H_0\)</span>被接受，原假设就是成立的</p>
<p>检验两总体的方差用F检验</p>
<h3 id="两正态总体方差比的检验">两正态总体方差比的检验</h3>
<h3 id="分布拟合检验">分布拟合检验</h3>
<h4 id="卡方拟合优度检验法">卡方拟合优度检验法</h4>
<h2 id="方差分析方法">方差分析方法</h2>
<p>方差分析又称“变异数分析”或“F检验”，用于两个及以上同方差（一般大于2）正态总体样本均值差别的显著性检验。</p>
<h3 id="单因素方差分析">单因素方差分析</h3>
<ul>
<li>方差分析模型</li>
</ul>
<h3 id="两因素方差分析">两因素方差分析</h3>
<h2 id="作业题">作业题</h2>
<h3 id="第一章">第一章</h3>
<h4 id="section">1.1</h4>
<p>在足球比賽中,球员在对方球门前不网的位置起脚射门对对方球门的威胁是不一样的。近距离的射门对球门的威胁要大于远射；在球门的正前方的威胁要大于再球门两侧射门。虽然球员之间的基本素质可能有一定差异，但对于职业球员来讲一般可以认为这种差别不大。同时根据统计资料显示，射门时球的速度一般在10m/s左右。已知标准球场的长、宽；球门的高、宽。</p>
<p>试建立数学模型研究下列问题</p>
<ol type="1">
<li>针对球员在不同位置射门对球门的威胁度进行分析，得出危险区域</li>
<li>在有一名守门员防守的情况下，对球员射门的威胁度和危险区域作进一步研究</li>
</ol>
<h4 id="section-1">1.2</h4>
<p>决策是为达到某个预定目标在若干可选方案中决定一个合适方案的过程，进行可行性决策时，但个人认为是否可行称为个体决策，多个人（至少三个人且人数为单数）按少数服从多数原则决定是否可行被称为集体决策。</p>
<p>分析：习惯上认为的“人多力量大，集体决策优于单个个体决策”是否一定正确？</p>
<p>应该考虑多个人组成的群体，其中每个个体的决策能力是相近的，那么每个个体的决策就是某个正态分布的样本，集体决策的效益也就是这几个样本的期望；个体决策是这个正态分布的期望值。</p>
<h4 id="section-2">1.3</h4>
<p>设某货物的需求量在17件到26件之间，已知需求量的概率分布如下表</p>
<table>
<thead>
<tr class="header">
<th>需求量x</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
<th>25</th>
<th>26</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>概率P(x)</td>
<td>0.12</td>
<td>0.18</td>
<td>0.23</td>
<td>0.13</td>
<td>0.10</td>
<td>0.08</td>
<td>0.05</td>
<td>0.04</td>
<td>0.04</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>成本每件5元，售价每件10元，处理每件2元。问应该进货多少，能使总利润的期望值最大？</p>
<p><span class="math display">\[
\begin{array}{l}
  假设进货量为n，记题中所给的三个数据为a,b,c\\
  售出一件的利润为b-a，处理一件赔a-c\\
  当x\lt n时，进货存在没有卖完的部分，利润S可以表示为\\
  {S_1} = {\sum_{x=17}^{n}(a-b)P(x)}-{\sum_{x=n}^{26}(a-c)P(x)}\\
  x\gt n时，{S_2} = {\sum_{x=17}^{26} }
\end{array}
\]</span></p>
<h4 id="section-3">1.4</h4>
<p>某市上半年平均每月发生171次火灾，若7月份发生了153次火灾，问7月份的火灾率是实际减少了还是一个随机波动？</p>
<h4 id="section-4">1.5</h4>
<p>保险储备</p>
<h4 id="section-5">1.6</h4>
<p>在当前生育政策下建立一个人口模型。</p>
<h2 id="参考资料">参考资料</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>特征值、特征向量、相似矩阵与二次型等</title>
    <url>/blog/posts/40258/</url>
    <content><![CDATA[<h2 id="内积和外积">内积和外积</h2>
<h3 id="内积与施瓦茨不等式">内积与施瓦茨不等式</h3>
<p>利用内积可以证明施瓦茨不等式</p>
<p><span class="math display">\[
[{\mathbf{x} },{\mathbf{y} }]^2{\le}{[{\mathbf{x} },{\mathbf{x} }]}{[{\mathbf{y} },{\mathbf{y} }]}
\]</span></p>
<h2 id="正交向量组">正交向量组</h2>
<h2 id="特征值">特征值</h2>
<h3 id="特征值的性质">特征值的性质</h3>
<p>对n阶方阵，有性质</p>
<p><span class="math display">\[
\begin{array}{l}
{\lambda_1}+{\lambda_2}+{\cdots}+{\lambda_n}={a_{11} }+{a_{22} }+{\cdots}+{a_{nn} }\\
{\lambda_1}{\lambda_2}{\cdots}{\lambda_n}=|A|
\end{array}
\]</span></p>
<h2 id="相似矩阵和对角化">相似矩阵和对角化</h2>
<h3 id="相似矩阵">相似矩阵</h3>
<p>对两个矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，如果能找到相似变换矩阵<span class="math inline">\(P\)</span>使得</p>
<p><span class="math display">\[
A=P^{-1}BP且B=P^{-1}AP
\]</span></p>
<p>就称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>是相似的。</p>
<p>当且仅当两方阵具有相同的特征值和重数时，两方阵相似。</p>
<h3 id="相似对角化">相似对角化</h3>
<p>相似对角化前首先要考虑能否进行对角化，对n阶方阵<span class="math inline">\(A\)</span>有两种情况</p>
<ol type="1">
<li>所有特征值互异，一定能够对角化</li>
<li>如果不全都互异，对于所有特征值满足<span class="math inline">\(r(A-{\lambda_i}E)=n-r_i\)</span>，也可以对角化</li>
</ol>
<p>确定可以对角化后，需要得到变换矩阵<span class="math inline">\(P\)</span>以及对角矩阵<span class="math inline">\(\Lambda\)</span></p>
<p><span class="math inline">\(P\)</span>矩阵由特征向量组，<span class="math inline">\(\Lambda\)</span>矩阵由对应的特征值作为对角线元素组成。</p>
<p>值得注意的是，当且仅当一个矩阵是对称矩阵，他才可以被正交对角化。</p>
<blockquote>
<p>求正交对角矩阵<span class="math inline">\(P\)</span>时，部分向量可能不互相正交，此时可以利用格拉姆-施密特方法，在其中一些向量中减去另一个向量的投影，即可得到相互正交的基向量。</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>犹太历史与文化</title>
    <url>/blog/posts/65453/</url>
    <content><![CDATA[<h1 id="第二讲-希伯来圣经与犹太历史文化的开端">第二讲 《希伯来圣经》与犹太历史文化的开端</h1>
<h2 id="希伯来圣经">《希伯来圣经》</h2>
<h3 id="翻译">翻译</h3>
<ul>
<li>狄考文翻译的</li>
<li>圣书之民</li>
<li>原罪和圣经没有关系，中世纪神学家编出来的</li>
<li>单词alphabet来源于希伯来语前两个字母alef和bet</li>
<li>希伯来语从右往左读</li>
<li>希伯来语有圣经希伯来语和现代希伯来语</li>
<li><strong>不要用旧约！！！！！！！！！！！！！！！！！！！！！！！！</strong></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>选修</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵与矩阵运算</title>
    <url>/blog/posts/9209/</url>
    <content><![CDATA[<h2 id="矩阵的基本知识和运算">矩阵的基本知识和运算</h2>
<h3 id="基本概念">基本概念</h3>
<h3 id="矩阵的加法乘法">矩阵的加法乘法</h3>
<p>矩阵的加法要求两个矩阵具有相同的大小。</p>
<p>矩阵乘法是对两矩阵所描述的线性变换的复合。</p>
<p>矩阵乘法满足结合律，左右分配律以<span class="math inline">\(I_n\)</span>为乘法单位元；但不满足消去律。</p>
<p>对于常用平方差、立方差等公式，需要满足条件<span class="math inline">\(AB=BA\)</span>，例如</p>
<p><span class="math display">\[
\begin{array}{l}
(A+B)(A-B)=A^2-AB+BA+B^2\\
当且仅当AB=BA，上式=A^2+B^2
\end{array}
\]</span></p>
<blockquote>
<p>显然，如果其中一个元素数是单位矩阵<span class="math inline">\(E\)</span>，这一系列性质显然成立</p>
</blockquote>
<p>根据矩阵乘法的定义</p>
<p><span class="math display">\[
AB = {A\mathbf{b_1} }+{A\mathbf{b_2} }+{\dotsb}+{A\mathbf{b_n} }
\]</span></p>
<blockquote>
<p>对于一些<span class="math inline">\(B\)</span>的各列都相等的情况，可以使用定义来化简</p>
</blockquote>
<p>由行列法则，同样可以在A的各列相同时有一个化简的思路</p>
<p><span class="math display">\[
AB = {row_1(A)B}+{row_2(A)B}+{\dotsb}+{row_m(A)B}
\]</span></p>
<p>对角矩阵一般可以保证<span class="math inline">\(AD=DA\)</span>，当然，特征矩阵更可以</p>
<blockquote>
<p>这是由于对角矩阵只有对角线元素对另一个矩阵有作用，而对角线元素的位置是“唯一”的，所以总是有相同的效果。</p>
</blockquote>
<h3 id="初等矩阵">初等矩阵</h3>
<p>对特征矩阵<span class="math inline">\(I\)</span>进行一种初等变换得到的矩阵被称为初等矩阵，一般记作<span class="math inline">\(E\)</span>。</p>
<p>初等矩阵的逆矩阵<span class="math inline">\(E^{-1}\)</span>可以通过反向的同一类初等变换得到，根据这个性质，得到了下面逆矩阵的算法。</p>
<h2 id="矩阵的因式分解">矩阵的因式分解</h2>
<p>矩阵因式分解有非常广泛的应用，常见的有满秩分解，QR分解，奇异值分解，特征分解，极分解定理，LU分解</p>
<blockquote>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/356686048" class="uri">https://zhuanlan.zhihu.com/p/356686048</a></p>
</blockquote>
<h3 id="lu分解">LU分解</h3>
<blockquote>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/144137832" class="uri">https://zhuanlan.zhihu.com/p/144137832</a> <a href="https://zhuanlan.zhihu.com/p/45784001" class="uri">https://zhuanlan.zhihu.com/p/45784001</a></p>
</blockquote>
<h4 id="lu分解的理解和意义">LU分解的理解和意义</h4>
<blockquote>
<p>参考 [LU分解法与Gauss消元法两者复杂度的比较，谁跟快？ - Artorias的回答 - 知乎]<a href="https://www.zhihu.com/question/346783313/answer/1139681118" class="uri">https://www.zhihu.com/question/346783313/answer/1139681118</a> [lu分解有什么意义啊？ - 王锐的回答 - 知乎]<a href="https://www.zhihu.com/question/52451868/answer/297354277" class="uri">https://www.zhihu.com/question/52451868/answer/297354277</a></p>
</blockquote>
<p>LU 分解的意义在于，将矩阵的<strong>分解</strong>与方程的<strong>求解</strong>分离.</p>
<p>在不少应用场景中，当需要求解<span class="math inline">\(A\mathbf{x} =\mathbf{b}\)</span>的时候，左边的矩阵<span class="math inline">\(A\)</span>很多时候是不变的，而右边的<span class="math inline">\(\mathbf{b}\)</span>随着输入而变化。做LU分解时，只会用到矩阵<span class="math inline">\(A\)</span>，所以可以预先准备好<span class="math inline">\(L\)</span>与<span class="math inline">\(U\)</span>，当有求解<span class="math inline">\(b\)</span>的需求时，直接拿来用就好了。</p>
<p>Gauss消元法的时间复杂度约为<span class="math inline">\(O(n^3)\)</span>,LU分解的时间复杂度也为<span class="math inline">\(O(n^3)\)</span>，但分解之后每次求解的复杂度为<span class="math inline">\(O(n^2)\)</span>；但是如果目标向量是一组k个，那直接使用Gauss消元法的时间复杂度为<span class="math inline">\(kO(n^3)\)</span>，先进行LU分解的复杂度则为<span class="math inline">\(O(n^3)+kO(n^2)\)</span>，所以对于求解一组目标向量的情况LU分解明显有更高的效率。</p>
<h3 id="qr分解正交三角分解">QR分解（正交三角分解）</h3>
<h3 id="谱分解满秩分解">谱分解（满秩分解）</h3>
<h3 id="奇异值分解">奇异值分解</h3>
<p>奇异值分解用于对行列式进一部分析，获得一系列奇异值，研究矩阵的奇异性。</p>
<h2 id="矩阵的转置">矩阵的转置</h2>
<div class="note note-warning">
            <p>矩阵转置的理解涉及到对偶性，Duality，包括对偶基、对偶空间等，没学会。</p>
          </div>
<p>定义矩阵<span class="math inline">\(A\)</span>的转置<span class="math inline">\(A^T\)</span>是行由<span class="math inline">\(A\)</span>的列组成的矩阵。具有如下性质</p>
<p><span class="math display">\[
\begin{array}{l}
(A^T)^T = A,\\
(A+B)^T = A^T+B^T,\\
(kA)^T = kA^T,\\
(AB)^T = B^TA^T
\end{array}
\]</span></p>
<p>显然最后一个是容易出现问题的，当然，这个结论也可以进一步推广到有限个。</p>
<p>对于对称矩阵<span class="math inline">\(A\)</span>和反对称矩阵<span class="math inline">\(B\)</span>，有性质</p>
<p><span class="math display">\[
\begin{array}{l}
A^T=A\\
B^T=-B
\end{array}
\]</span></p>
<blockquote>
<p>因此，在判断矩阵是否对称时，利用这个性质直接判断矩阵的转置与原矩阵的关系即可。若既不相等也不是相反数，那就既不对称也不反对称。</p>
</blockquote>
<h2 id="矩阵的逆">矩阵的逆</h2>
<p>逆矩阵是矩阵的乘法逆元，要求矩阵为方阵且行列式不为零。</p>
<p>并不是所有方阵都有自己的逆矩阵，可逆矩阵被称为非奇异矩阵，不可逆矩阵则被称为奇异矩阵。</p>
<div class="note note-success">
            <p>数学上，“奇异”（singular）一词用来形容破坏了某种优良性质的数学对象。</br> 对于矩阵来说，“可逆”是一个好的性质，不可逆的矩阵就称为“奇异”矩阵。</p>
          </div>
<blockquote>
<p>“奇异”一词在数学中的含义参考<a href="https://zhuanlan.zhihu.com/p/462373339" class="uri">https://zhuanlan.zhihu.com/p/462373339</a> </br> 奇异矩阵对应奇异线性变换。所谓奇异的线性变换，就是不存在逆变换的线性变换，即变换不回来了，所以奇异矩阵的严格定义是行列式不为零。</p>
</blockquote>
<p>既然我们能知道“奇异”是个不良好的性质，自然可以找到一些指标，也就是异类指数描述矩阵“奇异”的程度，就可以逐步引出奇异值分解。</p>
<p>异类指数需要描述的是线性变换在不同维度上缩放的差异程度，不同维度缩放的差距越大其奇异性越强。要获得异类指数，可以使用奇异值对矩阵进行分解。</p>
<p><span class="math display">\[
A=U{\Sigma}V^T =
{[{\mathbf{u_1} } {\quad} {\mathbf{u_2} } {\quad} {\dotsb} {\quad} {\mathbf{u_n} }]}
{\left []
\begin{array}{ccccc}
{\sigma_1} &amp; 0 &amp; 0 &amp; {\dotsc} &amp; 0 \\
0 &amp; {\sigma_2} &amp; 0 &amp; {\dotsc} &amp; 0 \\
0 &amp; 0 &amp; {\sigma_3} &amp; {\dotsc} &amp; 0 \\
{\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\
0 &amp; 0 &amp; 0 &amp; {\dotsc} &amp; {\sigma_n}
\end{array}
\right ]}
{\left [
\begin{array}{c}
{\mathbf{v_1} }^T \\
{\mathbf{v_2} }^T \\
{\mathbf{v_3} }^T \\
{\vdots} \\
{\mathbf{v_n} }^T
\end{array}
\right ]}
\]</span></p>
<p>其中<span class="math inline">\(U\)</span>和<span class="math inline">\(V\)</span>是正交矩阵，而<span class="math inline">\(\Sigma\)</span>是对角矩阵，对角元素就是<span class="math inline">\(n\)</span>个非负奇异值，可以取<span class="math inline">\(0\)</span>值，从大到小排列。</p>
<p>奇异值就是把行列式一个数变成<span class="math inline">\(n\)</span>个非负因子，从各个维度上分别衡量了线性变换的缩放情况。</p>
<h3 id="二阶矩阵的逆">二阶矩阵的逆</h3>
<p>对于二阶矩阵，有一个使用克拉默法则推出的公式可以直接使用</p>
<p><span class="math display">\[
{A^{-1} } = { {1}\over{|A|} }
{\left [
\begin{array}{cc}
d &amp; -b \\
-c &amp; a
\end{array}
\right ]}
\]</span></p>
<p>对于对角矩阵，其逆矩阵的对角线上元素与原矩阵互为倒数。</p>
<h3 id="逆矩阵的性质">逆矩阵的性质</h3>
<p>逆矩阵有与转置矩阵相似的一些性质</p>
<p><span class="math display">\[
\begin{array}{l}
(A^{-1})^{-1} = A, \\
(AB)^{-1} = {B^{-1} }{A^{-1} }
\end{array}
\]</span></p>
<p>当逆矩阵与转置矩阵一起出现</p>
<p><span class="math display">\[
(A^T)^{-1} = (A^{-1})^T
\]</span></p>
<h3 id="逆矩阵的算法">逆矩阵的算法</h3>
<p>对矩阵<span class="math inline">\(A\)</span>，当且仅当<span class="math inline">\([A{\quad}I]\)</span>可以行化简为<span class="math inline">\([I{\quad}A^{-1}]\)</span>，其逆矩阵<span class="math inline">\(A^{-1}\)</span>存在。</p>
<p>如果将<span class="math inline">\(I\)</span>视作若干方程组，也就是从向量<span class="math inline">\(\mathbf{e_1},\mathbf{e_2},{\dotsb},\mathbf{e_n}\)</span>的角度来看，这个过程是求解线性方程组。这种角度可以得到某个或几个解，不必求出整个逆矩阵。</p>
<p>对于对角矩阵，其逆矩阵就是取对角线上所有元素的倒数，即</p>
<p><span class="math display">\[
{\begin{bmatrix}
  a &amp; 0 &amp; {\cdots} &amp;0 \\
  0 &amp; b &amp; {\cdots} &amp;0 \\
  {\vdots}&amp;  {\vdots}&amp; {\ddots}&amp;{\vdots} \\
  0&amp;  0&amp; 0 &amp; c
\end{bmatrix} }^{T}=
\begin{bmatrix}
  1/{a} &amp; 0 &amp; {\cdots} &amp;0 \\
  0 &amp; 1/{b} &amp; {\cdots} &amp;0 \\
  {\vdots}&amp;  {\vdots}&amp; {\ddots}&amp;{\vdots} \\
  0&amp;  0&amp; 0 &amp; 1/{c}
\end{bmatrix}
\]</span></p>
<h3 id="可逆矩阵定理">可逆矩阵定理</h3>
<blockquote>
<p>可逆矩阵定理贼几把难</p>
</blockquote>
<h2 id="子空间列空间与零空间">子空间、列空间与零空间</h2>
<blockquote>
<p>线性代数中，子空间往往以某个线性方程组的解集或者某几个向量的线性组合的形式出现，这对应了矩阵的两个子空间。</p>
</blockquote>
<h3 id="列空间">列空间</h3>
<p>矩阵的所有列向量张成矩阵的列空间，记作<span class="math inline">\(ColA\)</span>或<span class="math inline">\(C(A)\)</span>。</p>
<p>对一个<span class="math inline">\(m{\times}n\)</span>矩阵，列空间是<span class="math inline">\(R^m\)</span>的子空间；他是矩阵所对应的线性变换能包含的所有向量的集合，也就是说，经过该矩阵的变换，向量只能位于这个空间内。</p>
<h3 id="零空间">零空间</h3>
<p>矩阵的零空间是所有满足<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的解的集合，记作<span class="math inline">\(NulA\)</span>。</p>
<p>对一个<span class="math inline">\(m{\times}n\)</span>矩阵，零空间是<span class="math inline">\(R^n\)</span>的子空间。</p>
<p>零空间是原空间<span class="math inline">\(V\)</span>在变换后被映射到<span class="math inline">\(W\)</span>中0的所有向量的集合，他也因此被称为线性变换的核，相应的，此时列空间对应值域。</p>
<h3 id="维数">维数</h3>
<p>向量空间的生成基中向量的个数，成为空间的维，记作<span class="math inline">\(dimV\)</span>。</p>
<p>维度为n的空间的基可以有多于n个向量，但其中一定存在线性相关的向量，可以使用生成基定理去掉这些没有用的向量。</p>
<p>对于列空间来讲，一个<span class="math inline">\(m{\times}n\)</span>矩阵有<span class="math inline">\(n\)</span>个列向量作为<span class="math inline">\(ColA\)</span>的基，但他们不一定都使得上劲；矩阵的主元列作为线性组合的权，是可以生成列空间的最小生成集，因此列空间的维数就是<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的增广矩阵的主元列的个数。</p>
<p>对于零空间来讲，非主元列的个数就是<span class="math inline">\(dimNulA\)</span>。</p>
<h3 id="秩">秩</h3>
<p>秩包括矩阵的秩、行秩和列秩，其中行秩、列秩分别是行空间、列空间的维度，行秩与列秩总是相等；秩被定义为非零子式的最高阶数，或者极大线性无关组的个数。</p>
<p>秩反映了线性变换后所具有的最大维度，因此秩反映为列空间的维数。</p>
<p>由列空间和零空间维数的求解可以知道对<span class="math inline">\(m{\times}n\)</span>矩阵</p>
<p><span class="math display">\[
rankA+dimNulA = n
\]</span></p>
<p>利用这条性质，还可以得出</p>
<p><span class="math display">\[
方程组A{\mathbf{x} }={\mathbf{0} }与A^TA{\mathbf{x} }={\mathbf{0} }同解，且有r(A)=r({A^T}A)
\]</span></p>
<p>对<span class="math inline">\(n\)</span>阶对称方阵，矩阵的秩等于非零特征值的个数。</p>
<p>秩还具有以下性质<a href="refer-anchor-1"><sup>1</sup></a></p>
<p><span class="math display">\[
\begin{array}{l}
r(A{\plusmn}B)\leq{r(A){\plusmn}r(B)},\\
r(AB){\leq}{min\{r(A),r(B)\} },\\
若AB=0,则r(A)+r(B){\leq}n\\
r(kA)=r(A),\\
r(A)=r({A^T}A)\\
r(AC)=r(A),C是一个可逆矩阵
\end{array}
\]</span></p>
<h2 id="伴随矩阵">伴随矩阵</h2>
<p>先计算出矩阵的代数余子式，将其排列成矩阵之后转置得到就是矩阵的伴随矩阵。</p>
<p><span class="math display">\[
{A^*}=|A|{A^{-1} }
\]</span></p>
<p>伴随矩阵的性质</p>
<p><span class="math display">\[
AA^*=A^*A=|A|E
\]</span></p>
<p>对于一些代数余子式或余子式的和的求解，可以利用他们的性质。</p>
<blockquote>
<p>比如对<span class="math inline">\(4{\times}4\)</span>矩阵计算<span class="math inline">\({A_{31}+A_{32}+A_{34} }\)</span>，有<span class="math inline">\({A_{31}+A_{32}+A_{34} } = 1{\times}{A_{31} }+1{\times}{A_{32} }+0{\times}{A_{33} }+1{\times}{A_{34} }\)</span>，等价于将原矩阵第三行更换为<span class="math inline">\((1,1,0,1)\)</span>后计算新矩阵<span class="math inline">\(A&#39;\)</span>的行列式（因为被展开的一行不影响代数余子式的值，这一行也只决定代数余子式的系数）。</p>
</blockquote>
<h2 id="分块矩阵">分块矩阵</h2>
<p>分块矩阵的逆有两种情况</p>
<p><span class="math display">\[
{\begin{pmatrix}
\mathbf{B} &amp; \mathbf{0} \\
\mathbf{0} &amp; \mathbf{C}
\end{pmatrix} }^{-1}=
{\begin{pmatrix}
\mathbf{B}^{-1} &amp; \mathbf{0} \\
\mathbf{0} &amp; \mathbf{C}^{-1}
\end{pmatrix} }, \\
{\begin{pmatrix}
\mathbf{0} &amp; \mathbf{B} \\
\mathbf{C} &amp; \mathbf{0}
\end{pmatrix} }^{-1}=
{\begin{pmatrix}
\mathbf{0} &amp; \mathbf{C}^{-1} \\
\mathbf{B}^{-1} &amp; \mathbf{0}
\end{pmatrix} }
\]</span></p>
<h3 id="准对角矩阵">准对角矩阵</h3>
<p>准对角矩阵（分块对角矩阵）是对角线上的分块以外全是0的分块矩阵。</p>
<p><span class="math display">\[
\begin{array}{l}
|A|=|{A_1}|{\cdot}|{A_2}|{\cdots}|{A_n}|\\
r(A)=r({A_1})+r({A_2})+{\cdots}+r({A_n})
\end{array}
\]</span></p>
<h2 id="reference">Reference</h2>
<div id="refer-anchor-1">

</div>
<ul>
<li>[1] <a href="https://kaoyan.wendu.com/2016/0202/74205.shtml">2017考研数学:矩阵秩的常用性质分析</a></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学</title>
    <url>/blog/posts/46708/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<h2 id="离散数学内容">离散数学内容</h2>
<p>离散数学主要包括逻辑、集合、算法、图论和代数五个部分，他们共同用来描述一个模型</p>
<table>
<thead>
<tr class="header">
<th>领域</th>
<th>角度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>逻辑</td>
<td>描述模型的性质和结构</td>
</tr>
<tr class="even">
<td>集合</td>
<td>描述模型的元素和结构</td>
</tr>
<tr class="odd">
<td>算法</td>
<td>描述模型的行为和实现</td>
</tr>
<tr class="even">
<td>图论</td>
<td>描述模型结构</td>
</tr>
<tr class="odd">
<td>代数</td>
<td>描述模型的结构和约束</td>
</tr>
</tbody>
</table>
<h2 id="内容">内容</h2>
<ul>
<li><strong>逻辑</strong>包含命题逻辑、一阶逻辑和证明</li>
<li><strong>集合</strong>包含集合和关系</li>
<li><strong>算法</strong></li>
<li><strong>图论</strong></li>
<li><strong>代数</strong>指代数系统</li>
</ul>
<h2 id="基础知识">基础知识</h2>
<h3 id="逻辑语言">逻辑语言</h3>
<h4 id="命题">命题</h4>
<ul>
<li>命题及其真值</li>
<li>原子命题和复合命题</li>
<li>逻辑联结词</li>
</ul>
<h4 id="逻辑公式">逻辑公式</h4>
<ul>
<li>逻辑运算符，与、或、蕴涵和双蕴涵</li>
<li>充分条件和必要条件</li>
<li>蕴涵命题又被称为条件命题，双蕴涵命题又被称为双条件/逻辑等价命题</li>
<li>量化命题和量词</li>
</ul>
<h3 id="集合语言">集合语言</h3>
<h4 id="集合">集合</h4>
<ul>
<li>集合和元素</li>
<li>空集、元素枚举法和性质概括法</li>
<li>有序对（二元组）、n元组</li>
<li>笛卡尔积</li>
</ul>
<h4 id="关系">关系</h4>
<ul>
<li>二元关系及n元关系</li>
<li>归纳法</li>
</ul>
<h4 id="函数">函数</h4>
<ul>
<li>定义域、值域和陪域</li>
</ul>
<h4 id="特殊关系">特殊关系</h4>
<ul>
<li>整除<span class="math inline">\(a|b\)</span>，a是b的一个因子，b是a的一个倍数</li>
</ul>
<h3 id="算法语言">算法语言</h3>
<h3 id="图论语言">图论语言</h3>
<h4 id="图">图</h4>
<ul>
<li>包含所有边且仅一次的回路的图称为欧拉图</li>
<li>顶点集和边集</li>
<li>有向图和无向图</li>
</ul>
<h4 id="树">树</h4>
<ul>
<li>通路和回路</li>
<li>连通图和树</li>
<li>根树</li>
</ul>
<h3 id="代数语言">代数语言</h3>
<h4 id="运算">运算</h4>
<ul>
<li>封闭性</li>
<li>运算律：交换律、结合律和分配律</li>
</ul>
<h4 id="元素">元素</h4>
<ul>
<li>单位元</li>
<li>零元</li>
<li>逆元</li>
<li>最大公因数（dcd）和最小公倍数（lcm）</li>
</ul>
<h1 id="命题逻辑">命题逻辑</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="命题与真值">命题与真值</h3>
<ul>
<li><p><strong>命题(proposition)</strong>是具有真假值的陈述句</p></li>
<li><p><strong>真值(truth value)</strong>是命题的真假值，是一个二元素集合<span class="math inline">\({0,F}\)</span>和<span class="math inline">\({1,T}\)</span></p></li>
</ul>
<h3 id="原子命题和复合命题">原子命题和复合命题</h3>
<ul>
<li><strong>原子命题(atomic proposition)</strong>或<strong>简单命题(simple proposition)</strong>是不可以进一步分解（不含有逻辑联结词）的命题</li>
<li><strong>复合命题(compound proposition)</strong>是可以进一步分解出<strong>子命题(sub-proposition)</strong>的命题</li>
<li><strong>命题逻辑公式(propositional logic formula)</strong>是由<strong>命题变量符号</strong>、<strong>逻辑运算符(logic connectives)</strong>组成的公式</li>
</ul>
<blockquote>
<p>原子命题/复合命题和命题逻辑公式描述的不是一个角度，原子命题/复合命题关注命题能否继续分解，继而伴生了子命题；命题逻辑公式只是对命题的一种描述方式，可以说是一种定义</p>
</blockquote>
<h2 id="基本的逻辑公式">基本的逻辑公式</h2>
<h3 id="逻辑公式的语法">逻辑公式的语法</h3>
<ul>
<li><p><strong>语法(syntax)</strong>就是命题逻辑公式的运算规则</p></li>
<li><p>定义一个命题变量符号集<span class="math inline">\(Var\)</span>，每一个元素都是一个命题变量(propositional variable)，使用小写字母和下标表示</p></li>
<li><p>定义命题逻辑公式的符号集，包含命题变量符号集<span class="math inline">\(Var\)</span>和五个逻辑运算符、左右圆括号</p>
<blockquote>
<p>上面的定义，可以联想在代数系统里似乎提到过的，对于运算的定义包括运算数(命题变量符号集)和运算符(逻辑运算符)</p>
</blockquote></li>
<li><p>由五个逻辑运算符，我们会这样一系列可能的形式（<strong>语法角度的分类</strong>）</p>
<ol type="1">
<li>原子公式(atomic formula)</li>
<li>否定式(negation)</li>
<li>合取式(conjunction</li>
<li>析取式(disjunction)</li>
<li>蕴涵式(implication)/条件式(conditional formula)</li>
<li>双蕴涵式(bi-implication)/双条件式(bi-conditional formula)</li>
</ol></li>
<li><p>构造命题逻辑公式时用到的公式被称为<strong>子公式(sub-formula)</strong></p></li>
</ul>
<h4 id="结构归纳法">结构归纳法</h4>
<p>要证明<strong>一个性质对任意命题逻辑公式都成立</strong>，只需证1.这个性质对原子公式（命题变量）成立2.这个性质对剩余五种形式成立，这种方法被称为结构归纳法</p>
<p>以下有两个引理</p>
<ol type="1">
<li><p>引理2.1：任意命题逻辑公式，有左圆括号数等于右圆括号数等于逻辑运算符的数量</p></li>
<li><p>引理2.2：如果一个命题逻辑公式不是命题变量，那么他作为一个符号串存在且仅存在一个位置满足1.字符是逻辑运算符2.左边的字符串以左圆括号开头，且左圆括号比右圆括号多一个；右边的字符串以右圆括号开头，且右圆括号比左圆括号多一个</p>
<blockquote>
<p>引理2.2提供了一种判断字符串是否是命题逻辑公式的方法，它可以通过递归的分支实现</p>
</blockquote></li>
</ol>
<h4 id="命题逻辑公式的简写">命题逻辑公式的简写</h4>
<p>截止目前，运算符的优先级还没有被定义，对于优先级的描述依赖于左右圆括号</p>
<p>在定义运算符的优先级之后，就可以进行一系列简写</p>
<h3 id="语法的抽象表示">语法的抽象表示</h3>
<p>每个公式的构造都可以用一个二叉树表示，这样的二叉树被称为<strong>抽象语法树(abstract syntax tree,AST)</strong></p>
<ul>
<li>这颗二叉树的叶子（方形）结点都是归纳基给出的命题变量，圆形节点都是逻辑运算符</li>
</ul>
<h3 id="逻辑公式的语义">逻辑公式的语义</h3>
<p>命题逻辑公式的语义就是命题逻辑公式的真值</p>
<ul>
<li>定义一个真值赋值函数<span class="math inline">\(\sigma:Var \rightarrow 2\)</span></li>
</ul>
<p>对于几种形式的真值为的条件</p>
<table>
<thead>
<tr class="header">
<th>形式</th>
<th>条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>否定式</td>
<td></td>
</tr>
<tr class="even">
<td>析取式</td>
<td>当且仅当都为假时为假</td>
</tr>
<tr class="odd">
<td>合取式</td>
<td>当且仅当都为真时为真</td>
</tr>
<tr class="even">
<td>蕴涵式</td>
<td>当且仅当前提为真，结论为假时为假</td>
</tr>
<tr class="odd">
<td>双蕴涵式</td>
<td>真值相同时成立</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于蕴涵式，前件为假时整个蕴涵式为真</p>
<p>这在数学上称为<strong>整个命题平凡为真</strong>，从而在证明中通常不明确给出逻辑蕴涵命题前件为假的情况</p>
</blockquote>
<ul>
<li><p>从<strong>语义的角度</strong>，我们可以将命题逻辑公式进行分类（注意比较上面从语法角度的分类）</p>
<ol type="1">
<li>永真式(tautology)</li>
<li>矛盾式(contradiction)</li>
<li>偶然式(contingency)</li>
</ol>
<blockquote>
<p>若一个柿式子不是矛盾式，则它是可满足的，因此偶然式也称为非永真的可满足式</p>
</blockquote></li>
<li><p>命题逻辑公式有一个重要的定理</p>
<blockquote>
<p>定理2.4: 设命题逻辑公式A是永真式，p是其中出现过的一个命题变量，那么使用任意命题逻辑公式B<strong>替换(substituion)</strong>所有A中出现的p，得到的逻辑公式A'仍然是永真式</p>
</blockquote></li>
</ul>
<h2 id="等值演算">等值演算</h2>
<h3 id="逻辑等值和逻辑等值式模式">逻辑等值和逻辑等值式模式</h3>
<p>两个命题逻辑公式A和B的真值都相同，称A和B逻<strong>辑等值(logically equivalent)</strong>，记为$AB $，将这个式子称为逻辑等值式。</p>
<p>逻辑等值具有<strong>传递性(transiticity)</strong>，基于传递性进行一系列变换的过程被称为等值演算</p>
<ul>
<li><p>以下引理将逻辑等值的表达转换成命题逻辑公式</p>
<blockquote>
<p>引理2.5: 命题逻辑公式A和B逻辑等值，当且仅当<span class="math inline">\(A \Leftrightarrow B\)</span></p>
</blockquote></li>
</ul>
<p>从一些基本的逻辑等值式出发，利用定理2.4，我们可以得到一系列逻辑等值式子，这些基本的逻辑等值式被称为基本<strong>逻辑等值式模式(template)</strong></p>
<ul>
<li><p>同一律<span class="math inline">\(A\cap1\equiv A,A\cup0\equiv A\)</span></p></li>
<li><p>零率<span class="math inline">\(A\cap 0 \equiv 0,A\cup 1\equiv 1\)</span></p>
<blockquote>
<p>对这两者的理解还是结合代数系统的单位元、零元：</p>
<p>同一律表明永真式是合取的单位元；矛盾式是析取的单位元。</p>
<p>零律表明矛盾式是合取的零元；永真式是析取的零元</p>
</blockquote></li>
<li><p>矛盾律<span class="math inline">\(A\cap (\neg A) \equiv 0\)</span></p></li>
<li><p>排中律<span class="math inline">\(A \cup (\neg A)\equiv 1\)</span></p></li>
<li><p>双重否定律<span class="math inline">\(\neg(\neg A)\equiv A\)</span></p></li>
<li><p>幂等律<span class="math inline">\(A\cap \neg A\equiv A,A\cup \neg A \equiv A\)</span></p>
<blockquote>
<p>这四者·都是针对同一个命题逻辑公式的变换</p>
</blockquote></li>
<li><p>交换律<span class="math inline">\(A\cap B=B\cap A,A\cup B=B\cup A\)</span></p></li>
<li><p>结合律<span class="math inline">\((A\cap(B\cap C))\equiv ((A\cap B)\cap C),(A\cup(B\cup C))\equiv ((A\cup B)\cup C)\)</span></p></li>
<li><p>分配律<span class="math inline">\(A\cap(B\cup C)=(A\cap B)\cup(A\cap C),A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\)</span></p></li>
<li><p>吸收律<span class="math inline">\(A\cap (A\cup B)\equiv A,A\cup (A\cap B)\equiv A\)</span></p>
<blockquote>
<p>这是一个数集上不存在的定律</p>
</blockquote></li>
<li><p>德摩根律<span class="math inline">\(\neg(A\cap B)\equiv (\neg A)\cup(\neg B),\neg(A\cup B)\equiv (\neg A)\cap(\neg B)\)</span></p>
<blockquote>
<p>非常经典和常用的运算律</p>
</blockquote></li>
<li><p>蕴涵等值式<span class="math inline">\(A\rightarrow B \equiv (\neg A)\cup B\)</span></p></li>
<li><p>双蕴涵等值式<span class="math inline">\(A \leftrightarrow B\equiv (A\rightarrow B)\cap(B\rightarrow A)\)</span></p></li>
</ul>
<p>对于逻辑蕴涵，我们还有这样四个逻辑等值式，他们可以被当作是逻辑蕴涵的分配律</p>
<blockquote>
<p>在前件不同时，要注意将合取变为析取，析取变为合取</p>
</blockquote>
<h3 id="范式">范式*</h3>
<p>定义范式前，还有几个概念要明确</p>
<ul>
<li><strong>文字(literial)</strong>：命题变量或其否定</li>
<li><strong>简单合取式</strong>：一个或多个文字的合取的公式</li>
<li><strong>析取范式(disjunction normal formula)</strong>：一个或几个合取式的析取</li>
</ul>
<p>同样的可以定义简单析取式和合取范式</p>
<blockquote>
<p>要注意否定运算符只能出现在文字（命题变量之前）</p>
</blockquote>
<ul>
<li>对于任意一个命题逻辑公式，都有至少一个等价的析取和合取范式</li>
</ul>
<p>为此，我们希望找到一个唯一的析取/合取范式，首先定义极小项和极大项</p>
<ul>
<li><p><strong>极小项(minterm)</strong>：若含有n个命题变量的合取式恰好是n个文字的合取，且每个文字对应不同的命题变量，则该合取式被称为极小项</p>
<blockquote>
<p>或者说，设有 n 个命题变项，若在<strong>简单合取式</strong>中每个命题变项与其否定<strong>有且仅有一个出现一次</strong>，则这样的简单合取式叫做极小项</p>
</blockquote></li>
<li><p><strong>极大项(maxterm)</strong>：相似的，对于某个析取式。。。</p></li>
</ul>
<p>对于极小项和极大项，我们可以使用二进制的形式对其进行编码，具体编码方式以后再说</p>
<p>有了极小项和极大项，我们可以进一步定义</p>
<ul>
<li><strong>主析取范式(principal disjunctive normal form)</strong>：零个或几个极小项的析取</li>
<li><strong>主合取范式(principal conjunctive normal form)</strong>：零个或几个极大项的合取</li>
</ul>
<h2 id="推理">推理</h2>
<p>推理(reasoning)是从一组作为前提(premise)的命题得到一个作为结论(conclusion)的命题的过程，可以表示为<span class="math inline">\(A_1,A_2,...,A_n \Rightarrow B\)</span></p>
<p>当<span class="math inline">\(A_1 \cap A_2 \cap ...\cap A_n \rightarrow B\)</span>为永真式时，称这个推理是有效(valid)的</p>
<blockquote>
<p>推理的有效性和结论的真假没有任何关系</p>
</blockquote>
<h3 id="自然推理系统">自然推理系统</h3>
<p>构造真值表和等值演算都不适合进行推理，因此推过引入中间结论和公理化的方法，构造自然推理系统来进行推理的演算</p>
<p>自然推理系统包含以下规则</p>
<ul>
<li><p>假言推理(modus ponens)/分离规则<span class="math inline">\(A\rightarrow B,A\Rightarrow B\)</span></p></li>
<li><p>假言异位(modus tollens)/取拒式<span class="math inline">\(A\rightarrow{B},{\neg{B} }\Rightarrow{\neg{A} }\)</span></p>
<blockquote>
<p>这两个是对包含蕴涵式的推理方法的抽象，二者一正一反</p>
<p>用于从前提中得到中间结论</p>
</blockquote></li>
<li><p>合取(conjunction)<span class="math inline">\({A,B}\Rightarrow{A\cap{B} }\)</span></p></li>
<li><p>化简(simplification)<span class="math inline">\(A\cap{B}\Rightarrow{A},A\cap{B}\Rightarrow{B}\)</span></p>
<blockquote>
<p>这两个是对前提之间关系的描述，合取告诉我们几个前提同时存在其实就是对他们的合取；化简则告诉我们几个前提的合取可以从中任意取出一个来作为前提</p>
<p>合取用于得到结论是合取式的结论</p>
<p>化简可用于利用前提中的合取式</p>
</blockquote></li>
<li><p>附加(addition)<span class="math inline">\(A\Rightarrow{A\cup{B} }\)</span></p>
<blockquote>
<p>用于得到是析取式的结论</p>
</blockquote></li>
<li><p>析取三段论(disjunction syllogism)<span class="math inline">\(\neg{A},A\cup{B}\Rightarrow{B}\)</span></p>
<blockquote>
<p>析取三段论是对排除法的抽象，可以利于前提中的析取式</p>
</blockquote></li>
<li><p>假言三段论<span class="math inline">\(A\rightarrow{B},B\rightarrow{C}\Rightarrow{A\rightarrow{C} }\)</span></p></li>
<li><p>等值置换(equivalent replacement)<span class="math inline">\(A\equiv{B},有A\Rightarrow{B},B\Rightarrow{A}\)</span></p></li>
<li><p>双蕴涵推理<span class="math inline">\(A\leftrightarrow{B}\Rightarrow A\rightarrow{B},B\rightarrow{A}\)</span></p></li>
</ul>
<h3 id="两种推理方法">两种推理方法</h3>
<h4 id="附加前提法">附加前提法</h4>
<p>用于得到结论是蕴涵式的结论，有以下定理</p>
<blockquote>
<p>定理2.8: 推理<span class="math inline">\(A_1,A_2,...,A_n\Rightarrow{B\rightarrow{C} }\)</span>是有效的，当且仅当<span class="math inline">\(A_1,A_2,...,A_n,B\Rightarrow {C}\)</span>是有效的</p>
</blockquote>
<h4 id="反证法">反证法</h4>
<p>用于得到结论是否定式的结论，有以下定理</p>
<blockquote>
<p>定理2.9: 推理<span class="math inline">\(_1,A_2,...,A_n\Rightarrow \neg B\)</span>是有效的，当且仅当<span class="math inline">\(_1,A_2,...,A_n,B\Rightarrow{C\cap{\neg C} }\)</span>是有效的</p>
</blockquote>
<h2 id="应用">应用</h2>
<p>几种判断的分类</p>
<ul>
<li>联言判断：对应“与”</li>
<li>选言判断：选言判断还分为相容选言判断和不相容选言判断，相容选言判断对应“或”，不相容选言判断则是“异或”</li>
<li>假言判断</li>
</ul>
<p>三种命题关系</p>
<ul>
<li>逆命题</li>
<li>否命题</li>
<li>逆否命题</li>
</ul>
<h1 id="一阶逻辑和证明">一阶逻辑和证明</h1>
<h2 id="一阶逻辑的基本概念">一阶逻辑的基本概念</h2>
<p><strong>一阶逻辑(first-order logic)</strong>是对原子命题的结构进行细分，以便表达一类事物和单个具体事物之间的联系</p>
<p>一阶逻辑是一阶谓词逻辑的简称，他的谓词只作用于个体变量，量词也只作用于个体变量</p>
<p>进一步拆分带来以下几个概念</p>
<ul>
<li><strong>个体(individual)</strong>：原子命题要判断的事物</li>
<li><strong>谓词(predicate)</strong>：原子命题中给出的性质或关系</li>
<li><strong>量词(quantifier)</strong>：修饰事物类的词语</li>
</ul>
<p>一阶逻辑中将不确定的个体称为<strong>个体变量(individual variable)</strong>，用小写字母表示<strong>个体常量(indivudual constant)</strong>，一个谓词能作用的个体数目称为谓词的<strong>元数(arity)</strong></p>
<p>出现量词的命题被称为量化命题(quantification proposition)，其用到的个体变量所表示的不确定个体所属的事物类被称为该个体变量的<strong>论域(domain)</strong></p>
<p>量化命题进一步分类，有两种</p>
<ul>
<li>全称命题</li>
<li>存在命题</li>
</ul>
<h2 id="一阶逻辑公式">一阶逻辑公式</h2>
<h3 id="一阶逻辑公式的符号和语法">一阶逻辑公式的符号和语法</h3>
<p>对于一阶逻辑公式，符号集被分为两类，一类是逻辑符号，包含</p>
<ul>
<li><p>个体变量符号</p></li>
<li><p>逻辑运算符号</p></li>
<li><p>左右圆括号，<strong>逗号</strong></p></li>
<li><p><strong>量词符号</strong></p>
<blockquote>
<p>逗号和量词符号是相比命题逻辑公式新加入的符号</p>
</blockquote></li>
</ul>
<p>另一类是非逻辑符号，包括</p>
<ul>
<li><p>个体常量符号</p></li>
<li><p>函数符号</p></li>
<li><p>谓词符号</p>
<blockquote>
<p>非逻辑符号是对具体讨论内容的抽象，比如数集、集合都有各自不同的符号集</p>
</blockquote></li>
</ul>
<p>对于个体变量，由于量词的作用，定义3.4可以拆分为</p>
<ul>
<li><p>量词中的个体变量，被称为指示变量，这个量词的自公式为这个量词的<strong>辖域(scope)</strong></p></li>
<li><p>如果一个个体变量既是指示变量，还出现在对应的辖域里，那么他的出现是约束出现，否则就是自由出现</p></li>
<li><p>当一个公式里存在一个自由出现的个体变量，那么这个变量就是公式的<strong>自由变量(free variable)</strong>，若都是约束出现，就是<strong>约束变量(bound variable)</strong></p>
<blockquote>
<p>自由变量就像是计算机程序中的全局变量，对整个公式都有用，相应的，约束变量类似于局部变量</p>
<p>同名的约束变量处于不同辖域中，这类似于两个恰好同名的局部变量</p>
</blockquote></li>
<li><p>没有自由变量的公式就被称为<strong>闭公式(closed formula)或句子(sentence)</strong></p></li>
</ul>
<p>通过约束变量改名和自由变量替换，可以对公式的表达进行变换</p>
<h3 id="一阶逻辑公式的语义">一阶逻辑公式的语义</h3>
<h2 id="一阶逻辑的等值演算">一阶逻辑的等值演算</h2>
<h3 id="基本等值式模式">基本等值式模式</h3>
<ul>
<li>消除量词等值式：<span class="math inline">\(\forall{x}A(x)\equiv{ {A_1}\cap{A_2}\cap{...}{A_1}\cap}\)</span></li>
<li>量词否定等值式</li>
<li>量词分配等值式</li>
</ul>
<h3 id="前束范式">前束范式</h3>
<p>直观的讲，<strong>前束范式(prenex normal form)</strong>就是所有量词约束都在最前面的一阶逻辑公式</p>
<h2 id="一阶逻辑的">一阶逻辑的</h2>
<p>引入了一种新的推理表达方式<span class="math inline">\({ {P_1},{P_2},{...},{P_n} }\over{C}\)</span>，其中横线上方为条件，下方为结论</p>
<p>一阶逻辑的推理规则一部分继承自命题逻辑公式，另一部分主要是关于量词的推理规则</p>
<ul>
<li>全称例化(universal instantiation)</li>
<li>全称泛化(universal generalization)</li>
<li>存在例化(existential instantiation)</li>
<li>存在泛化(existential generalization)</li>
</ul>
<p>进行推理时，常常先得到等价的前束范式</p>
<h1 id="证明">证明</h1>
<h2 id="概述">概述</h2>
<h2 id="基本证明方法">基本证明方法</h2>
<h3 id="直接证明">直接证明</h3>
<h3 id="反证">反证</h3>
<h2 id="归纳证明">归纳证明</h2>
<h3 id="第一归纳证明数学归纳法">第一归纳证明/数学归纳法</h3>
<h3 id="第二归纳证明强归纳法">第二归纳证明/强归纳法</h3>
<h1 id="集合-1">集合</h1>
<h2 id="概念">概念</h2>
<ul>
<li><p>康托尔认为，任何一堆东西都可以成为一个集合，这被称为<strong>朴素集合论(naive set theory)</strong>；后来人们以多条公理的形式界定集合，发展出<strong>公理集合论(axiomatic set theory)</strong></p>
<blockquote>
<p>朴素集合论可能导致悖论</p>
</blockquote></li>
<li><p>对于要讨论的最小的不可再分的集合，称为<strong>全集(universal set)</strong></p></li>
<li><p>集合中的每个东西被称为<strong>元素</strong>，元素属于集合，集合包含元素</p></li>
<li><p>定义两个集合之间的包含关系，一方为<strong>子集(subset)</strong>，另一方为<strong>超集(super set)</strong>；当两者不互相为集合时，一方为<strong>真子集(proper set)</strong></p></li>
<li><p>由于集合的子集也可以是集合，当强调这个情况时，我们考虑<strong>全总域</strong><span class="math inline">\(u\)</span>；称一个元素全部为集合的集合为<strong>集合族(a family of set)</strong></p></li>
<li><p>根据外延原则，定义集合的相等</p>
<blockquote>
<p>在哲学和语言学中，我们称一个概念的外延是它所指的对象/元素，内涵则是他的本质；对于集合，外延也就是它包含的元素，内涵则是他究竟是要指什么，是怎样产生的。</p>
<p>比如说，《朝花夕拾》和《狂人日记》的作者分别是两个集合，他们包含的都是猹，但所指代的目标不同，我们仍定义这两个集合相等</p>
</blockquote></li>
</ul>
<h3 id="集合的描述">集合的描述</h3>
<ul>
<li><p>归纳定义法</p></li>
<li><p>元素枚举法：<span class="math inline">\(S={x|P(x)}\)</span>，进一步的为了避免悖论得到<span class="math inline">\(S={x\in{B}|P(x)}\)</span></p>
<blockquote>
<p>在这种条件下，有罗素悖论<span class="math inline">\(S={x|x\notin{x} }\)</span>；为此我们引入<strong>子集分离公理</strong>，这样可以限定论域避免悖论的出现</p>
</blockquote></li>
<li><p>性质概括法：<span class="math inline">\(S={f(x)|P(x)}\)</span></p></li>
<li><p>文氏图</p></li>
<li><p>成员关系表</p></li>
</ul>
<h2 id="集合的运算">集合的运算</h2>
<p>再给定全集的情况下，集合运算对于全集的幂集封闭而构成了完整的集合代数系统</p>
<ul>
<li><p>交(intersection)</p>
<p>广义交(generalized intersection)</p></li>
<li><p>并集(union)</p>
<p>广义并(generalized union)</p></li>
<li><p>差(difference)</p></li>
<li><p>绝对补/补(complement)</p></li>
<li><p>幂集(power set)</p></li>
</ul>
<h2 id="等式">等式</h2>
<h3 id="定义证明">定义证明</h3>
<h3 id="等式演算">等式演算</h3>
<p>首先有一系列运算律</p>
<ul>
<li>同一律</li>
<li>零律</li>
<li>矛盾律</li>
<li>排中律</li>
<li>双重否定率</li>
<li>幂等律</li>
<li>交换律</li>
<li>结合律</li>
<li>分配率</li>
<li>吸收率</li>
<li>德摩根律</li>
<li>集合差等式</li>
<li>全补律</li>
<li>相对德摩根律</li>
</ul>
<h3 id="子集关系和集合等式">子集关系和集合等式</h3>
<ul>
<li>集合交于子集关系</li>
<li>集合并与子集关系</li>
<li>集合差与子集关系</li>
<li>幂集运算保持子集关系</li>
</ul>
<h1 id="关系-1">关系</h1>
<h2 id="概念-1">概念</h2>
<ul>
<li><p>定义有序对(ordered pair)<span class="math inline">\(&lt;a,b&gt;\)</span>，称a为第一个元素，b为第二个元素；同理定义n-元组(n-ary tuple)</p>
<blockquote>
<p>关系型数据库就是基于n元关系</p>
</blockquote></li>
<li><p>定义两个集合的笛卡尔积(Cartesian product)，记为<span class="math inline">\(A\times{B}\)</span></p>
<blockquote>
<p>笛卡尔积既不满足结合律也不满足交换律，但满足分配率</p>
</blockquote></li>
<li><p>定义A和B的二元关系(binary relation from A to B)是笛卡尔积<span class="math inline">\(A\times B\)</span>的子集；特别的，定义A上的关系(relation on A)</p>
<p>有时将A和B之间的关系R写作<span class="math inline">\(a R b\)</span>，通常是将R定义为符号时使用</p></li>
<li><p>空集<span class="math inline">\(\Phi\)</span>也是一种关系，被称为空关系；整个笛卡尔积<span class="math inline">\(A\times B\)</span>被称为全关系</p>
<blockquote>
<p>从集合角度讨论关系时，全集一般就是指全关系</p>
</blockquote></li>
<li><p>特别的，恒等关系(identity relation)/对角关系(diagonal relation)，记为<span class="math inline">\(\Delta_{A}=\{&lt;a,a&gt;|a\in{A}\}\)</span></p>
<blockquote>
<p>数学上，恒等(identity)往往强调同一个元素，相等的情况则要多得多</p>
</blockquote></li>
</ul>
<h3 id="表示">表示</h3>
<ul>
<li><p>性质概括法</p></li>
<li><p>元素枚举法</p></li>
<li><p>关系图：使用一个有向图来表示，顶点集为两个集合的元素，边集为关系；特别的，指向自己的有向边被称为环</p></li>
<li><p>关系矩阵：使用一个矩阵来描述，有关系的两个元素用1表示</p>
<p>不难理解全关系是全1矩阵，恒等关系是单位矩阵</p></li>
</ul>
<h3 id="关系运算">关系运算</h3>
<ul>
<li><p>逆关系(inverse relation)，定义<span class="math inline">\(R^{-1}=\{&lt;b,a&gt;|&lt;a,b&gt;\in{R}\}\)</span></p></li>
<li><p>关系的复合(composite)使用<span class="math inline">\(S\circ{R}\)</span>表示</p>
<blockquote>
<p>注意逆序复合和顺序复合的书写方式区别</p>
</blockquote></li>
<li><p>可以通过关系矩阵的计算来进行关系运算</p>
<ul>
<li><p>关系并集：分别作逻辑或运算</p></li>
<li><p>关系交集：分别作逻辑与运算</p></li>
<li><p>关系差集：当且仅当前者为1后者为0时为1</p></li>
<li><p>关系的逆：关系矩阵的转置</p></li>
<li><p>关系的复合：对两个关系矩阵做矩阵逻辑积(logic product)</p>
<blockquote>
<p>只需将矩阵相乘时加法用逻辑或，乘法用逻辑与代替</p>
</blockquote></li>
</ul></li>
<li><p>关系逆对关系并、交都有可交换性(commutative)</p></li>
<li><p>关系逆具有传递性</p>
<blockquote>
<p>以上是关系逆的一些性质</p>
</blockquote></li>
<li><p>关系复合满足结合律</p></li>
<li><p>关系复合的单位元是恒等关系</p></li>
<li><p>关系复合保持子集关系</p></li>
<li><p>关系复合对集合并有分配律，集合交没有分配律，但有<span class="math inline">\({T\circ(R)},{}\)</span></p>
<blockquote>
<p>这是因为存在量词对析取有分配律，对合取并没有 以上是关系复合的一些性质</p>
</blockquote></li>
</ul>
<h2 id="性质">性质</h2>
<h3 id="自反性reflexive与反自反性irreflexive">自反性(reflexive)与反自反性(irreflexive)</h3>
<ul>
<li>元素考察法定义：对于任意元素<span class="math inline">\(a\in{A}\)</span>，都有<span class="math inline">\(&lt;a,a&gt;\in R\)</span>有自反性(reflexsive)；对于任意元素<span class="math inline">\(a\in{A}\)</span>，都有<span class="math inline">\(&lt;a,a&gt;\notin R\)</span></li>
<li>性质概括法定义：<span class="math inline">\(\Delta_A\subseteq{R}\)</span>；<span class="math inline">\(\Delta_A\cap R=\Phi\)</span></li>
<li>自反和反自反不是互为否定的性质</li>
<li>存在既不是自反也不是反自反的关系</li>
<li>空集上的空关系既是自反也是非自反关系</li>
<li>对一个含有<span class="math inline">\(n\)</span>个元素的集合，满足自反性的关系有<span class="math inline">\(2^{n^2-n}\)</span>个</li>
<li>从关系图上看，自反关系的每一个点都有环；反自反关系的每一个点都没有环</li>
<li>从关系矩阵上看，自反关系的关系矩阵对角线都为1；反自反对角线都为0</li>
</ul>
<h3 id="对称性symmetric与反对称性antisymmetric">对称性(symmetric)与反对称性(antisymmetric)</h3>
<ul>
<li>元素考察法定义：对于任意元素<span class="math inline">\(a,b\)</span>，有<span class="math inline">\({&lt;a,b&gt;\in{R} }\rightarrow{&lt;b,a&gt;\in{R} }\)</span>有对称性(symmetric);对于任意元素<span class="math inline">\(a,b\)</span>，有<span class="math inline">\(({&lt;a,b&gt;\in{R} }\cap{&lt;b,a&gt;\in{R} })\rightarrow{a=b}\)</span>;</li>
<li>性质概括法定义：<span class="math inline">\(R=R^{-1}\)</span>；<span class="math inline">\(R\cap R^{-1}=\Delta_A\)</span></li>
<li>对称和反对称也不是互为否定的性质</li>
<li>蕴涵一般就是既不对称也不反对称的一种关系</li>
<li>对一个含有<span class="math inline">\(n\)</span>个元素的集合，满足自反性的关系有<span class="math inline">\(2^{ {n(n+1)}\over{2} }\)</span>个</li>
<li>对称的关系图每两个之间的边是成对儿出现的；反对称关系每条边之间至多有一条边</li>
<li>对称的关系矩阵是对称矩阵；反对称的对称位置元素不相等</li>
</ul>
<h3 id="传递性transitive">传递性(transitive)</h3>
<ul>
<li>元素考察法定义：对任意<span class="math inline">\(a,b\)</span>，称<span class="math inline">\({ {&lt;a,b&gt;\in{R} }\cap{&lt;b,c&gt;\in{R} }\rightarrow{&lt;a,c&gt;\in{R} } }\)</span>为传递性(transitive)</li>
<li>性质概括法定义：<span class="math inline">\(R\circ{R}\subseteq{R}\)</span></li>
<li>对一个含有<span class="math inline">\(n\)</span>个元素的集合，满足自反性的关系有<span class="math inline">\({2^n}{\cdot}{3^{ {n^2-n}\over{2} } }\)</span>个</li>
<li>传递关系的关系图的任何两个顶点之间，如果有长度大于或等于2的有向通路，则他们之间有直接的有向边</li>
</ul>
<h3 id="关系运算的性质">关系运算的性质</h3>
<p>关系在运算后，总是有性质能否保持以及如何证明的问题。</p>
<p>运算和性质之间的联系可以整理为下表，1表示保持关系</p>
<table>
<thead>
<tr class="header">
<th>运算</th>
<th>自反性</th>
<th>反自反性</th>
<th>对称性</th>
<th>反对称性</th>
<th>传递性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>关系逆</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>集合交</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>集合并</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>集合差</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>关系复合</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>此处进行证明时有一些常用的思路和思考记忆方式</p>
<ol type="1">
<li>优先考虑性质概括法</li>
<li>涉及到集合并的证明时，必须考虑分情况证明（即给定关系究竟包含于哪个集合）</li>
<li>关系逆和集合交由非常良好的性质；集合并由于逻辑析取不具有分配的能力，因此不具有反对称性和传递性；集合差可能导致自反关系丢失、也可能带来传递关系的消失；关系复合只能保持自反性。</li>
</ol>
<h2 id="闭包">闭包</h2>
<p>关系的闭包(closure)是指包含一个关系且满足某个性质的最小关系。</p>
<blockquote>
<p>离散&amp;计算机科学</br> 以传递闭包为例。文件编译时，需要同时编译的依赖文件通过依赖关系传递，因此一次编译时需要得到该文件的传递闭包，确保所有需要编译的文件都能被编译并正确链接。</p>
</blockquote>
<p>我们讨论的闭包有三种</p>
<ul>
<li>自反闭包(reflexive closure)，记作r(R)</li>
<li>对称闭包(symmetric closure)，记作s(R)</li>
<li>传递闭包(transitive clsure)，记作t(R)</li>
</ul>
<p>这三种关系的定义是相似的，以自反关系<span class="math inline">\(R\)</span>为例，重点关注她的自反闭包<span class="math inline">\(r(R)\)</span>第三个条件。</p>
<ol type="1">
<li><span class="math inline">\(R{\subseteq}r(R)\)</span></li>
<li><span class="math inline">\(r(R)\)</span>是自反关系</li>
<li>对任意自反关系<span class="math inline">\(S\)</span>，如果<span class="math inline">\(R{\subseteq}S\)</span>，一定有<span class="math inline">\(r(R){\subseteq}S\)</span> &gt; 这保证了<span class="math inline">\(r(R)\)</span>一定是<span class="math inline">\(R\)</span>为基础所有自反关系的子集，保证该闭包是“最小”的。</li>
</ol>
<blockquote>
<p>当一个关系不具有上面三种性质时，我们可以通过国添加最少的有序对来得到这种性质；但反自反和反对称并不行</p>
</blockquote>
<ul>
<li>如果一个关系已经有了某种性质，那么这个关系关于这个性质的闭包就是他自己</li>
<li>自反与对称闭包都对集合并满足可交换性（这主要由集合并运算保持关系的子反性和对称性决定）</li>
</ul>
<h3 id="计算关系闭包">计算关系闭包</h3>
<ul>
<li><p><span class="math inline">\(r(A)=R\cap{\Delta_A}\)</span></p></li>
<li><p><span class="math inline">\(s(R)=R\cup{R^{-1} }\)</span></p></li>
<li><p><span class="math inline">\(t(R)=\bigcup^{\infty}_{n=1}{R^n}，其中\bigcup^{\infty}_{n=1}{R^n}也被记作R^*\)</span></p>
<blockquote>
<p>我们可以对其简化，对于大于n的通路，一定至少有一个重复的顶点，也就是有一个小于等于n的通路，该式可以等价的化作<span class="math inline">\(t(R)=\bigcup^{n}_{k=1}{R^k}\)</span></p>
</blockquote></li>
</ul>
<h3 id="warshall算法">Warshall算法</h3>
<h2 id="两个特殊关系">两个特殊关系</h2>
<h3 id="等价关系">等价关系</h3>
<ul>
<li><p>如果R是自反、对称且传递，称R为等价关系(equivalence relation)</p></li>
<li><p>由等价关系，定义元素<span class="math inline">\(a\in{A}\)</span>所在的等价关系<span class="math inline">\(R\)</span>的等价类(equivalence class)，也就是所有与<span class="math inline">\(a\)</span>有关系<span class="math inline">\(R\)</span>的元素的集合，记作<span class="math inline">\([a]_R\)</span></p></li>
<li><p>对于元素<span class="math inline">\(b\in{[a]_R}\)</span>，b为等价类的一个代表(representative)；特别的，a自身也是<span class="math inline">\([a]_R\)</span>的一个代表</p></li>
<li><p>集合A下，所有元素的等价类，所组成的集合称为集合A关于等价关系R的商集(quotient set)，记作<span class="math inline">\(A/R\)</span></p>
<blockquote>
<p>注意等价类是一个集合，商集则是集合的集合即集合族</p>
</blockquote></li>
<li><p>对于等价类，有以下引理</p>
<ul>
<li><span class="math inline">\([a]_R=[b]_R\)</span>，当且仅当<span class="math inline">\(&lt;a,b&gt;\in{R}\)</span></li>
<li><span class="math inline">\([a]_R\cap[b]_R=\Phi\)</span>，当且仅当<span class="math inline">\(&lt;a,b&gt;\notin{R}\)</span></li>
</ul></li>
<li><p>商集的基本性质</p>
<ul>
<li>对任意的<span class="math inline">\(a\in{A}\)</span>，有<span class="math inline">\([a]_R\neq\Phi\)</span></li>
<li>对任意的<span class="math inline">\(a,b\in{A}\)</span>，有<span class="math inline">\([a]_R=[b]_R\)</span>且<span class="math inline">\([a]_R\cap[b]_R{\neq}\Phi\)</span></li>
<li><span class="math inline">\(\bigcup_{a\in{A} }{[a]_R}=A\)</span>，即<span class="math inline">\(\bigcup{A/R}=A\)</span></li>
</ul></li>
</ul>
<p>下面给出循环证明</p>
<p><span class="math display">\[
\begin{array}{l}
由aRb证明[a]=[b]:\\
{\forall{x}\in[a]}{\Rightarrow}(a,x){\in}R{\quad(1)}\\
aRb{\Rightarrow}(a,b){\in}R{\Rightarrow}(b,a){\in}R{\quad(2)}\\
由(1)和(2)得，(b,x){\in}R{\Rightarrow}{x{\in}[b]}\\
{\therefore}[a]{\subseteq}[b]，同理，可以得到[b]{\subseteq}[a]\\
所以[a]=[b]
\end{array}
\]</span></p>
<p>如果两个关系<span class="math inline">\(R_1\)</span>和<span class="math inline">\(R_2\)</span>是等价关系，那么<span class="math inline">\({(R_1{\cap}R_2)}^*\)</span>也是等价关系。</p>
<h3 id="划分和划分块">划分和划分块</h3>
<ul>
<li>定义满足性质的集合族为<strong>集合的划分(partition)</strong></li>
<li>划分的每一个集合称为这个划分的一个<strong>划分块(block)</strong></li>
<li>每个划分都可以导出一个等价关系</li>
</ul>
<p>要求一个具有<span class="math inline">\(n\)</span>个元素的集合上的等价关系（划分）的个数，有以下递推公式</p>
<p><span class="math display">\[
\begin{array}{l}
B(0)=1\\
B(1)=1\\
B(n+1)={\sum_{k=0}^{n} }{C_n^k}{B(k)},{n{\ge}1}
\end{array}
\]</span></p>
<h3 id="偏序关系">偏序关系</h3>
<ul>
<li><p>如果R是自反、反对称且传递的，称R为偏序关系(partial order)</p></li>
<li><p>称一个反自反、传递关系为严格序关系(strict order)</p>
<blockquote>
<p>不难证明反自反、传递可以推出反对称</p>
</blockquote></li>
<li><p>称一个自反、传递关系为拟序关系(quasi-order)</p></li>
<li><p>定义偏序集(partial order set)</p>
<blockquote>
<p>偏序集之所以叫偏序集，就是因为他的元素之间不一定是可比的</p>
</blockquote></li>
<li><p>定义两个元素之间存在偏序关系为可比的(comparable)，以及不可比的。如果偏序集的任意两个元素都可比，称它为全序(total order)/线序(linear order)。如果全序集的每一个子集都有一个最小元素，称为良序集(ell-ordered)</p></li>
<li><p>如果对于<span class="math inline">\(A\)</span>中元素，如果<span class="math inline">\(a&lt;b\)</span>，且不存在<span class="math inline">\(c\)</span>使得<span class="math inline">\(a&lt;c\)</span>且<span class="math inline">\(c&lt;b\)</span>称<span class="math inline">\(b\)</span>，覆盖(cover)<span class="math inline">\(c\)</span></p></li>
<li><p>定义偏序集的极大元(maximal element)和极小元(minimal element)</p></li>
<li><p>定义偏序集的最大元(greatest element)和最小元(least element)</p></li>
<li><p>定义偏序集的上界(upper bound)和下界(lower bound)</p></li>
<li><p>定义偏序集的上确界(least upper bound, lub)和下确界(greatest lower bound, glb)</p></li>
<li><p>如果一个偏序集的每对元素都有最小上界和最大下界，就称这个偏序集为格(lattice)。由定义知，所有的全序都是格，但并非所有的偏序集都是格。</p></li>
</ul>
<blockquote>
<p>举个例子，对于偏序关系<span class="math inline">\(({\mathbb{Z}^+},|)\)</span>，他的上确界是两个元素的最小公倍数(least common multiple)，下确界是两个元素的最大公约数(greatest common divisor)，因此它是一个格。</p>
</blockquote>
<ul>
<li>从一个偏序构造一个相容的全序叫做拓扑排序(topological sorting)</li>
</ul>
<h3 id="字典顺序lexicographic-ordering">字典顺序(lexicographic ordering)</h3>
<h1 id="函数-1">函数</h1>
<h2 id="概念性质和运算">概念、性质和运算</h2>
<h2 id="基数">基数</h2>
<h2 id="算法分析">算法分析</h2>
<h1 id="算法">算法</h1>
<h2 id="组合计数基本原理">组合计数基本原理</h2>
<h2 id="排列组合">排列组合</h2>
<h2 id="递推关系">递推关系</h2>
<h1 id="图论">图论</h1>
<h2 id="图的基本知识">图的基本知识</h2>
<h2 id="树的基本知识">树的基本知识</h2>
<h2 id="带权图">带权图</h2>
<h2 id="特殊的图">特殊的图</h2>
<h1 id="代数系统">代数系统</h1>
<h2 id="集合运算">集合运算</h2>
<blockquote>
<p>详见“近世代数”</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数学</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>科目一考点</title>
    <url>/blog/posts/53332/</url>
    <content><![CDATA[<h2 id="证件">证件</h2>
<ul>
<li>假一吊二撤三醉五逃终生</li>
<li>补领驾驶证or驾驶证损毁丢失-核发地</li>
<li>更换驾驶证-居住地或所在地</li>
<li>更换行驶证-登记地车管所</li>
<li>申请驾驶车型年龄</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- 18+:小型汽车，小型自动挡汽车，残疾人专用小型自动挡载客汽车，轻便摩托车
- 18-60：低速载货汽车、三轮汽车、普通三轮摩托车、普通二轮摩托车或轮式机械车
- 20-50：城市公交车、大型货车、无轨电车
- 21-50：中型客车
- 24-50：牵引车
- 26-50：大型客车</code></pre></div>
<ul>
<li>驾驶证有六年、十年和长期三类有效期</li>
</ul>
<hr />
<h2 id="速度">速度</h2>
<ul>
<li>普通道路限速</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Title</th>
<th>城市道路</th>
<th>公路</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>无中心线</td>
<td>30</td>
<td>40</td>
</tr>
<tr class="even">
<td>有中心线</td>
<td>50</td>
<td>70</td>
</tr>
</tbody>
</table>
<ul>
<li>两车道高速公路 100-120，60-100</li>
<li>三车道高速公路 110-120，90-110，60-90</li>
<li>公路车速大于100 100m以上；小于100 50m以上</li>
</ul>
<hr />
<h2 id="酒驾">酒驾</h2>
<ul>
<li>公安机关交通管理部门约束至酒醒</li>
<li>200-2000元罚款并处吊销驾驶证</li>
<li>五年内不得考取驾驶证（“醉五”）</li>
<li>酒驾20-80，醉驾80-100</li>
</ul>
<hr />
<h2 id="行车">行车</h2>
<ul>
<li>高速路会车150米外改为近光灯</li>
<li>公交站30米内 路口、窄路50米内不得停车</li>
<li>肇事逃逸</li>
</ul>
<table>
<thead>
<tr class="header">
<th>撞人</th>
<th>处罚</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>没死 逃逸</td>
<td>3年以下</td>
</tr>
<tr class="even">
<td>逃逸or撞伤后逃逸</td>
<td>3~7年</td>
</tr>
<tr class="odd">
<td>死了 跑了</td>
<td>7年以上</td>
</tr>
</tbody>
</table>
<ul>
<li>能见度（261，145，520）</li>
</ul>
<table>
<thead>
<tr class="header">
<th>能见度</th>
<th>时速</th>
<th>车距</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>低于200米</td>
<td>60-</td>
<td>100+</td>
</tr>
<tr class="even">
<td>低于100米</td>
<td>40-</td>
<td>50+</td>
</tr>
<tr class="odd">
<td>低于50米</td>
<td>20-</td>
<td>-------</td>
</tr>
</tbody>
</table>
<ul>
<li>右让左 左让直 转弯让直行</li>
<li>连续驾驶超过四小时 休息不得少于20分钟</li>
<li>站30 口50</li>
</ul>
<hr />
<h2 id="罚款和吊销驾驶证">罚款和吊销驾驶证</h2>
<ul>
<li>车辆超速50%</li>
<li>酒驾</li>
<li>将机动车交由未取得机动车驾驶证或证件被吊销、暂扣的人</li>
<li>拼装车上路</li>
<li>重大交通事故<strong>构成犯罪</strong></li>
</ul>
<hr />
<h2 id="车辆申检">车辆申检</h2>
<ul>
<li>大中型客车、火车驾驶人每年申检 申报一次身体条件</li>
<li>70周岁以上每年一次身体检查</li>
<li>因服兵役、出国等无法办理申检 延期申检不超过<strong>三年</strong></li>
<li>有效期超过一年以上未换证将被注销</li>
<li>换发驾驶证需申检</li>
<li>信息发生变化要在<strong>30日</strong>内向当地车管所提出更换驾照信息</li>
<li>有效期满要在<strong>90日</strong>内换证</li>
</ul>
<hr />
<h2 id="扣分及处罚">扣分及处罚</h2>
<ul>
<li>12分</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- 在高速路上掉头、逆行、掉头、穿越中英分隔带掉头
- 在高速路上长时间占用应急车道
- 驾驶与准驾证不一样的车型
- 酒后驾驶
- 驾驶营运客车(不包括公共汽车)、校车载人超过核定任务20%以上
- 未悬挂机动车号牌、故意遮挡号牌、
- 使用假的车牌、驾驶证、行驶证
- 超过规定时速50%以上</code></pre></div>
<ul>
<li>6分</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">- 高速车道上停车
- 不按规定避让校车
- 不遵守交通信号
- 高速路超过限速20%不超过50%
- 驾驶证暂扣期间驾驶</code></pre></div>
<ul>
<li>酒驾和无照只扣12分</li>
<li>拼装车吊销驾驶证</li>
</ul>
<hr />
<h2 id="交通标线">交通标线</h2>
<h3 id="指示标线">指示标线</h3>
<p><strong>指示车道、行车方向、路面边缘、人行道、停车位、停靠站及减速丘</strong></p>
<h4 id="纵向标线">纵向标线</h4>
<ul>
<li>可跨越对向车行道分界线（黄色虚线）</li>
<li>可跨越同向车行道分界线（白色虚线）</li>
<li>潮汐车道线</li>
<li>车行道边缘线</li>
<li>左弯待转区线</li>
<li>路口导向线</li>
<li>导向车道线</li>
</ul>
<h4 id="横向标线">横向标线</h4>
<ul>
<li>人行横道线</li>
<li>车距确认线</li>
</ul>
<h4 id="其他标线">其他标线</h4>
<ul>
<li>道路出入口标线</li>
<li>停车位标线</li>
<li>停靠站标线</li>
<li>减速丘标线</li>
<li>导向箭头</li>
<li>路面文字标记</li>
<li>中心圈（交叉路口中心的白色圆形或菱形区域）</li>
<li>路面图形标记</li>
</ul>
<h3 id="禁止标线">禁止标线</h3>
<p><strong>告示道路交通的遵行、禁止、限制等特殊规定</strong></p>
<h4 id="纵向标线-1">纵向标线</h4>
<ul>
<li>禁止跨越对向车行道分界线</li>
<li>禁止跨越同向车行道分界线</li>
<li>禁止停车线</li>
</ul>
<h4 id="横向标线-1">横向标线</h4>
<ul>
<li>停止线</li>
<li>停车让行线</li>
<li>减速让行线</li>
</ul>
<h4 id="其他标线-1">其他标线</h4>
<ul>
<li>非机动车禁驶区标线</li>
<li>导流线</li>
<li>网状线</li>
<li>专用车道线</li>
<li>禁止掉头（转弯）线</li>
</ul>
<h3 id="警告标线">警告标线</h3>
<p><strong>促使道路使用者了解道路上的特殊情况 提高警觉准备防范应变措施</strong></p>
<h4 id="纵向标线-2">纵向标线</h4>
<ul>
<li>路面（车行道）宽度渐变段标线</li>
<li>接近障碍物标线</li>
<li>近铁路平交道口标线</li>
</ul>
<h4 id="横向标线-2">横向标线</h4>
<ul>
<li>减速标线</li>
</ul>
<h4 id="其他标线-2">其他标线</h4>
<ul>
<li>立面标记</li>
<li>实体标记</li>
</ul>
<hr />
<h2 id="交通标志">交通标志</h2>
<ul>
<li>蓝色最低限速 黄色建议速度 红色最高限速</li>
<li>车道上白色最低限速 黄色最高限速</li>
<li>交通标志分为主标志和辅助标志两大类</li>
<li>主标志有警告标志、禁令标志、指示标志和指路标志</li>
<li>警告标志：警告车辆与行人注意 黄底，黑边，黑图案，等边三角形，顶角朝上</li>
<li>禁令标志：禁止和限制车辆与行人</li>
<li>指示标志：指示车辆与行人行进 蓝底，没有文字</li>
<li>指路标志：传递方向与道路信息 蓝底，有文字</li>
<li>三角是减速让行 八角是停车让行</li>
<li>火车道牌一条斜线50m</li>
<li>空心突起驼峰桥 实心突起路面高凸</li>
<li>两个小孩警告标志注意儿童 一大一小指示标志需要步行 人过马路指示标志注意行人</li>
<li>线性诱导标志：一般道路为蓝底白图案，高速公路为绿底白图案。用于引导车辆驾驶人改变行驶方向，促使安全运行。警告性线性诱导标志为红底白图案。</li>
<li>合流有箭头，没有箭头就是汇入</li>
<li>两边虚线中间实线：港湾式停车道 全虚线：应急车道 没有线条：错车道</li>
</ul>
<hr />
<h2 id="交警手势">交警手势</h2>
<ul>
<li>交警看哪边就是指挥哪边</li>
<li>手不过腰摆动是变道</li>
</ul>
<hr />
<h2 id="其他">其他</h2>
<ul>
<li>路缘石黄色虚线禁止长时间停车 实线禁止停车</li>
<li>只有违法没有违章</li>
<li>鹿是野生动物 牛是牲畜</li>
<li>除更换驾照90天以外都是30天</li>
<li>在狭窄的坡路 上坡的一方先行；下坡的一方已行至中途时下坡的先行</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>当代大学牲实录</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/blog/posts/28245/</url>
    <content><![CDATA[<blockquote>
<p>参考资料</p>
<p>《工科数学线性代数》（同济）、《线性代数》（山大）</p>
<p>《线性代数应该怎样学》</p>
<p>《线性代数及其应用》、《Linear Algebra and its Application》</p>
</blockquote>
<h1 id="前言">前言</h1>
<h1 id="线性方程组">线性方程组</h1>
<h2 id="线性方程组和矩阵的引入">线性方程组和矩阵的引入</h2>
<p>这一节和下一节都是描述线性方程组与矩阵的关系</p>
<h3 id="线性方程和线性方程组">线性方程和线性方程组</h3>
<ul>
<li><p>线性方程(linear equation)的定义，线性方程组(system of linear equations, linear system)是一系列包含相同变量的线性方程组成的</p></li>
<li><p>方程组所有可能的解合称为解集(solution set)</p></li>
<li><p>具有相同解集的两个方程组是等价(equivalent)的</p>
<blockquote>
<p>求包含两个变量的线性方程组，等价于求两直线的交点</p>
</blockquote></li>
<li><p>对于任何一个线性方程组，我们称他是相容(consistent)的，当且仅当有唯一或无穷多个解；不相容(inconsistent)的，若他无解</p></li>
</ul>
<h3 id="矩阵的引入">矩阵的引入</h3>
<ul>
<li>任何一个线性方程组都可以使用一个矩阵(matrix)，我们使用维数(dimension)来说明他的行列数</li>
<li>对应线性方程组系数的矩阵被称为系数矩阵，包含常数列的被称为增广矩阵(augmented matrix)</li>
<li>可以通过初等行变换得到的两个矩阵，我们称他们是行等价的</li>
</ul>
<h3 id="线性方程组和初等行变换">线性方程组和初等行变换</h3>
<p>线性方程组有三个基本变换</p>
<ol type="1">
<li>Replacement：把某个方程换成它与另一方程的倍数的和</li>
<li>Interchange：交换两个方程的位置</li>
<li>Scaling：把某一方程的所有项乘一个非零常数</li>
</ol>
<p>矩阵也有三个初等行变换(Element Row Operations)</p>
<ol type="1">
<li>倍加变换：把某一行换成它与另一行的倍数的和</li>
<li>对换变换：交换两行的位置</li>
<li>对称变换：把某一行的所有元素乘同一个非零数</li>
</ol>
<blockquote>
<p>所有初等行变换都是可逆的</p>
</blockquote>
<h2 id="行化简到阶梯形矩阵">行化简到阶梯形矩阵</h2>
<h3 id="阶梯型矩阵">阶梯型矩阵</h3>
<ul>
<li>首先定义阶梯型矩阵(echelon form of matrix)</li>
<li>进一步定义简化阶梯型矩阵(reduced row echelon form)</li>
</ul>
<blockquote>
<p>通常我们会用REF作为阶梯型的缩写，RREF作为简化阶梯型的缩写</p>
<p>对于任意一个矩阵，有对应的多个阶梯形和唯一的简化阶梯形</p>
</blockquote>
<p>对于一个阶梯型，还有下面几个概念</p>
<ul>
<li>先导元素：某一非零行最左边的元素</li>
<li>主元位置(pivot position)：矩阵对应的简化阶梯形的先导元素位置</li>
<li>主元：在主元位置上的元素</li>
<li>主元列：含有主元位置的列</li>
</ul>
<h3 id="行化简算法">行化简算法</h3>
<h3 id="线性方程组的解">线性方程组的解</h3>
<ul>
<li>将线性方程组的增广矩阵化简到简化阶梯形后，位于主元列的变量被称为基本变量，非主元列的是自由变量</li>
<li>对一个相容的线性方程组，使用自由变量表示基本变量得到的就是它显式的通解</li>
<li>使用自由变量作为参数的解集的表达式，被称为解集的参数表示</li>
</ul>
<p>对于解的存在和唯一性，我们有解的存在与唯一性定理</p>
<ul>
<li>线性方程组相容的充要条件是增广矩阵的最右列不是主元列</li>
<li>当不存在自由变量，有唯一解；否则有无穷多解</li>
</ul>
<h2 id="向量方程">向量方程</h2>
<p>向量方程可以等价的变换成线性方程组和矩阵</p>
<h3 id="向量及其几何解释">向量及其几何解释</h3>
<ul>
<li><p>仅含一列的矩阵被称为列向量，或简称向量；有时为表示方便，会使用圆括号的方式表示向量</p>
<blockquote>
<p>对于数学来讲，我们称其为向量，在计算机中就是数组，对物理来讲就是矢量</p>
</blockquote></li>
<li><p>所有元素都是零的向量叫做零向量</p></li>
<li><p>向量有加法和数乘两种运算</p></li>
</ul>
<h3 id="线性组合及其几何解释">线性组合及其几何解释</h3>
<ul>
<li>我们称向量<span class="math inline">\(\mathbf{v}={ {c_1}\mathbf{v_1}+{c_2}\mathbf{v_2}+{...}+{c_n}\mathbf{v_n} }\)</span>为向量<span class="math inline">\({v_1},{v_2},{...},{v_n}\)</span>以<span class="math inline">\({c_1},{c_2},{...},{c_n}\)</span>为权的线性组合</li>
<li>根据向量加法，我们可以有线性组合得到线性方程组，进而得到增广矩阵</li>
<li>定义由<span class="math inline">\({v_1},{v_2},{...},{v_n}\)</span>的所有线性组合所成的集合，表示为<span class="math inline">\(Span\{ {v_1},{v_2},{...},{v_n}\}\)</span>，是由<span class="math inline">\({v_1},{v_2},{...},{v_n}\)</span>所张成/生成的<span class="math inline">\(R^n\)</span>的子集</li>
<li>要判断某个向量是否在几个向量张成的空间内，只需判断对应的向量方程是否有解</li>
</ul>
<h2 id="矩阵方程">矩阵方程</h2>
<p>线性代数的一个思想，就是把向量的线性组合看作矩阵，还有向量的积</p>
<ul>
<li>可以定义矩阵方程，以及他的形式<span class="math inline">\(A\mathbf{x}=\mathbf{b}\)</span></li>
</ul>
<h3 id="特殊矩阵">特殊矩阵</h3>
<ul>
<li>单位矩阵：<span class="math inline">\(I\mathbf{x}=\mathbf{x}\)</span></li>
<li>对角（线）矩阵：非对角线元素全是0的方阵</li>
<li>零矩阵：所有元素都是0的矩阵</li>
</ul>
<h2 id="线性方程组的解集">线性方程组的解集</h2>
<p>有了前面的铺垫，对于一个线性方程组，我们有三个视角1.线性方程组2.向量方程3.矩阵方程来看待它</p>
<h3 id="解集的表示形式">解集的表示形式</h3>
<p>由前面的求解方法，我们首先得到了通解的参数形式</p>
<p>由向量方程的角度，我们还可以得到通解的向量形式</p>
<blockquote>
<p>方程是对线性空间中平面或高维平面的隐式描述，解的向量形式就是对平面的显式描述</p>
</blockquote>
<h3 id="齐次线性方程组">齐次线性方程组</h3>
<ul>
<li><p>若一个线性方程组可以写成<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的形式，我们称它为齐次的。</p></li>
<li><p>对于齐次线性方程组，至少有一个平凡解，即<span class="math inline">\(\mathbf{x}=\mathbf{0}\)</span></p></li>
<li><p>当方程存在至少一个自由变量时，方程有非平凡解</p></li>
</ul>
<h3 id="非齐次线性方程组">非齐次线性方程组</h3>
<ul>
<li><p>非齐次线性方程组的通解的向量形式，一般为<span class="math inline">\(\mathbf{x}=\mathbf{p}+t\mathbf{v}\)</span></p>
<blockquote>
<p>他在集合上反映为平移</p>
</blockquote></li>
</ul>
<h2 id="线性相关和线性无关">线性相关和线性无关</h2>
<ul>
<li>定义向量之间的线性相关和线性无关</li>
<li>定义矩阵各列之间的线性相关和线性无关</li>
</ul>
<h3 id="一些性质和推论">一些性质和推论</h3>
<p>线性相关集存在某种特征，当某个集合线性相关，其中至少一个向量是其他向量的线性组合</p>
<blockquote>
<p>详见定理7和例4</p>
</blockquote>
<p>当一个向量组的向量个数，超过每个向量的元素个数，这个向量组一定线性相关</p>
<p>若向量组包含零向量，这个向量组一定线性相关</p>
<h2 id="线性变换">线性变换</h2>
<p>矩阵被作为一种对象，通过乘法，“作用”于向量，得到一个新的向量</p>
<h3 id="矩阵变换的概念和定义">矩阵变换的概念和定义</h3>
<ul>
<li>定义函数<span class="math inline">\(T:R^n \rightarrow R^m\)</span>是变换，其中<span class="math inline">\(R^n\)</span>为定义域，<span class="math inline">\(R^m\)</span>为余定义域/取值空间</li>
<li>对于<span class="math inline">\(R^n\)</span>中的向量，经过变换后的向量被称为像，所有像的集合被称为<span class="math inline">\(T\)</span>的值域</li>
</ul>
<p>给出几种常见的几何变换</p>
<ul>
<li>剪切变换</li>
<li>压缩变换和拉伸变换</li>
</ul>
<h3 id="线性变换-1">线性变换</h3>
<ul>
<li>线性变换的定义</li>
<li>线性变换保持向量的加法运算和标量乘法运算</li>
<li>每个矩阵变换都是线性变换</li>
<li>叠加原理：反复使用线性变换的性质，可以得到<span class="math inline">\(T({c_1}\mathbf{v_1}+{c_2}\mathbf{v_2}+{...}+{c_n}\mathbf{v_n})={c_1{T(v_1)}+c_2{T(v_2)}+{...}+c_n{T(v_n)} }\)</span></li>
<li>对于任何一个线性变换，都有对应的唯一一个标准矩阵</li>
</ul>
<h3 id="还是存在与唯一性问题">还是存在与唯一性问题</h3>
<ul>
<li><p>定义满射</p></li>
<li><p>定义单射，当且仅当方程<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>仅有平凡解时成立</p>
<blockquote>
<p>参考定理11</p>
</blockquote></li>
<li><p>对于一个线性变换<span class="math inline">\(T:{R^n}\rightarrow{R^m}\)</span></p>
<ul>
<li>A的列生成<span class="math inline">\(R^m\)</span>，T是满射</li>
<li>A的列线性无关，T是单射</li>
</ul></li>
</ul>
<h1 id="矩阵代数">矩阵代数</h1>
<blockquote>
<p>矩阵代数的内容就是字面意思，主要介绍矩阵之间的运算法则。</p>
<p>在学习过代数系统之后，一些讨论或许可以统一起来，比如逆矩阵与逆元、矩阵代数的定义和一个代数系统的定义</p>
<p>其中分块矩阵和矩阵因式分解是一些提高和优化运算速度的方法，同时提供了另一种处理矩阵的方式</p>
<p>子空间则会在向量空间继续探讨</p>
</blockquote>
<h2 id="矩阵的代数运算">矩阵的代数运算</h2>
<ul>
<li>对向量加法和标量乘法进一步推广，不难得到矩阵的加法和标量乘法</li>
</ul>
<h3 id="矩阵乘法">矩阵乘法</h3>
<ul>
<li>对一个向量<span class="math inline">\(\mathbf{x}\)</span>乘一个矩阵得到<span class="math inline">\(B\mathbf{x}\)</span>，再进行一次变换得到<span class="math inline">\(A(B\mathbf{x})=(AB)\mathbf{x}\)</span></li>
<li>由此可见矩阵乘法<span class="math inline">\(A(B\mathbf{x})\)</span>是线性变换的复合，新的线性变换的标准矩阵是<span class="math inline">\(AB\)</span></li>
<li>对于矩阵的第i行j列个元素，有<span class="math inline">\((AB)_{ij}=\Sigma^{n}_{k=1}{ {a_{ik} }{b_kj} }\)</span></li>
<li>矩阵乘法需要格外注意顺序。若AB=BA，则称A和B彼此可交换</li>
<li><span class="math inline">\(A^k\)</span>表示连续k个A的乘积，<span class="math inline">\(A^0\)</span>被定义为单位矩阵</li>
</ul>
<h3 id="矩阵的转置">矩阵的转置</h3>
<ul>
<li>给定一个<span class="math inline">\(m\times{n}\)</span>矩阵，用他的列构成行得到的<span class="math inline">\(n\times{m}\)</span>矩阵就是原矩阵的转置</li>
<li>矩阵转置有一个特殊的性质，若干个矩阵的乘积的转置，等于每个矩阵的转置的相反顺序的乘积</li>
</ul>
<h2 id="矩阵的逆">矩阵的逆</h2>
<blockquote>
<p>存在逆矩阵的一定是方阵</p>
</blockquote>
<ul>
<li>对一个方阵<span class="math inline">\(A\)</span>，如果能找到另一个矩阵<span class="math inline">\(C\)</span>,使得<span class="math inline">\(AC=I,CA=I\)</span>,则称这个方阵是可逆的</li>
<li>这里的矩阵<span class="math inline">\(C\)</span>由<span class="math inline">\(A\)</span>决定且唯一，我们记为<span class="math inline">\(A^{-1}\)</span></li>
<li>有时可逆矩阵被称为非奇异矩阵，不可逆矩阵被称为非奇异矩阵</li>
</ul>
<h3 id="逆矩阵的求解">逆矩阵的求解</h3>
<ul>
<li><p>给出2x2矩阵的可逆矩阵的直接公式，其逆矩阵的系数为行列式的倒数，矩阵为。。</p>
<blockquote>
<p>参考定理4</p>
</blockquote></li>
<li><p>根据公式，当且仅当2x2矩阵的行列式<span class="math inline">\(det A \neq{0}\)</span>时，2x2矩阵可逆</p></li>
<li><p>逆矩阵也有一个特殊的性质，若干个矩阵的逆，等于每个矩阵的逆的相反顺序的乘积</p></li>
<li><p>对增广矩阵<span class="math inline">\([A \ I]\)</span>进行化简，<span class="math inline">\([A \ I]\)</span>行等价于<span class="math inline">\([I A^{-1}]\)</span>，否则没有逆</p></li>
</ul>
<h3 id="初等矩阵">初等矩阵</h3>
<ul>
<li>对单位矩阵进行一次初等行变换得到的就是初等矩阵</li>
<li>初等矩阵是可逆的</li>
<li>当且仅当方阵行等价于单位矩阵，该方阵是可逆的，他化简为单位矩阵的变换矩阵就是他的逆矩阵</li>
<li>对三种初等矩阵
<ul>
<li><span class="math inline">\(E\)</span>是一个行倍加(矩阵)，若<span class="math inline">\(E\)</span>由一次行倍加变换得到</li>
<li><span class="math inline">\(E\)</span>是一个交换，若<span class="math inline">\(E\)</span>由一次交换得到</li>
<li><span class="math inline">\(E\)</span>是一个<span class="math inline">\(r\)</span>倍乘，若<span class="math inline">\(E\)</span>由一次<span class="math inline">\(r\)</span>倍乘得到</li>
</ul></li>
</ul>
<h3 id="可逆矩阵定理">可逆矩阵定理</h3>
<p>设<span class="math inline">\(A\)</span>为<span class="math inline">\(n\times n\)</span>矩阵，下列命题是等价的</p>
<ol type="1">
<li><p><span class="math inline">\(A\)</span>是可逆矩阵。</p>
<blockquote>
<p>1可由7证明</p>
</blockquote></li>
<li><p>存在<span class="math inline">\(n\times n\)</span>矩阵<span class="math inline">\(C\)</span>使得<span class="math inline">\(CA=I\)</span>。</p></li>
<li><p>存在<span class="math inline">\(n\times n\)</span>矩阵<span class="math inline">\(D\)</span>使得<span class="math inline">\(AD=I\)</span>。</p>
<blockquote>
<p>根据可逆矩阵的定义，<span class="math inline">\(1\rightarrow{2,3}\)</span></p>
</blockquote></li>
<li><p><span class="math inline">\(A\)</span>的各列线性无关。</p></li>
<li><p>对于向量空间<span class="math inline">\(R^n\)</span>中任意向量<span class="math inline">\(\mathbf{b}\)</span>，方程<span class="math inline">\(A\mathbf{x}=\mathbf{b}\)</span>有且仅有一个解。</p>
<blockquote>
<p>由命题3，有</p>
<p><span class="math inline">\(AD\mathbf{b}=I\mathbf{b}=\mathbf{b}\)</span>，得<span class="math inline">\(A(D\mathbf{b})=\mathbf{b}\)</span></p>
<p>所以<span class="math inline">\(\mathbf{x}=D\mathbf{b}\)</span>为唯一解</p>
</blockquote></li>
<li><p><span class="math inline">\(A\)</span>的各列张成<span class="math inline">\(R^n\)</span>。</p>
<blockquote>
<p>命题6和命题5完全等价，</p>
</blockquote></li>
<li><p><span class="math inline">\(A\)</span>行等价于单位矩阵。</p>
<blockquote>
<p>已知<span class="math inline">\(A\)</span>是方阵且有<span class="math inline">\(n\)</span>个主元位置，则主元必然位于主对角线上（<span class="math inline">\(n\)</span>个主元位置在不同的行）。所以<span class="math inline">\(A\)</span>的行最简形是单位矩阵<span class="math inline">\(I_n\)</span></p>
</blockquote></li>
<li><p>方程<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>仅有平凡解。</p>
<blockquote>
<p>由于<span class="math inline">\(CA\mathbf{x}=C(A\mathbf{x})=C\mathbf{0}=\mathbf{0}\)</span></p>
<p>引入2，有<span class="math inline">\(CA\mathbf{x}=(CA)\mathbf{x}=I\mathbf{x}=\mathbf{0}\)</span></p>
<p>由此可得<span class="math inline">\(\mathbf{x}=\mathbf{0}\)</span></p>
</blockquote></li>
<li><p><span class="math inline">\(A.T\)</span>是可逆矩阵。</p></li>
<li><p><span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个主元位置，有<span class="math inline">\(n\)</span>个主元列，没有自由元。</p>
<blockquote>
<p>由8，可知矩阵<span class="math inline">\(A\)</span>没有自由变量，因此命题10</p>
</blockquote></li>
</ol>
<h2 id="分块矩阵">分块矩阵</h2>
<ul>
<li>定义矩阵的分块矩阵(partitioned matrix)</li>
<li>分块矩阵继承矩阵的加法和标量乘法</li>
<li>分块矩阵的乘法适用行列规则</li>
</ul>
<h3 id="分块矩阵的逆">分块矩阵的逆</h3>
<ul>
<li>显然</li>
</ul>
<h2 id="矩阵因式分解">矩阵因式分解</h2>
<blockquote>
<p>矩阵因式分解是对数据的分解，在数据处理过程中往往被称为对数据的预处理；矩阵的乘法则是对数据的综合</p>
</blockquote>
<ul>
<li>矩阵的因式分解(factorization)就是将矩阵表示为两个或多个矩阵的乘积</li>
</ul>
<h3 id="lu分解">LU分解</h3>
<ul>
<li>LU分解用于求解一系列具有相同系数矩阵，但<span class="math inline">\(b\)</span>不同的线性方程</li>
<li>LU分解(LU factorization)将矩阵分解为<span class="math inline">\(L_{m\times{m} }\)</span>，一个单位下三角矩阵，和<span class="math inline">\(U_{m\times{n} }\)</span>，一个阶梯型矩阵，的乘积，即<span class="math inline">\(A=LU\)</span></li>
<li>对于方程<span class="math inline">\(A\mathbf{x}\mathbf{b}\)</span>，经LU分解后，可化为<span class="math inline">\((LU)\mathbf{x}=L(U\mathbf{x})=\mathbf{b}\)</span></li>
<li>如果将矩阵L化为单位下三角矩阵，我们称他为置换下三角矩阵L，这个LU分解称为置换LU分解</li>
<li>要进行LU分解，有一系列算法</li>
</ul>
<h2 id="子空间">子空间</h2>
<ul>
<li>注意前面提到的向量所有线性组合张成的空间<span class="math inline">\(Span\{\mathbf{v_1},\mathbf{v_2},{\dots},\mathbf{v_n}\}\)</span>是一个集合，我们现在给他一个名字叫做<span class="math inline">\(R^n\)</span>的子空间(subspace)</li>
<li>子空间满足三个性质，简单地说就是包含1.零向量2.对加法和标量乘法封闭</li>
<li>特别的，我们定义一个仅含有零的子空间为零子空间</li>
</ul>
<h3 id="矩阵的列空间">矩阵的列空间</h3>
<ul>
<li><p>定义列空间是A的各列各自作为向量所张成的一个空间，记作<span class="math inline">\(ColA\)</span></p></li>
<li><p>如果<span class="math inline">\(A\mathbf{x}=\mathbf{b}\)</span>相容，我们也可以称<span class="math inline">\(ColA\)</span>是有使得前式相容的所有解的集合</p></li>
<li><p>列空间是<span class="math inline">\(R^n\)</span>的子空间</p></li>
<li><p>对于一个阶梯型矩阵，他的主元列构成列空间的基</p></li>
<li><p>对于一个普遍的矩阵，他的主元列构成了列空间的基</p>
<blockquote>
<p>注意是矩阵本身的主元列，而不是行化简后的主元列</p>
</blockquote></li>
</ul>
<h3 id="矩阵的零空间">矩阵的零空间</h3>
<ul>
<li>定义零空间是方程<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>相容的所有解的线性组合张成的空间，记作<span class="math inline">\(NulA\)</span></li>
<li>零空间是<span class="math inline">\(R^n\)</span>的子空间</li>
<li>要获得零空间的基，首先要将方程的解写作参数向量形式，这几个参数向量就是零空间的基</li>
</ul>
<h2 id="矩阵的维数与秩">矩阵的维数与秩</h2>
<ul>
<li><p>定义子空间的一组基为<span class="math inline">\(\mathbf{x}\)</span>相对坐标系<span class="math inline">\(\Beta\)</span>的坐标向量</p></li>
<li><p>若非零子空间H的一组基包含p个向量，则他的每个基都包含p个向量</p></li>
<li><p>非零子空间H的维数(<span class="math inline">\(dimH\)</span>)是H的任意一个基的向量个数</p></li>
<li><p>对于零空间，<span class="math inline">\(dimNulA\)</span>就是<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的自由变量/非主元列的个数</p></li>
<li><p>对于列空间，A的秩<span class="math inline">\(rankA=dimColA\)</span>就是A的主元列的个数</p>
<blockquote>
<p>因为A的主元列形成<span class="math inline">\(ColA\)</span>的一组基</p>
</blockquote></li>
<li><p>秩定理：<span class="math inline">\(rankA+dimNulA=n\)</span></p></li>
</ul>
<h1 id="行列式">行列式</h1>
<h2 id="行列式的定义和性质">行列式的定义和性质</h2>
<p>对于行列式的概念，首先应该注意的是“行列式”这个翻译存在不妥的地方</p>
<blockquote>
<p>参考资料 为何线性代数的「determinant」被翻译成「行列式」？ - 张姜棍的回答 - 知乎 https://www.zhihu.com/question/54849904/answer/206017827 行列式为什么称作“行列式”？ - 天下无难课的回答 - 知乎 https://www.zhihu.com/question/332671271/answer/749090410</p>
</blockquote>
<ul>
<li>行列式的英文determinant，本质就是矩阵所描绘的线性变换前后，任何一个“体积”缩放的比例</li>
<li>中文只是从其形式的角度定义了名字</li>
<li>行列式不为0时，描述这个体积的缩放比例；若为0，则发生了降维</li>
<li>行列式更具有“特征值”的意味，描述了这个矩阵，或者说线性变换的唯一特征；特征值则只是在某个方向上，经过变换的向量与原向量共线，更具有“特征比例”的意味，相应的特征向量更像是这个会共线的“特征方向”</li>
</ul>
<p>行列式的一些性质</p>
<ul>
<li>一般来说，任意一个<span class="math inline">\(n\times{n}\)</span>矩阵的行列式都可以由一个<span class="math inline">\((n-1)\times{n-1}\)</span>矩阵的行列式来定义</li>
<li>定义余因子<span class="math inline">\(C_{ij} = {(-1)^{i+j} }{det{A_ij} }\)</span>，矩阵行列式可以有由任意行、列展开求得</li>
<li>特别的，如果矩阵是三角阵，其行列式就是对角线上元素的乘积</li>
<li>对于矩阵和可逆矩阵之间的关系，<span class="math inline">\(det{A}=det{A^T}\)</span></li>
</ul>
<h3 id="基本性质">基本性质</h3>
<ul>
<li><p>对矩阵的三个基本行变换，只有互换会使行列式取反号</p></li>
<li><p>对于经历了<span class="math inline">\(r\)</span>次行交换的矩阵<span class="math inline">\(A\)</span>，<span class="math inline">\(detA={(-1)^r}det{U}\)</span></p></li>
<li><p>方阵<span class="math inline">\(A\)</span>可逆，当且仅当<span class="math inline">\(det{A}\neq{0}\)</span></p>
<blockquote>
<p>推论1.若<span class="math inline">\(A\)</span>的列线性相关，则<span class="math inline">\(det{A}=0\)</span></p>
<p>推论2.若<span class="math inline">\(A\)</span>的行线性相关，则<span class="math inline">\(det{A}=0\)</span>。因为<span class="math inline">\(A\)</span>的列就是<span class="math inline">\(A^T\)</span>的行，由推论1和可逆矩阵定理可得</p>
</blockquote></li>
<li><p>对<span class="math inline">\(n\times{n}\)</span>矩阵<span class="math inline">\(E、A\)</span>,有<span class="math inline">\(det{EA}=det{E}det{A}\)</span>，其中<span class="math inline">\(det{E}=1,-1,r\)</span>，分别对应<span class="math inline">\(E\)</span>是倍加、交换和r倍乘</p></li>
</ul>
<h2 id="克拉默法则">克拉默法则</h2>
<ul>
<li>对<span class="math inline">\(n\times{n}\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(R^n\)</span>中的向量<span class="math inline">\(\mathbf{b}\)</span>，用<span class="math inline">\(\mathbf{b}\)</span>替矩阵<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列，记为<span class="math inline">\(A_i{(\mathbf{b})}\)</span></li>
<li>克拉默法则：方程<span class="math inline">\(A\mathbf{x}=\mathbf{b}\)</span>的唯一解可由<span class="math inline">\({x_i}={ {det{A_i{(\mathbf{b})} }\over{detA} } }\)</span>给出</li>
</ul>
<h3 id="逆矩阵公式">逆矩阵公式</h3>
<ul>
<li>逆矩阵公式：<span class="math inline">\({A^{-1} }={1\over{detA} }{adjA}\)</span>，其中<span class="math inline">\(adjA\)</span>是<span class="math inline">\(A\)</span>的伴随矩阵，即余因子矩阵的转置</li>
</ul>
<h2 id="体积和线性变换">体积和线性变换</h2>
<h1 id="向量空间">向量空间</h1>
<blockquote>
<p>抽象意义上的向量空间，也就是不特意指明<span class="math inline">\(R^n\)</span>的空间，其实就是一个所谓的代数系统（似乎是群），满足交换律、结合律等等，它可以作为线性变换的描述</p>
<p>零空间和列空间则是矩阵产生的两个重要的向量空间，维和秩是与其相关的描述</p>
<p>基和坐标系的内容则是对向量在不同空间内的另一种描述和相对定义方式</p>
</blockquote>
<h2 id="向量空间和子空间">向量空间和子空间</h2>
<ul>
<li>向量空间定理，略</li>
<li>由向量空间定理，不难发现零向量是唯一的，顺便定义一下负向量</li>
</ul>
<h3 id="典型的向量空间">典型的向量空间</h3>
<ul>
<li><span class="math inline">\(R^n\)</span>空间</li>
<li>(离散时间)信号空间：</li>
<li><span class="math inline">\(P^n\)</span>空间：用于统计数据的趋势分析</li>
</ul>
<h3 id="子空间-1">子空间</h3>
<ul>
<li>由于一般来说，向量空间往往是某个更大的向量空间的几个向量的子集所构成的，此时我们就只需要验证三个公理即可证明该空间为向量空间
<ul>
<li>包含零向量</li>
<li>对向量加法封闭</li>
<li>对标量乘法封闭</li>
</ul></li>
<li>定义只包含零向量的子空间为<strong>零子空间</strong>，记作<span class="math inline">\({\mathbf{0} }\)</span></li>
<li>需要区分<span class="math inline">\(R^2\)</span>不是<span class="math inline">\(R^3\)</span>的子空间，二者根本不是一回事儿，不能瞎掰扯；尽管我们可以把<span class="math inline">\(R^2\)</span>的几何意义理解为一个平面，但他在<span class="math inline">\(R^3\)</span>空间内没有完全约束，所以并不是<span class="math inline">\(R^3\)</span>的子空间</li>
<li>由上面的定理，在判断子空间时，优先判断是否包含零向量；若不包含，那就玩几把蛋了</li>
<li>与前面的知识结合，在此严格定义若几个向量在向量空间<span class="math inline">\(V\)</span>中，那么是<span class="math inline">\(V\)</span>的一个子空间，称其为<span class="math inline">\({\mathbf{v_1} },{\mathbf{v_2} },{...},{\mathbf{v_n} }\)</span>张成的子空间，称其为<span class="math inline">\(V\)</span>的张成集</li>
</ul>
<h2 id="零空间列空间和线性变换">零空间、列空间和线性变换</h2>
<h3 id="零空间">零空间</h3>
<ul>
<li>零空间的基本定义仍然是满足<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的解集</li>
<li>使用集合符号表示为<span class="math inline">\(\{ {\mathbf{x}:\mathbf{x}\in{R^n} },A\mathbf{x}=\mathbf{0}\}\)</span></li>
<li>进一步来讲，这是指经过线性变换<span class="math inline">\(A\)</span>映射到<span class="math inline">\(R^m\)</span>上零向量的所有原像的集合</li>
<li>对于一个<span class="math inline">\(m\times{n}\)</span>矩阵，或m个方程、n个未知数的齐次线性方程，他们的零空间是<span class="math inline">\(R^n\)</span>的一个子空间</li>
</ul>
<h3 id="列空间">列空间</h3>
<ul>
<li>列空间就是<span class="math inline">\(A\)</span>的所有列的线性组合组成的集合</li>
</ul>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2x3yi79t3j21ka0nuq98.jpg" alt="列空间与零空间的比较" /><figcaption aria-hidden="true">列空间与零空间的比较</figcaption>
</figure>
<h3 id="线性变换-2">线性变换</h3>
<p>从线性变换的角度来讲，我们可以对零空间和列空间换一个说法</p>
<ul>
<li>零空间是满足<span class="math inline">\(T(\mathbf{u})=\mathbf{0}\)</span>的所有向量的集合，通常，在这个角度下称呼零空间为核</li>
<li>该线性变换的值域就是列空间</li>
</ul>
<h2 id="线性无关集构成的基">线性无关集构成的基</h2>
<p>对于一组单位矩阵的列，他们可以张成一个空间，这样一个集合被称为标准基</p>
<h3 id="生成集">生成集</h3>
<p>生成集是一个比基更大的概念，它是指可以生成一个空间的若干向量的集合。</p>
<p>生成集不要求向量之间的线性无关，只要能够长成一个空间即可。</p>
<p>因此，空间的基是尽可能小的生成集，同时也是尽可能大的线性无关集。</p>
<h3 id="零空间的基">零空间的基</h3>
<ul>
<li>零空间是被隐式表示的，我们需要对其进行显化的处理才能得到基</li>
<li>简单而言，就是求出<span class="math inline">\(A\mathbf{x}=\mathbf{0}\)</span>的解得向量表示，最后的向量因数就是零空间的张成集</li>
</ul>
<h3 id="列空间的基">列空间的基</h3>
<ul>
<li>矩阵的<strong>主元列</strong>构成列空间的一个集</li>
<li>因此，行变换可以改变矩阵的列空间，所以一定要慎重选择<span class="math inline">\(ColA\)</span>的基 &gt; 行化简利用了初等行变换不会改变列的线性关系的性质，所以这里只是利用简化阶梯型寻找主元列（主元列的定义，只是指出了包含主元的那一列，而不是列的这些个元素），最后选取原矩阵主元列的值即可作为基。</li>
</ul>
<h2 id="坐标系">坐标系</h2>
<ul>
<li>唯一表示定理</li>
</ul>
<h2 id="向量空间的维和秩">向量空间的维和秩</h2>
<h2 id="基的变换">基的变换</h2>
<h1 id="特征值与特征向量">特征值与特征向量</h1>
<h2 id="特征值与特征向量-1">特征值与特征向量</h2>
<p>有时，<span class="math inline">\(A\mathbf{x} = \lambda \mathbf{x}\)</span>是成立的，这时<span class="math inline">\(\lambda\)</span>被称为<span class="math inline">\(A\)</span>的特征值，每个特征值对应的<span class="math inline">\(\mathbf{x}\)</span>被称为他的特征向量</p>
<ul>
<li>对于一个特征值，可能存在若干个与之对应的特征向量。我们称零向量和这些特征向量的集合为该特征值对应的特征空间</li>
</ul>
<h2 id="特征方程">特征方程</h2>
<p>利用矩阵方程<span class="math inline">\((A-\lambda I)\mathbf{x}=\mathbf{0}\)</span>可以得到特征值，进一步解线性方程组可以得到特征向量</p>
<ul>
<li>解特征方程会涉及到行列式，挖坑</li>
</ul>
<p>特征方程就是指<span class="math inline">\(det({A-\lambda{I} }) = 0\)</span>这个数值方程的根</p>
<ul>
<li>由数值方程的定义，其左侧是一个多项式，被称为特征多项式</li>
<li>特征多项式中某些特征值多次出现，我们称它出现的次数为重数</li>
</ul>
<h3 id="一个关于多项式根的基本定理">一个关于多项式根的基本定理</h3>
<blockquote>
<p>这个定理似乎是来自代数基本定理，具体称呼和证明都不晓得。</p>
</blockquote>
<p><span class="math display">\[
\begin{array}{l}
对于给定一个有理式\\
f(x)={ {a_n}x^n}+{ {a_{n-1} }x^{n-1} }+{\cdots}+{a_0}\\
集合B为{a_n}的所有因子，集合C为{a_0}的所有因子\\
构造集合C=\{ { {r}\over{s} }|{s{\in}C},{r{\in}B}\}\\
如果C不为空，则方程的根一定全部是C的元素；否则方程无解。
\end{array}
\]</span></p>
<h2 id="相似性与对角化">相似性与对角化</h2>
<h3 id="相似性">相似性</h3>
<p>如果两个矩阵，满足<span class="math inline">\(A=PBP^{-1}\)</span>，也有<span class="math inline">\(B=PAP^{-1}\)</span>，则称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>是相似的。他们有相同的特征多项式和特征值。</p>
<h3 id="对角化">对角化</h3>
<p>首先要知道，计算对角矩阵的高次幂很简单</p>
<p>如果矩阵<span class="math inline">\(A=PDP^{-1}\)</span>，也就是像上面提到的，<span class="math inline">\(A\)</span>与<span class="math inline">\(D\)</span>相似，其中<span class="math inline">\(D\)</span>是一个对角矩阵，则称<span class="math inline">\(A\)</span>可对角化</p>
<p>对角化有一系列定理和判定方式</p>
<p>要求出一个矩阵的对角化，有四个步骤</p>
<ol type="1">
<li>特征值</li>
<li>特征向量，这些特征向量也被称为特征向量基</li>
<li>使用特征向量构造矩阵<span class="math inline">\(P\)</span></li>
<li>与矩阵<span class="math inline">\(P\)</span>保证向量一一对应的前提下，构造矩阵<span class="math inline">\(D\)</span></li>
<li>（验证）由证明，这里可以判断是否满足<span class="math inline">\(AP=PD\)</span>（也就是原式右乘<span class="math inline">\(P^{-1}\)</span>）是否成立</li>
</ol>
<h1 id="正交性和最小二乘法">正交性和最小二乘法</h1>
<h1 id="二次型">二次型</h1>
<h1 id="一些问题的处理方式">一些问题的处理方式</h1>
<h2 id="求解线性方程组">求解线性方程组</h2>
<p>构造增广矩阵进行行化简即可。</p>
<h2 id="克拉默法则-1">克拉默法则</h2>
<p>可以直接求出线性方程组的解。</p>
<p><span class="math display">\[
{x_i}={ {|{A_i({\mathbf{b} })}|}\over{|A|} },{i=1,2,{\cdots},n}
\]</span></p>
<p>其中，<span class="math inline">\({A_i({\mathbf{b} })}\)</span>的意思是用<span class="math inline">\(\mathbf{b}\)</span>替换<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列。</p>
<h2 id="lu分解-1">LU分解</h2>
<p>对矩阵<span class="math inline">\(A\)</span>进行行化简，可以得到一个简化阶梯型矩阵<span class="math inline">\(U\)</span>；<span class="math inline">\(U\)</span>可以得到<span class="math inline">\(A\)</span>的主元列，取<span class="math inline">\(A\)</span>中主元列并除以主元（即主元位置化为1）得到矩阵<span class="math inline">\(L\)</span>，有<span class="math inline">\(A=LU\)</span>。</p>
<h2 id="基的变换矩阵">基的变换矩阵</h2>
<p>以二维向量为例。<span class="math inline">\({\mathbf{b_1} },{\mathbf{b_2} }\)</span>和<span class="math inline">\({\mathbf{c_1} },{\mathbf{c_2} }\)</span>是空间<span class="math inline">\(B,C\)</span>下的基，我们需要一个矩阵<span class="math inline">\(P_{C{\leftarrow}B}\)</span>去指示二者之间的变换。</p>
<p>对某个用来表示<span class="math inline">\(B\)</span>中向量在<span class="math inline">\(C\)</span>中的坐标的向量<span class="math inline">\(\mathbf{x},\mathbf{y}\)</span>，有</p>
<p><span class="math display">\[
\begin{array}{l}
[{\mathbf{c_1} }{\quad}{\mathbf{c_2} }]{\mathbf{x} }={\mathbf{b_1} },[{\mathbf{c_1} }{\quad}{\mathbf{c_2} }]{\mathbf{y} }={\mathbf{b_2} },\\
等价于[{\mathbf{c_1} }{\quad}{\mathbf{c_2} }][{\mathbf{x} }{\quad}{\mathbf{y} }]=[{\mathbf{b_1} }{\quad}{\mathbf{b_2} }]\\
只需化简[{\mathbf{c_1} }{\quad}{\mathbf{c_2} }|{\mathbf{b_1} }{\quad}{\mathbf{b_2} }]\\
得到形为[E|P_{C{\leftarrow}B}]
\end{array}
\]</span></p>
<blockquote>
<p>有些时候，求<span class="math inline">\(P_{C{\leftarrow}B}\)</span>要比<span class="math inline">\(P_{B{\leftarrow}C}\)</span>简单；二者互为逆矩阵。</p>
</blockquote>
<h2 id="求解特征值与特征向量">求解特征值与特征向量</h2>
<p>求解一个矩阵的特征值，只需计算<span class="math inline">\(|A-{\lambda}I|=0\)</span>求得一系列<span class="math inline">\({\lambda_1},{\lambda_2},{\dotsb},{\lambda_k}\)</span>。</p>
<p>将上面求出的特征值回代到矩阵<span class="math inline">\(A-{\lambda_i}I=0\)</span>，解这个线性方程组获得的即是对应的特征向量。</p>
<h2 id="矩阵对角化">矩阵对角化</h2>
<p>矩阵对角化用于简化幂运算，对一个可以对角化的矩阵<span class="math inline">\(A\)</span>，有<span class="math inline">\(A^n=P^{-1}{ {\Lambda}^n}P\)</span>。</p>
<p>将矩阵对角化，首先需要判段能否对角化。</p>
<p>然后求矩阵的特征值和特征向量。</p>
<p>用特征值为对角元素组成一个对角矩阵<span class="math inline">\(\Lambda\)</span>，<strong>对应的</strong>特征向量组成<span class="math inline">\(P\)</span>，手算出<span class="math inline">\(P^{-1}\)</span></p>
<h2 id="构造标准正交基">构造标准正交基</h2>
<p>使用格拉姆-施密特方法构造正交基。</p>
<p>格拉姆-施密特方法可以表述为对要构造的基向量<span class="math inline">\(v_i\)</span>，它等于所给的列向量<span class="math inline">\(x_i\)</span>减去<span class="math inline">\(x_i\)</span>在之前若干个基向量上的投影。可以记为</p>
<p><span class="math display">\[
\begin{array}{l}
\mathbf{v_1}=\mathbf{x_1},i=1\\
\mathbf{v_i}={\mathbf{x_i} }-{ {\sum_{k=1}^i}{ {\mathbf{x_i} }{\cdot}{\mathbf{v_k} }\over{ {\mathbf{v_k} }{\cdot}{\mathbf{v_k} } } }{\mathbf{v_k} } },i=2,{\dotsb},n
\end{array}
\]</span></p>
<p>最后，如果需要得到单位正交基，只需对正交基单位化，即</p>
<p><span class="math display">\[
{\mathbf{u_i} }={1\over{||{\mathbf{v_i} }||} }{\mathbf{v_i} },i=1,2,{\dotsb},n
\]</span></p>
<h2 id="qr分解">QR分解</h2>
<p>通过格拉姆-施密特方法，我们可以得到正交基矩阵<span class="math inline">\(Q=[{\mathbf{u_1} }{\quad}{\mathbf{u_2} }{\quad}{\cdots}{\quad}{\mathbf{u_n} }]\)</span>。</p>
<p>因为<span class="math inline">\(Q^TQ=I\)</span>，所以<span class="math inline">\(Q^TA={Q^T}(QR)=(Q^TQ)R=R\)</span>。因此要求<span class="math inline">\(R\)</span>，有<span class="math inline">\(R=Q^TA\)</span></p>
<h2 id="二次型的变量代换">二次型的变量代换</h2>
<p>二次型的变量代换就是形如<span class="math inline">\({\mathbf{x} }=P{\mathbf{y} }\)</span>，使得二次型矩阵只含有对角线元素，二次型只有二次想的变换。</p>
<p>只需对原二次型矩阵<span class="math inline">\(A\)</span>进行正交对角化（此时每个特征值都不同且对应一个特征向量，这些向量自动正交），得到矩阵<span class="math inline">\(P\)</span>和<span class="math inline">\(\Lambda\)</span>。</p>
<p>此时有<span class="math inline">\(A=P{\Lambda}P^{-1}\)</span>，且<span class="math inline">\({\Lambda}=P{-1}AP={P^T}AP\)</span>，所以</p>
<p><span class="math display">\[
{\mathbf{x} }^TA{\mathbf{x} }=(P{\mathbf{y} })^TA(P{\mathbf{y} })={\mathbf{y} }^TP^TAP{\mathbf{y} }={\mathbf{y} }^T{\Lambda}{\mathbf{y} }
\]</span></p>
<h1 id="线性代数应用">线性代数应用</h1>
<h2 id="解线性方程组">解线性方程组</h2>
<h2 id="计算机图形学">计算机图形学</h2>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛2022</title>
    <url>/blog/posts/29384/</url>
    <content><![CDATA[<h2 id="qa">Q&amp;A</h2>
<ol type="1">
<li>美赛评奖规则，允许不对所有问题进行解答，如果最后实在做不出来，但往往<strong>最多允许一小问</strong>，提交的话也不会影响评奖的</li>
<li>对于所有参考的数据或者是文献都<strong>需要指明来源</strong></li>
<li>从2021年起，美赛官方明确说了<strong>不能超过25页（包括附录之类的）</strong>，超过的话不会直接没奖，但往往会降低评奖档次</li>
<li><strong>附录一般并不作为评奖的内容，但会占用页数</strong>，因此对于不重要的代码或结果尽量别放</li>
<li><strong>摘要页每年都会有新的发布</strong>，可以在美赛官网下载。必须要用今年的，用去年的可能会影响评奖</li>
<li>如果是<strong>命名出现错误是可以重新提交</strong>的，但如果命名正确已经提交出现问题，再重新提交的话可能导致不会接收等问题，建议只交一遍</li>
<li>在<strong>页眉添加#号或者页码</strong></li>
<li>比赛结束前是必须要选题的，<strong>选题由队长登录参赛官网后直接在上面选择</strong>即可，六选一，论文只能提交自己选择的那道题的求解结果</li>
<li>原则上说，邮箱主题只需要<strong>体现自己的控制号</strong>即可</li>
<li><strong>控制号是团队的唯一标识码</strong>，控制号写错了在截止前重新提交可以</li>
<li>美赛论文<strong>要求用12号及以上的字体</strong>写作，如果字体太小会让评委阅卷不方便</li>
<li>值得注意的是<strong>附件大小不能超越17M</strong>即可，不要采用云服务</li>
<li>美赛要求<strong>论文中绝不允许出现姓名、学校等信息</strong></li>
</ol>
<h2 id="时间轴">时间轴</h2>
<ul>
<li>1.9:组队成功</li>
</ul>
<h2 id="to-do-list">TO-DO LIst</h2>
<h3 id="如何解决时间空差">如何解决时间空差？</h3>
<ol type="1">
<li>尽量避免过于单一的个人能力</li>
</ol>
<h3 id="资料搜集">资料搜集</h3>
<ol type="1">
<li>墙外！</li>
<li>记得登记原始来源</li>
<li>要不要上爬虫呢</li>
</ol>
<h3 id="论文写作latex-or-word">论文写作(LaTex or Word？)</h3>
<ol type="1">
<li>LaTex写作效果更好，但有学习成本，据说美赛用LaTex不好（待定</li>
</ol>
<h3 id="数据备份和同步">数据备份和同步</h3>
<ol type="1">
<li>首选坚果云，编程手随手github备份</li>
<li>队长保证至少一份原始备份，每天检查资料</li>
</ol>
<h2 id="概况">概况</h2>
<h3 id="评分重点">评分重点</h3>
<ol type="1">
<li>主要陈述应提出重大思路和结果</li>
<li>酌情澄清或重述问题</li>
<li>对所有变量，<strong>假设和假设进行清晰的阐述</strong></li>
<li>对问题进行分析，<strong>包括所使用模型的动机或理由</strong></li>
<li>模型的设计</li>
<li>讨论<strong>如何测试模型</strong>，包括误差分析和稳定性（调理，敏感性等）</li>
<li>讨论您的模型或方法中的<strong>任何明显的优点或缺点</strong></li>
</ol>
<h3 id="比赛要求">比赛要求</h3>
<ul>
<li><p>人数：<strong>三人（本科生）为一组</strong>，人数要是3，所以配置要合理，大家尽可能有默契，目标专一，作息一致，分工合理。搭档选得好，O奖没得跑</p></li>
<li><p>时间：在<strong>四天</strong>时间内，四天，一般都是早晨到早晨，要安排好比赛的时间</p></li>
<li><p>任务：就指定的问题完成从建立模型、求解、验证到论文撰写的全部工作，选择好问题——开始建模——验证——撰写论文</p></li>
<li><p><img src="https://pic3.zhimg.com/v2-94526e24dd338cef3dec8ce424ed9d92_r.jpg" alt="preview" />ABC一般会对于建模的要求更高一些些，DEF也需要建模，但是在专业学科知识上的运用可能更加灵活</p></li>
<li><p>奖项设置</p>
<figure>
<img src="https://pic4.zhimg.com/v2-a51c47ba3f67df9d40f94816dbf6585f_b.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>官网：https://www.comap.com/undergraduate/contests/index.html</p></li>
</ul>
<h2 id="经验">经验</h2>
<h3 id="经验a西电准大二f奖">经验A（西电准大二F奖）</h3>
<h4 id="赛前">赛前</h4>
<ul>
<li><p>看之前的O奖<strong>论文</strong></p></li>
<li><p>快速积累数学模型</p>
<blockquote>
<p>现在Stream大佬吸取了我提的意见，在SPSSPRO（完全免费）把算法做成了三段式解释（算法简短说明+输入+输出+案例），以及还搭配了配套演示视频（平均每个时长2，3分钟），大家学习建模时可以照着这个来学习，一两天就可以掌握上百个模型，无论是未来工作、科研，还是接着打数模，都是非常有用的。</p>
</blockquote></li>
</ul>
<h4 id="赛中">赛中</h4>
<ul>
<li>给了数据的D题，一道音乐分析的题目</li>
</ul>
<h3 id="经验b知乎浩然适合论文手参考">经验B（知乎浩然，适合论文手参考）</h3>
<h4 id="赛前-1">赛前</h4>
<ul>
<li>好的论文是从模仿开始的</li>
<li>自主学习了一些模型算法</li>
</ul>
<h4 id="赛中-1">赛中</h4>
<ul>
<li>首先进行选题的讨论，其实这部分的时间很短</li>
<li>找数据的过程其实是美赛的重点之一，能不能找到合适的足够的数据，是模型建立是否成果的重要部分</li>
<li>将找到数据的网站list列出来，这样说明你的数据是真实有效的</li>
<li>非常推荐查找硕博论文，因为硕博论文由浅入深介绍这个问题的来历，会从一般模型说起，这样便于你对模型进行改进</li>
<li>B题要解决的问题一定需要可视化来展示，那么就少不了如何可视化，这时我就建议A去学习一下可视化的方法，最初是matlab，后来发现效果并不理想，最后换了他最熟悉的Python，有包可以调用</li>
<li>第二天基本上8：40开始，没必要熬夜，第一天基本上12：00睡觉就可以</li>
<li>多阅读O奖论文就发现，题目都有闪光点，我们要取长补短，例如算法流程图就是重要的图，我们希望将其画出来</li>
<li>编程手一定要与论文手多沟通，否则优秀的算法思想没有办法被写出来</li>
<li>最后一天晚上当然熬夜写摘要，摘要主要是B写的，然后我在写优缺点分析、灵敏度分析的事情</li>
<li>摘要的文字一定要符合习惯，不能有错误，我在写论文的时候也非常注意，英文表达习惯被动句，而很多人先写中文后写英文的喜欢翻译成主动句，这是一个巨大的差别</li>
</ul>
<h4 id="赛后">赛后</h4>
<ul>
<li>国赛重结果，论文其次，美赛重创新和论文，结果其次，这是这个比赛固有的事实</li>
</ul>
<h3 id="经验c">经验C</h3>
<h4 id="赛前-2">赛前</h4>
<ul>
<li><p>学习内容：</p>
<ul>
<li>ALL：数学建模常用模型和算法的知识、查找文献、修改论文的能力</li>
<li>论文手：学会使用Latex或者word排版、学会使用VISIO、亿图、Excel、PPT等基本绘图和图表可视化，学会如何表述数学建模过程、阐述问题，了解美赛论文基本结构框架（充分准备，可以速成）</li>
<li>编程手：学会使用mathlab、python、C、SPSS、R、Origin等基本编程和数据处理软件，学会数据处理和算法实现</li>
<li>建模手：30种常用算法和模型原理的熟悉，对模型的实际运用能力，问题分析能力</li>
</ul></li>
<li><p>读论文每个人看论文都必须要有针对性，否则看了几乎等于没有看，因为没有任何印象</p></li>
<li><p>适用写作和建模</p>
<ul>
<li>拿到一篇O奖论文，不看摘要 不看摘要 不看摘要，把所有的内容和题目看一次，理清文章思路</li>
<li>试着把你看到的和理解的，总结下来，自己写出这篇文章的摘要，反复修改直到满意为止，一定要写，然后反复修改</li>
<li>你写的摘要和原文摘要进行对比，找出差距和不足，或者明显不一样的地方，看完以后，再修改你原来写的，逐渐模仿到和原文差距不大，甚至超越原文的地步</li>
</ul>
<blockquote>
<p>每年美赛评委会仅仅通过看摘要会筛选出<strong>50%左右</strong>的论文</p>
</blockquote></li>
</ul>
<p>赛中</p>
<ul>
<li><p>Day1</p>
<ul>
<li><p>早上6点左右，官网放出了题目，我把题目下载了以后进行翻译复制到word里面，发到群里，然后我们都开始选题的工作</p></li>
<li><p>数模乐园官方也给出了中文版的翻译，我们对比着两个翻译版本进行分析</p></li>
<li><p>第一周里面只有ADE三类题目，所以我们的选择范围相对有限。我们果断放弃了A，开始纠结D和E。开始我和W学长都比较赞同D题，看上去题目意思比较直观，而且D有数据包，很多数据不需要查找，但最后Z学长说D题不容易实现，然后我们再看了一下题目发现也好像是那么回事。最后我们决定选了E题，关于<a href="https://www.zhihu.com/search?q=环境保护&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22107590650%22%7D">环境保护</a>类的。E题容易在模型比较简单，而且主观性很强可以发挥的空间很大；难点在于没有数据 没有数据 没有数据</p></li>
<li><blockquote>
<p>解题模型和数据的冲突</p>
</blockquote></li>
</ul></li>
<li><p>Day2</p>
<ul>
<li><p>W学长开始尝试建立第一问的模型，我着手开始写论文的introduction和restatement of problem 这些不需要解题就能写的部分,整理了论文的框架；然后我继续帮忙找数据，期间我们W学长一直在和我们讨论题目，建立模型，Z学长一直在处理已有的部分数据，进行可视化分析</p>
<blockquote>
<p>组员的时间分配</p>
</blockquote></li>
</ul></li>
<li><p>Day3</p>
<ul>
<li><p>把每个题目都分成不同的文档,包括整体的思路和解题过程,这样看上去整体性比较强,可以尽量减少建模和写作之间的gap.然后明天就是需要把这些翻译出来，放在整体的论文里面，还有一些图标格式绘制的问题</p>
<blockquote>
<p>题目之间的联系</p>
</blockquote></li>
</ul></li>
<li><p>Day4</p>
<ul>
<li>一整天都在进行庞大的整理、翻译、格式调整、排版的工作</li>
<li>手写摘要，把摘要单独放在了一个文档里面</li>
</ul></li>
</ul>
<h4 id="经验d张浩驰">经验D（张浩驰）</h4>
<h4 id="赛前-3">赛前</h4>
<ul>
<li><p>在求解过程中存在一些灵感，倒是建议<strong>大胆</strong>使用</p></li>
<li><p>推荐一本官方写作书籍《正确写作美国大学生数学建模竞赛》</p></li>
<li><p>公式编辑器推荐AxMath</p>
<blockquote>
<p>Windows 下有什么用过之后就离不开的冷门软件？ - 张浩驰的回答 - 知乎 https://www.zhihu.com/question/21175572/answer/588082133</p>
</blockquote></li>
<li><p>可视化工具</p>
<ul>
<li><p>Matlab</p></li>
<li><p>Python-Matplotlib &amp; Python-Seaborn</p>
<blockquote>
<p>Seaborn是用户把自己常用到的可视化绘图过程进行了函数封装，形成的一个“快捷方式”，他相比Matplotlib的好处是代码更简洁，可以用一行代码实现一个清晰好看的可视化输出</p>
</blockquote></li>
<li><p>R-ggplot2：R语言主要就是面向数据科学的语言</p></li>
</ul></li>
<li><p>绘图工具</p>
<ul>
<li><p>VISIO</p></li>
<li><p>AxGlyph</p></li>
<li><p>Geogebra</p></li>
<li><p>Gephi</p>
<blockquote>
<p>建议的配色是加一点灰度，大红大绿的配色容易让评审产生审美疲劳，所以，我最常用的图表配色类似于右图（注：本文为下图），每种颜色都带一点灰度，使得图表更有学术范。</p>
<p>图示的字体（包括坐标轴）不能太小，需要与正文字体相当或者小一号，MATLAB绘制的图可以放在Visio中进行再加工，添加图示和文字。</p>
</blockquote></li>
</ul></li>
<li><p>排版</p>
<ul>
<li><p>图文穿插</p></li>
<li><p>表格直接固定图片格式</p>
<p>如果直接插入图片，很有可能会导致乱格式，一般我喜欢利用表格进行格式控制。最后将表格边框调整成“无边框”即可。（注：这点真的是非常好，自己调节图片大小往往不能做到嵌入进表格这样简单、便捷、优美）</p></li>
<li><p>三线表</p>
<p>如果有多行可以考虑添加背景阴影使得行与行之间区分开来。</p></li>
<li><p>段落</p>
<p>取消“定义文档网格时对齐网格”（注：在Word中被称之为如果定义了文档网格，则对齐到网格），这可以避免在输入公式后行间距不一致。（这与我那种方法不一样的另外一种解决行间公式嵌入导致公式前后行间距不一致的情况）</p></li>
<li><p>框架式绘图</p></li>
</ul></li>
<li><p>数据</p>
<ul>
<li>https://blog.csdn.net/weixin_43102634/article/details/103696632</li>
<li>https://max.book118.com/html/2019/0204/6232125043002005.shtm</li>
<li>世界卫生组织 https://www.who.int/data/gho</li>
<li>美国农业部 https://www.usda.gov/topics/data</li>
<li>直接访问美国政府总网站，搜索关键字+data或者部门官网</li>
<li>实在没有数据
<ul>
<li>如果这道题并没有限定国家，或者说对于文化背景要求不高，那么我们就考虑把伟大的祖国作为研究对象</li>
<li>我们应该利用数据挖掘的能力，也就是说，我们需要自己利用一定的技术手段去收集数据，比如爬虫技术，自己去爬一些可能用得到的内容</li>
</ul></li>
<li>天池大数据（以下是数据科学竞赛平台） https://tianchi.aliyun.com/dataset/?spm=5176.12281905.0.0.358b5699IjonJQ</li>
<li>Datasets https://www.kaggle.com/datasets?tags=15006-socrata</li>
<li>UCI机器学习库 https://archive.ics.uci.edu/ml/index.php</li>
</ul></li>
<li><p>解题流程</p>
<figure>
<img src="https://pica.zhimg.com/80/v2-b1d29028a05e718b5832f7f9774ec9ae_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数学建模</tag>
        <tag>小习题儿</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛论文赏析</title>
    <url>/blog/posts/10530/</url>
    <content><![CDATA[<h1 id="e">2021.E</h1>
<h2 id="section">2113869</h2>
<h3 id="模型建立">模型建立</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gzejx2tku9j30hi09t0ti.jpg" alt="image-20220215221118750" /><figcaption aria-hidden="true">image-20220215221118750</figcaption>
</figure>
<ul>
<li><p>从三个维度建立模型</p>
<ul>
<li><p>第一是生产，建立一个由畜牧业、种植业和渔业三个子系统组成的生产模型</p></li>
<li><p>第二是公平，基于分配建立的公平分配模型</p></li>
<li><p>第三是发展，引入时间因子建立增长模型</p></li>
</ul></li>
<li><p>生产模型使用BP网络预测，或许是因为团队引入了八个因子作为预测变量，此时使用多元线性回归的表现未必尽如人意</p></li>
<li><p>公平分配模型是一个离散模型，他将富有国家的财产分享给贫穷国家，其分享标准是国家之间的距离</p>
<blockquote>
<p>这种处理，感觉，不是很好</p>
</blockquote></li>
</ul>
<h3 id="涉及工具和算法">涉及工具和算法</h3>
<h4 id="生产模型">生产模型</h4>
<ul>
<li><p>使用BP神经网络中的M-P神经模型进行预测。</p>
<p>这是一个三层的BP神经网络，其输入层由八个神经元组成</p>
<blockquote>
<p>BP（Back-propagation，反向传播）神经网络是最传统的神经网络。也就是使用了Back-propagation算法的神经网络。请注意他不是时下流行的那一套深度学习。要训练深度学习level的网络你是不可以使用这种算法的。原因我们后面解释。而其实机器学习的bottleneck就是成功的突破了非常深的神经网络无法用BP算法来训练的问题。</p>
<p>大家记住，反复的念这句话：反向传播，反向传播，反向传播。那么反向传播的东西是什么呢？答案是：误差。就是在模拟过程中（这是一个循环，我们在训练神经网络的时候是要不断的去重复这个过程的）收集系统所产生的<strong>误差，</strong>并且返回这些误差到输出值，之后用这些误差来调整神经元的权重，这样生成一个可以模拟出原始问题的人工神经网络系统。</p>
<p>https://zhuanlan.zhihu.com/p/40623863</p>
</blockquote></li>
<li><p>Dijkstra算法求最小距离</p>
<blockquote>
<p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 <span class="math inline">\(O(n^{2})\)</span></p>
</blockquote></li>
<li><p>使用灰色预测实现单一因子的预测</p></li>
</ul>
<h3 id="可视化处理">可视化处理</h3>
<ul>
<li>对神经网络的拟合进行了可视化展示</li>
<li>展示了选定国家和地区的分布，为下一步最小距离的求解提供直观感受</li>
</ul>
<h3 id="模型优化">模型优化</h3>
<ul>
<li>使用实际表现相差很大的两个国家比较，说明模型的覆盖能力</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>整体观感一般，对于神经网络的处理是亮点，但行文有些散乱，有灌水的嫌疑</li>
<li>与2102057的模型相比，对生产模型的建立的确是亮点，直接建立产量收益与环境的关系</li>
<li>在这问题前，大多会考虑到公平和环境，离不开利益和成本</li>
</ul>
<h2 id="section-1">2102057</h2>
<h3 id="模型建立-1">模型建立</h3>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220215230401907.png" alt="image-20220215230401907" /><figcaption aria-hidden="true">image-20220215230401907</figcaption>
</figure>
<ul>
<li><p>模型由是三个部分组成，分别是环境可持续发展、经济和公平分配</p></li>
<li><p>环境方面的指标选择比较典型，分别是温室气体、污染物和土地占用</p></li>
<li><p>引入了税款进行转移支付</p>
<blockquote>
<p>这可比对口帮扶好多了</p>
</blockquote></li>
</ul>
<h3 id="涉及工具和算法-1">涉及工具和算法</h3>
<ul>
<li>Logistic预测来获得指标增长到指定值的变化曲线</li>
</ul>
<h3 id="可视化处理-1">可视化处理</h3>
<h3 id="模型优化-1">模型优化</h3>
<h3 id="其他-1">其他</h3>
<ul>
<li>与2113869相比，产量的需求来源于人，通过人引入生产因子，得到的是“人 -&gt; 粮食需求 -&gt; 过剩和不足 -&gt; 总体利润”的分析链条</li>
</ul>
<h2 id="section-2">2119031</h2>
<h3 id="模型建立-2">模型建立</h3>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216140319744.png" alt="image-20220216140319744" /><figcaption aria-hidden="true">image-20220216140319744</figcaption>
</figure>
<ul>
<li>建立一个食品系统模型，包含生产、运输和销售三个子系统</li>
<li>对于食品的生产，同样分为了种植业、畜牧业和渔业</li>
</ul>
<h3 id="涉及工具和算法-2">涉及工具和算法</h3>
<ul>
<li><p>使用了一个奇怪的距离优化算法</p></li>
<li><p>供求微分方程</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216141618678.png" alt="image-20220216141618678" /><figcaption aria-hidden="true">image-20220216141618678</figcaption>
</figure>
<blockquote>
<p>这个模型的处理不是很好，他认为这个导数是线性的，笔者认为这里可以使用一个非线性函数</p>
</blockquote></li>
<li><p>多目标优化</p></li>
</ul>
<h3 id="可视化处理-2">可视化处理</h3>
<ul>
<li><p>bacground部分引入一张图片</p></li>
<li><p>使用雷达图展示优化结果</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216143825041.png" alt="image-20220216143825041" /><figcaption aria-hidden="true">image-20220216143825041</figcaption>
</figure></li>
</ul>
<h3 id="模型优化-2">模型优化</h3>
<h3 id="其他-2">其他</h3>
<ul>
<li>这篇论文最后的一个分类图，联想到可以使用聚类将国家进行分层，以实现更好的分类效果</li>
</ul>
<h2 id="section-3">2119893</h2>
<h3 id="模型建立-3">模型建立</h3>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216144556398.png" alt="image-20220216144556398" /><figcaption aria-hidden="true">image-20220216144556398</figcaption>
</figure>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216151241760.png" alt="image-20220216151241760" /><figcaption aria-hidden="true">image-20220216151241760</figcaption>
</figure>
<ul>
<li>Basic Food System由几个因子决定，在此基础上，引入公平和可持续发展进行优化</li>
<li>引入营养指数描述食物需求</li>
</ul>
<h3 id="设计工具和算法">设计工具和算法</h3>
<ul>
<li><p>组合加权法</p></li>
<li><p>使用分层多元线性回归获得基本食品系统</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216144839631.png" alt="image-20220216144839631" /><figcaption aria-hidden="true">image-20220216144839631</figcaption>
</figure></li>
<li><p>数据归一化处理</p>
<ul>
<li><p>成员函数，用于运输能力等模糊参数</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216150539925.png" alt="image-20220216150539925" /><figcaption aria-hidden="true">image-20220216150539925</figcaption>
</figure></li>
<li><p>Sigmoid函数，用于人口正常化等没有明确边界的情况</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216150636068.png" alt="image-20220216150636068" /><figcaption aria-hidden="true">image-20220216150636068</figcaption>
</figure></li>
<li><p>Z-score归一，用于消费水平等类似正态分布的情况</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216150847497.png" alt="image-20220216150847497" /><figcaption aria-hidden="true">image-20220216150847497</figcaption>
</figure></li>
</ul></li>
<li><p>权重的判断使用熵权法</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216151057752.png" alt="image-20220216151057752" /><figcaption aria-hidden="true">image-20220216151057752</figcaption>
</figure></li>
<li><p>进一步引入主观权重法完善熵权法</p>
<figure>
<img src="/Users/guosurui/Library/Application%20Support/typora-user-images/image-20220216151107681.png" alt="image-20220216151107681" /><figcaption aria-hidden="true">image-20220216151107681</figcaption>
</figure></li>
</ul>
<h3 id="可视化处理-3">可视化处理</h3>
<h3 id="模型优化-3">模型优化</h3>
<h3 id="其他-3">其他</h3>
<h1 id="f">2021.F</h1>
<h2 id="section-4">2102185</h2>
<h3 id="模型建立-4">模型建立</h3>
<figure>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gzgcnxj651j20mq0brgm7.jpg" alt="image-20220217113129377" /><figcaption aria-hidden="true">image-20220217113129377</figcaption>
</figure>
<h3 id="设计工具和算法-1">设计工具和算法</h3>
<ul>
<li>使用TOPSIS</li>
</ul>
<h3 id="可视化处理-4">可视化处理</h3>
<ul>
<li>使用三线格描述各个因子</li>
</ul>
<h3 id="模型优化-4">模型优化</h3>
<h3 id="其他-4">其他</h3>
<h2 id="section-5">2103649</h2>
<h3 id="模型建立-5">模型建立</h3>
<h3 id="涉及工具和算法-3">涉及工具和算法</h3>
<h3 id="可视化处理-5">可视化处理</h3>
<h3 id="其他-5">其他</h3>
<h2 id="模板">模板</h2>
<h3 id="模型建立-6">模型建立</h3>
<h3 id="涉及工具和算法-4">涉及工具和算法</h3>
<ul>
<li><p>层次分析法</p></li>
<li><p>提出总分增益概念</p></li>
<li><p>数据包括分析法（DEA）</p>
<blockquote>
<p>数据包络分析是评价多输入指标和多输出指标的较为有效的方法，将投入与产出进行比较</p>
<p>在数学建模中，其实这好像是一种特殊的评估，类似“亏，盈”的场景。而且在这种衡量的时候，所投入的“本”“利润”都可以是多项的，而且在这些评价的因素中他们具有量纲化。但是在进行评估的时候，本模型的好处是避开了这种缺陷。 它能够用来比较提供相似服务的多个服务单位之间的效率，这项技术被称为数据包络线分析（DEA）。它避开了计算每项服务的标准成本，因为它可以把多种投入和多种产出转化为效率比率的分子和分母，而不需要转换成相同的货币单位。因此，用DEA衡量效率可以清晰地说明投入和产出的组合，从而，它比一套经营比率或利润指标更具有综合性并且更值得信赖。</p>
</blockquote></li>
<li><p>K-S检验</p></li>
</ul>
<h3 id="可视化处理-6">可视化处理</h3>
<h3 id="其他-6">其他</h3>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式</title>
    <url>/blog/posts/46546/</url>
    <content><![CDATA[<h2 id="基本知识">基本知识</h2>
<h3 id="行列式的概念和意义">行列式的概念和意义</h3>
<p>行列式的绝对值，反映了矩阵对原向量的改变程度，在集合上反映为面积、体积的变化比例；正负反映了手性的改变。</p>
<p>一个<span class="math inline">\(n\times{n}\)</span>行列式展开大概需要<span class="math inline">\(2n^3/3\)</span>次运算，通过算法优化充分利用0可以进一步加速。</p>
<h3 id="行列式的性质">行列式的性质</h3>
<p>若<span class="math inline">\(|A|\neq{0}\)</span>，那么<span class="math inline">\(|A| = |A^T|\)</span>成立。</p>
<div class="note note-success">
            <p>这是由于对于原矩阵的一行/列展开，等于对其转置矩阵的一列/行展开，在考虑到行列式的递归定义，可以证明其正确性。</p>
          </div>
<p>方阵可逆当且仅当其行列式不为0.</p>
<blockquote>
<p>这个性质被用在特征向量的计算上，它反映了矩阵对向量变换时出现的降维打击现象。一旦一个向量被变换到了更低维度，其就不可能逆向到原向量，因为在变换的过程中已经失去了部分信息。</br> 习题3.2 21-23</p>
</blockquote>
<p>对于两个<span class="math inline">\(n\times{n}\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，有<span class="math inline">\(det(AB) = (detA)(detB)\)</span></p>
<div class="note note-warning">
            <p>一般来讲，加法<span class="math inline">\(det(A+B) = detA + detB\)</span>是不成立的，</p>
          </div>
<p>矩阵的逆的行列式与该矩阵的行列式互为倒数</p>
<blockquote>
<p>由于<span class="math inline">\(det(A A^{-1}) = 1\Rightarrow (detA)(detA^{-1})=1\)</span></p>
</blockquote>
<h3 id="基本的代数变换">基本的代数变换</h3>
<p><span class="math display">\[
\begin{array}{l}
|{k}A| = {k^n}|A| ,n为矩阵的阶\\
|A{\cdot}B| = |A|{\cdot}|B|  \\
|A^T| = |A|  \\
|A^{-1}| {\cdot} |A| = 1  \\
|A^*| = |A|^{n-1}  \\
|A| = \prod_{i=1}^{n}{\lambda}_i  \\
|A| = |B|, A与B相似
\end{array}
\]</span></p>
<h2 id="计算技巧">计算技巧</h2>
<h3 id="times-3行列式"><span class="math inline">\(3\times 3\)</span>行列式</h3>
<p><span class="math inline">\(3\times 3\)</span>行列式可以将前两列写在后面，得到一个<span class="math inline">\(3\times 5\)</span>行列式，这个行列式由左下到右上、左上到右下依次有六个对角线，将对角线上的元素相乘，下面的取正，上面取负后相加即可得到结果。</p>
<p>结论证明很简单，同样的道理竖着堆叠也一样；其本质应该是将计算的过程进行了展开。</p>
<h3 id="初等变换">初等变换</h3>
<p>矩阵的初等变换，无论是行变换还是列变换，对行列式的影响都是相似的</p>
<ol type="1">
<li>行/列交换：行列式为原矩阵的相反数</li>
<li>行/列倍加：不改变行列式的值</li>
<li>行/列倍乘：<span class="math inline">\(|kA|=k|A|\)</span></li>
</ol>
<p>有这样的性质，我们可以将矩阵化为阶梯形简化计算。</p>
<p>同样的，注意将眼光放大到列变换。对于一些线性相关的列，其行列式也为0；一列也可以利用倍加法则进行分离得到两个独立的矩阵。</p>
<h3 id="对称矩阵等特殊矩阵的性质">对称矩阵等特殊矩阵的性质</h3>
<p>对于对称矩阵，有</p>
<p><span class="math display">\[
\begin{array}{l}
A{A^T}=E\\
{\because}|A{A^T}|=|A||A^T|=|A|^2=|E|=1\\
{\therefore}|A|={\plusmn}1
\end{array}
\]</span></p>
<h3 id="克拉默法则">克拉默法则</h3>
<blockquote>
<p>克拉默法则提供了一个通过计算行列式得到线性方程的根的方式。仅适用于未知量个数与方程数量相等时使用</p>
</blockquote>
<p>克拉默法则可以描述为将矩阵的第<span class="math inline">\(i\)</span>列使用目标向量<span class="math inline">\(\mathbf{b}\)</span>替换，解向量的第<span class="math inline">\(i\)</span>个元素<span class="math inline">\(x_i = { {det{A_i}{(\mathbf{b})} }\over{detA} }\)</span></p>
<ul>
<li><p>如果非齐次线性方程组<strong>无解</strong>或<strong>有两个不同解</strong>，则它的系数行列式必为0。</p></li>
<li><p>若齐次线性方程组的系数行列式不为0，则齐次线性方程组只有0解；如果方程组<strong>有非零解</strong>，那么必有<span class="math inline">\(|A|=0\)</span>。</p></li>
</ul>
<h3 id="逆矩阵公式">逆矩阵公式</h3>
<p><span class="math display">\[
{A^{-1} } = { {1}\over{detA} }{adjA}
\]</span></p>
<p>其中，<span class="math inline">\(adjA\)</span>为伴随矩阵，它是由<span class="math inline">\(A\)</span>的余因子组成的，但元素的位置由<span class="math inline">\((i,j)\)</span>变为<span class="math inline">\((j,i)\)</span>。</p>
<h3 id="三角形面积公式">三角形面积公式</h3>
<p><span class="math display">\[
S = {1\over{2} }
  {
  \left |
  \begin{array}{ccc}
  {x_1} &amp; {y_1} &amp; 1 \\
  {x_2} &amp; {y_2} &amp; 1 \\
  {x_3} &amp; {y_3} &amp; 1 \\
  \end{array}
  \right |
}
\]</span></p>
<h2 id="使用行列式进行判定">使用行列式进行判定</h2>
<h3 id="线性无关相关">线性无关/相关</h3>
<p>由可逆矩阵定理，行列式等于0<span class="math inline">\(\Rightarrow\)</span>矩阵不可逆<span class="math inline">\(\Rightarrow\)</span>矩阵存在线性相关的列</p>
<blockquote>
<p>线性相关的列会导致变化后不是满秩，输出向量被降维，因此其行列式为0</br> 对于全为0的列/行，相当于零向量，自然会与其他列/行线性相关，导致行列式为0</br> 习题3.2 24-26</p>
</blockquote>
<h2 id="特殊行列式">特殊行列式</h2>
<h3 id="上下三角行列式">上下三角行列式</h3>
<p>行列式为对角线元素的乘积。</p>
<h3 id="副对角线行列式">副对角线行列式</h3>
<p>副对角线元素的乘积与<span class="math inline">\((-1)^{ {n(n-1)\over{2} } }\)</span>的乘积。</p>
<h3 id="拉普拉斯展开式">拉普拉斯展开式</h3>
<blockquote>
<p>面向分块矩阵使用</p>
</blockquote>
<p>对于<span class="math inline">\(m{\times}m\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(n{\times}n\)</span>矩阵<span class="math inline">\(B\)</span>，有</p>
<p><span class="math display">\[
\left |
\begin{array}{cc}
A &amp; 0 \\
* &amp; B
\end{array}
\right | =
\left |
\begin{array}{cc}
A &amp; * \\
0 &amp; B
\end{array}
\right | =
|A|{\cdot}|B|
\]</span></p>
<p><span class="math display">\[
\left |
\begin{array}{cc}
0 &amp; A \\
B &amp; *
\end{array}
\right | =
\left |
\begin{array}{cc}
* &amp; A \\
B &amp; 0
\end{array}
\right | =
(-1)^{mn}{\cdot}|A|{\cdot}|B|
\]</span></p>
<h3 id="范德蒙德展开式">范德蒙德展开式</h3>
<p><span class="math display">\[
\left |
\begin{array}{cccc}
{ {x_1}^0} &amp; { {x_2}^0} &amp; {\dotsc} &amp; { {x_n}^0} \\
{ {x_1}^1} &amp; { {x_2}^1} &amp; {\dotsc} &amp; { {x_n}^1} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
{ {x_1}^n} &amp; { {x_2}^n} &amp; {\dotsc} &amp; { {x_n}^n}
\end{array}
\right | =
{\prod_{n{\ge}i{\gt}j{\ge}1} }({x_i}-{x_j})
\]</span></p>
<h3 id="对角线元素相同且其他元素也相同的行列式">对角线元素相同且其他元素也相同的行列式</h3>
<p><span class="math display">\[
\left |
\begin{array}{ccccc}
a &amp; b &amp; b &amp; \dotsb &amp; b \\
b &amp; a &amp; b &amp; \dotsb &amp; b \\
b &amp; b &amp; a &amp; \dotsb &amp; b \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
b &amp; b &amp; b &amp; \dotsb &amp; a
\end{array}
\right | =
[a +(n-1)b](a-b)^{n-1}
\]</span></p>
<h2 id="进一步研究行列式">进一步研究行列式</h2>
<h3 id="行列式的线性性质">行列式的线性性质</h3>
<blockquote>
<p>参考教材3.2最后一段，还没太学会</p>
</blockquote>
<p>对于行列式的求解，可以视作从<span class="math inline">\(R^n\)</span>到<span class="math inline">\(R\)</span>的线性变换，其自变量是一组列向量，此时如果对某一个列向量进行变换，行列式就是关于这个列向量的线性函数。也就是说，如果将矩阵<span class="math inline">\(A\)</span>的列向量<span class="math inline">\(\mathbf{a_{j} }\)</span>更换为向量<span class="math inline">\(\mathbf{x}\)</span>，那么这个行列式就是关于它的线性函数<span class="math inline">\(T\)</span>。</p>
<p><span class="math display">\[
T(c\mathbf{x}) = cT(\mathbf{x})\\
T(\mathbf{u}+\mathbf{v}) = T(\mathbf{u})+T(\mathbf{v})
\]</span></p>
<h3 id="拉普拉斯变换">拉普拉斯变换</h3>
<p>拉普拉斯变换允许将一个线性微分方程组视作一个线性代数方程组，但其系数含有一个参数。</p>
<p>求解这样一个线性方程组在满足行列式不为0时的唯一解，只需使用克拉默法则即可。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是怎样跑起来的 笔记</title>
    <url>/blog/posts/30847/</url>
    <content><![CDATA[<h2 id="计算机三大原则">计算机三大原则</h2>
<p>计算机三大原则被描述为</p>
<ol type="1">
<li>计算机是执行输入、运算、输出的机器</li>
<li>程序是指令和数据的集合</li>
<li>计算机的处理方式有时与人们的思维习惯不同，对计算机来说什么都是数字</li>
</ol>
<p>第一点为计算机的设计提供了一个思路。由于计算机只执行这三个任务，因此在设计的时候我们也只需要考虑 I/O 进行输入输出，CPU 进行运算（CPU其实还需要内存来辅助保存数据），其他设备理论上都是可有可无或辅助这几个东西。</p>
<blockquote>
<p>DIY 圈所说的最小系统，在我记忆里（2018年左右）就是主板、内存和CPU，这些设备就可以保证主板的能跑完一整套自检和启动流程</p>
</blockquote>
<p>除了所谓的“软件定义世界，数据驱动未来”，第二条原则或许也可以认为对堆内存和栈内存的设计埋下伏笔。毕竟简单来讲，C/C++ 设计的栈内存就是以保存程序为目的，用堆内存保存运行数据。</p>
<h2 id="构建一台简单的计算机">构建一台简单的计算机</h2>
<h3 id="概览">概览</h3>
<p>一台计算机需要的只有三个元件，<strong>CPU、内存和I/O</strong>。</p>
<h3 id="数据和地址总线">数据和地址总线</h3>
<p>CPU上“A”开头的管脚一般表示地址（Address）总线引脚。地址总线用于设置数据输入或输出的地址，告诉CPU向哪里传输数据总线的数据。</p>
<p>“D”开头的管脚就是数据（Data）总线。通常长度以字节为单位。</p>
<h3 id="io和时钟">I/O和时钟</h3>
<p>I/O也有自己的寄存器，但与CPU中的不同，I/O的寄存器用于控制I/O的状态，比如操作的端口、端口的工作模式，并存储要和外部设备交换的数据。</p>
<p>时钟信号不必多说。</p>
<h3 id="其他控制引脚">其他控制引脚</h3>
<p>对于 CPU 来讲，内存和 I/O 都是连接到数据总线的，因此需要 MREQ(Memory Request) 和 IORQ(I/O Request) 引脚标识操作状态；相应的，内存或 I/O IC 上也会有 CE(Chip Enable) 管脚。</p>
<p>除了分清操作对象，还需要知道输入状态还是输出状态，这就需要 CPU 的 RD 引脚和 WR 引脚。</p>
<p>CPU 还有个极其重要的中断功能，这需要 INT（Interrupt）管脚提供支持。</p>
<p>上面所涉及的地址管线、数据管线和其他管线合称为总线。为了设置值，CPU 有 BUSRQ（Bus Request） 引脚隔离操作，此时可以对内存进行直接访问和修改，这种操作成为DMA（Direct Memory Access），此时，BUSAK（Bus Acknowledge）值为0。</p>
<blockquote>
<p>连接电路时，将管脚与一个电阻和 Vcc 连接称为上拉。</p>
</blockquote>
<h2 id="手工汇编">手工汇编</h2>
<h3 id="cpu中的寄存器">CPU中的寄存器</h3>
<p>CPU内部有许多功能不同的寄存器，例如</p>
<ul>
<li>累加器（A，Add）</li>
<li>标志寄存器（F，Flag）</li>
<li>程序指针寄存器（PC）</li>
<li>栈顶指针寄存器（SP，Stack Pointer）</li>
</ul>
<h3 id="汇编语言的读写">汇编语言的读写</h3>
<blockquote>
<p>汇编语言中，使用<code>num</code>这种形式表示值，<code>(num)</code>表示地址。</p>
</blockquote>
<p>汇编语言的一条语句，可能对应多个机器语言；一条机器语言的指令可能只有一个字节，也可能有两个、三个。因此，内存中的指令并不总是连续的。</p>
<blockquote>
<p>不同CPU的内存存储方式存在差异。例如将一个2字节的数据存到内存，一些CPU低8位在前、高8位在后，这种方式被称为小端序，Little Endian。</p>
</blockquote>
<h2 id="程序的流动">程序的流动</h2>
<h3 id="程序的基本流程">程序的基本流程</h3>
<p>程序有顺序执行、分支和循环三个基本流程。</p>
<h3 id="中断处理">中断处理</h3>
<p>中断处理是指计算机使程序的流程突然跳转到程序中的特定地方，这样的地方被称为终端处理例程（Routine）或是中断处理程序（Handler），这种跳转是 CPU 的硬件功能实现的。这种由于外部原因使正常处理流程中断，中断后再返回到之前流程的过程就是中断处理流程。</p>
<p>只需要记住两点</p>
<ul>
<li>计算机具有硬件上处理中断的能力</li>
<li>中断的英文是 Interrupt</li>
</ul>
<h3 id="事件驱动">事件驱动</h3>
<p>通常将用户的操作成为“事件”，事件驱动就是基于事件改变程序的状态。</p>
<h2 id="算法的七个要点">算法的七个要点</h2>
<ol type="1">
<li>步骤明确</li>
<li>过程可重复</li>
<li>经典算法</li>
<li>利用计算机的处理速度</li>
<li>使用技巧</li>
<li>找规律</li>
<li>先进行手动演算</li>
</ol>
<h2 id="数据结构的七个要点">数据结构的七个要点</h2>
<ol type="1">
<li>内存和变量的关系</li>
<li>数组</li>
<li>数组的应用</li>
<li>数据结构的类型</li>
<li>栈和队列</li>
<li>结构体</li>
<li>链表和二叉树</li>
</ol>
<h2 id="面向对象">面向对象</h2>
<h2 id="简单的数据库">简单的数据库</h2>
<h2 id="简单的tcpip网络">简单的TCP/IP网络</h2>
]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学引论</title>
    <url>/blog/posts/7a228d9b/</url>
    <content><![CDATA[<h2 id="分享">分享</h2>
<ul>
<li>善用wiki</li>
<li>整理一下内容（yysy书组织的层次有点乱）</li>
<li>排除法yyds</li>
<li>问答题回答作用、定义、特点都可以</li>
<li>以关键词组织体系</li>
</ul>
<h2 id="名词翻译">名词翻译</h2>
<h2 id="判断">判断</h2>
<ul>
<li>RAM是易失的，所以他需要供电</li>
<li>The software you install（安装） to help a printer communicate with a computer is called a device driver.</li>
<li>Serial processing is when a processor begins executing（执行） one instruction before it completes the previous instruction.</li>
<li>Public key encryption uses a public key to encrypt messages, but <strong>a private key is required to decrypt</strong> messages.</li>
<li>A computer’s operating system is not a type of application software.</li>
<li>The list of codes for a microprocessor’s instruction set is called machine language.</li>
<li>A compiler converts source code to <strong>object code.</strong></li>
<li>A dictionary attack is a virus that hides out in the spelling checker for your word processing software.</li>
<li>Today’s computers typically process 32 or 64 bits at a time.</li>
<li>In RAM microscopic（微型的） electronic parts called capacitors（电容器） hold the bits that represent datA.</li>
<li>ROM is a type of memory that holds the6 computer’s startup routine.</li>
<li>Hard disk drives, optical drives, and solid state drives are <strong>not random access devices.</strong></li>
<li>CD-RWs doesn't allow you to record data, but data cannot be changed once it is recorded</li>
<li>The most popular type of wired connection is Ethernet.</li>
<li>The Domain Name System stores IP addresses and their equivalent domain names</li>
<li>Dial-up and DSL provide Internet access using telephone cabling.</li>
<li>The Web uses cookies because HTTP is stateless.</li>
<li>E-mail attachments are converted with MIME into ASCII code.</li>
<li>Any access to data or programs by hackers, criminals, or other unauthorized persons is called intrusion.</li>
<li>Ethernet simultaneously broadcasts data packets to all network devices.</li>
<li>A B2C e-commerce transaction occurs when individual consumers purchase goods and services from online merchants.</li>
</ul>
<h2 id="选择">选择</h2>
<ul>
<li><p>The type of code that uses only seven bits for each character is ASCII</p>
<p>The Extended ASCII uses 8bits</p></li>
<li><p>If virus protection software identifies a virus, it can try to take all of the following actions including remove the infection,delete the file,put the file in quarantine,but except shut down the computer</p></li>
<li><p>A submenu,menu selection or dialog box is an additional set of commands that the computer displays after you make a selection from the main menu.</p></li>
<li><p>The main directory maintained by your computer’s operating system is the root directory (based on Linux/Unix)</p></li>
<li><p>Application software is designed to accomplish real-world tasks.</p></li>
<li><p>RAM is a temporary holding area for data, application program instructions, and the operating system.</p></li>
<li><p>RAM can be thought of as the waiting room for the computer’s processor</p></li>
<li><p>A connecting link is a physical path or a frequency used for signal transmissions.</p></li>
<li><p>A hard disk platter is a flat, rigid disk made of aluminum or glass and coated with magnetic iron oxide particles.</p></li>
<li><p>Antispyware software is a type of security software designed to identify and neutralize Web bugs, ad-serving cookies, and other types of malware.</p></li>
<li><p>A(n) web is a collection of related information organized and formatted so it can be accessed using software called a browser</p></li>
<li><p>To find a particular record or group of records in a database, you use a query.</p></li>
<li><p>A group of sectors is called a cluster.</p></li>
<li><p>Cable currently offers the fastest Internet access speeds.</p></li>
<li><p>Cable Internet service needs circuitry to handle Ethernet protocols and a cable modem.</p></li>
<li><p>Portable Internet access includes all of the following EXCEPT WIFI</p></li>
<li><p>A compute-intensive problem runs on a supercomputer</p></li>
<li></li>
</ul>
<h2 id="专题">专题</h2>
<h2 id="storage-type">storage type</h2>
<ul>
<li>solid state storage</li>
<li>magnetic storage</li>
<li>bubble storage</li>
<li>optical storage</li>
</ul>
<h2 id="chapter1-information-technologythe-internetand-you">Chapter1 Information Technology,the Internet,and You</h2>
<h3 id="information-systems">Information Systems</h3>
<p>Consider PC as a part of the information system.</p>
<h4 id="people">People</h4>
<ul>
<li>The PCs are making <strong>people, end users</strong> like you,more productive.</li>
</ul>
<h5 id="making-it-work-for-you">Making IT Work for You</h5>
<h5 id="tips">Tips</h5>
<ul>
<li>Privacy</li>
<li>Environment</li>
<li>Ethics</li>
<li>Careers in IT</li>
</ul>
<h4 id="procedures">Procedures</h4>
<ul>
<li><p>The rules or guidelines for people to follow when using software,harware,data are procedures.</p></li>
<li><p>They are usually <strong>documented in manuals</strong></p></li>
</ul>
<h4 id="software">Software</h4>
<ul>
<li>Tell the computer how to do its work.</li>
<li>Anothe name for a program</li>
<li>Convert <strong>data(umprocessed facts) into Information(processed facts).</strong></li>
</ul>
<h5 id="system-softwarechapter4">System Software(Chapter4)</h5>
<ul>
<li>Enables the application software to interact with the computer hardware</li>
<li>a collection of programs
<ul>
<li>Operating System（操作系统）:smartphones use embedded operating system,also known as real-time operating systems(RTOS);desktop computers use standalone operating systems;networks use network operating system.</li>
<li>Utilities:An example,antivirus program.</li>
</ul></li>
</ul>
<h5 id="application-softwarechapter3">Application Software(Chapter3)</h5>
<ul>
<li><p>General-purpose applications（通用应用程序）</p>
<p>To be considered an efficient and effective end user.</p>
<ul>
<li>Word processors</li>
<li>Spreadsheets:Analyze and summarize numerical data.</li>
<li>Database management systems（数据库管理系统）</li>
<li>Presentation software:Communicate a message or persuade other people.</li>
</ul></li>
<li><p>Specialized applications</p>
<p>More narrowly focused on specific disciplines and occupations</p>
<ul>
<li>Graphics（图像处理）</li>
<li>Web authoring programs</li>
</ul></li>
<li><p>Mobile apps</p>
<p>Primiraly designed for mobile device.</p>
<ul>
<li>Social networking</li>
<li>Games</li>
<li>Downloading music and videos</li>
</ul></li>
</ul>
<h4 id="hardware">Hardware</h4>
<ul>
<li>The equipment that processes the data to create information.</li>
<li>Includes smartphones, tablet,keyboards,mice,displays,system units,and other devices.</li>
<li><strong>Controlled by software.</strong></li>
</ul>
<h5 id="types-of-computers">Types of Computers</h5>
<ul>
<li>Supercomputers（超算）:most powerful;analyze and predict worldwide weather patterns;for example,IBM's Blur Gene</li>
<li>Mainframe computers（大型机）:for example,insurance companies use them to process information about millions of policyholders.</li>
<li>Midrange computers（中型机）:support or serve end users for such specific needs as retrieving data from a database or supplying access to application software.</li>
<li>Personal computers(PCs):five types
<ul>
<li>Desktop computers</li>
<li>Laptop computers(notebook computers)</li>
<li>Tablets(Tablet computers)</li>
<li>Smartphones</li>
<li>Wearable device</li>
</ul></li>
</ul>
<h5 id="cell-phones">Cell Phones</h5>
<p>Cell phone is also a computer</p>
<h5 id="personal-computer-hardware">Personal Computer Hardware</h5>
<ul>
<li><p><strong>System unit(Chapter5)（系统单元）</strong>:a contaniner thar houses most of the electronic components that make up a computer system;<strong>microprocessors and memory</strong> are two important components</p>
<p>One type of memory is random-access memory(RAM) which is sometimes referred to as temporary storage</p>
<blockquote>
<p>此概念是指计算机的硬件组成</p>
</blockquote></li>
<li><p><strong>Input/output(Chapter6)</strong>:keyboard and mouse; display,as known monitor</p></li>
<li><p><strong>Secondary storage(Chapter7)(外存)</strong>:holds data constantly</p>
<p>Hard disks:using rigid metallic platters and read/write heas that move across the platters,data and information are stored using <strong>magnetic charges</strong> on diks's surface.</p>
<p>Solid-state storage:save data similar to RAMs</p>
<p>Optical discs:using <strong>laser tchnology</strong> to store data and programs; i<strong>ncluding compact discs(CDs),digital versatile(or video) discs(DvD),and Blu-ray Discs(BD)</strong></p></li>
<li><p><strong>Communication(Chapter8)</strong></p></li>
</ul>
<h4 id="data">Data</h4>
<ul>
<li><p>The raw information</p>
<blockquote>
<p>与information相对，data是指未经处理的元数据</p>
</blockquote></li>
</ul>
<h5 id="types">Types</h5>
<ul>
<li>Document files</li>
<li>Worksheet files</li>
<li>Database files</li>
<li>Presentation files</li>
</ul>
<h4 id="internet">Internet</h4>
<ul>
<li>A way to connect to other people and computers.</li>
</ul>
<h3 id="connectivity-and-the-mobile-internet">Connectivity and the Mobile Internet</h3>
<ul>
<li>A network is a communications system connecting two or more computers</li>
<li>The largest network in the world is the Internet</li>
<li>The web provides a multimedia interface to the resource</li>
</ul>
<h5 id="things-driving-the-impact-of-tehcnology">Things Driving the Impact of Tehcnology</h5>
<ul>
<li>Cloud computing(云计算)</li>
<li>Wireless communication</li>
<li>Internet of Things(物联网)</li>
</ul>
<hr />
<h2 id="chapter2-the-internetthe-web-and-electronic-commerce">Chapter2 The Internet,The WEB ,and Electronic Commerce</h2>
<h3 id="the-internet-and-the-web">The Internet and the Web</h3>
<ul>
<li>Adavanced Research Project Agency Network(ARPANET), an immense network that connects small er networks was <strong>launched in 1969</strong></li>
<li>The web, also known as the World Wide Web or WWW, <strong>was introduced in 1991.</strong></li>
<li>The web made a multimedia interface to resources on ther internet.</li>
</ul>
<h4 id="the-three-generations-of-web">The three generations of Web</h4>
<ul>
<li>Web1.0: <strong>linking existing information</strong>
<ul>
<li>Google and other research engines made it possible to search web pages</li>
<li>Many users can view web content, but few can create web content</li>
</ul></li>
<li>Web2.0:<strong>more dynamic content creation and social interaction</strong>
<ul>
<li>Facebook and othe social media are examples</li>
</ul></li>
<li>Web3.0:identifies <strong>relations between data</strong>
<ul>
<li>Siri and Google Assistant are exmples</li>
</ul></li>
<li>Web4.0:connect data and devices into a seamless integration into our physical life</li>
</ul>
<h4 id="web-and-internet">Web and Internet</h4>
<ul>
<li><p>The <strong>Internet is a physical network</strong>, which is made up of wires, cables,satallites, and rules for exchanging information between computers connected to the network.</p></li>
<li><p>Being connected to the web is called <strong>online.</strong></p></li>
<li><p>The <strong>web is a multimedia interface.</strong></p>
<blockquote>
<p>区分internet和web的根本差异就是internet是一个物理层面的网络，web是对internet这个物理网络的封装。在web出现之前，对internet的使用就像是GUI出现之前使用DOS</p>
</blockquote></li>
</ul>
<h4 id="the-common-uses-of-web">The common uses of Web</h4>
<ul>
<li>Communicating</li>
<li>Shopping</li>
<li>Searching</li>
<li>Education or e-learning</li>
<li>Online entertainment</li>
</ul>
<h4 id="online-entertainment">Online Entertainment</h4>
<ul>
<li>TV Shows and Movies</li>
<li>Online Music</li>
<li>Online Book</li>
<li>Social Media</li>
<li>News feeds</li>
</ul>
<h3 id="internet-access">Internet Access</h3>
<h4 id="providers提供商">Providers(提供商)</h4>
<ul>
<li><p>The most common way to connect to the Internet is through an <strong>Internet service provider(ISP)(网络服务提供商)</strong></p></li>
<li><p>Using telephone lines cable, and/or wireless connections</p>
<blockquote>
<p>该条目是指连接的物理方式</p>
</blockquote></li>
<li><p>Providers in America includs AT&amp;T, Comcast,Sprint,T-Mobile, and Verizon</p></li>
<li><p>Connection techonologies including <strong>DSL, cable, and wireless modem</strong></p>
<blockquote>
<p>该条目是指连接的技术</p>
</blockquote></li>
</ul>
<h4 id="browsers浏览器">Browsers(浏览器)</h4>
<ul>
<li><p>The progrm to connect to theInterne is called the browsers</p></li>
<li><p>Apple Safari,Google Chrome,FireFox,Microsoft Egde,etc</p></li>
<li><p>The location or address of the resource is called <strong>uniform resource locators(URLs)(统一资源定位符)</strong></p>
<blockquote>
<p>URL：统一资源定位符</p>
<p>URI(uniform resource identiter)：统一资源识别符</p>
</blockquote></li>
<li><p>All URLs have at least two basic parts</p>
<ul>
<li><p>To present the <strong>protocol(协议)</strong>. http/https is used for web traffic</p></li>
<li><p>To present the <strong>domain name(域名)</strong>. The last part of the domain name following the dot is the <strong>top-level domain(TLD)（顶级域名）</strong>,also known as the <strong>web suffix</strong>,which identifies thetype of the organization.</p>
<table>
<thead>
<tr class="header">
<th>Domain</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.com</td>
<td>Commercial</td>
</tr>
<tr class="even">
<td>.edu</td>
<td>Educational</td>
</tr>
<tr class="odd">
<td>.gov</td>
<td>Goverment</td>
</tr>
<tr class="even">
<td>.mil</td>
<td>U.S.military</td>
</tr>
<tr class="odd">
<td>.net</td>
<td>Network</td>
</tr>
<tr class="even">
<td>.org</td>
<td>Organization</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>An document will be sent back once connected to the website, which usually contains <strong>Hypertext Markup Language(HTML)(超文本标记语言)</strong>,a language displaying web page.</p></li>
<li><p>Many techonologies are used to show animated and interactive websites</p>
<ul>
<li><p>JavaScript:used within HTML to trigger interactive features, executes on the <strong>user's computer</strong></p></li>
<li><p>PHP:<strong>executes on the website's computer</strong></p></li>
<li><p>Cascading style sheets(CSS):control the appearence of the web page</p>
<blockquote>
<p>JavaScript是一种运行在浏览器上的脚本语言，往往被用在客户端；PHP往往被用于服务端开发</p>
</blockquote></li>
</ul></li>
</ul>
<h3 id="web-utilities">Web Utilities</h3>
<h4 id="filters过滤器">Filters(过滤器)</h4>
<ul>
<li>block access to selected sites</li>
</ul>
<h4 id="web-transfer-utilitiesweb传输工具">Web Transfer Utilities(web传输工具)</h4>
<ul>
<li><p>Web-based file transfer services:make use of a <strong>browser to upload and download</strong> files,such as dropbox.com</p></li>
<li><p>BitTorrent(种子): distributes a file across many computers to accelerate.</p>
<p><strong>A single file might be located on dozens of individual computers.</strong></p>
<p>Have been used for distributing unauthorized copies of copyrighted music and video</p></li>
<li><p><strong>FIle transfer pritocol(FTP)</strong> and secure FTP(SFTP)</p></li>
</ul>
<h4 id="internet-security-suites">Internet Security Suites</h4>
<ul>
<li>Designed to maintain the security and privacy</li>
</ul>
<h3 id="communications">Communications</h3>
<h4 id="social-networking">Social Networking</h4>
<ul>
<li><p>Profiles:created by users to share information about them</p></li>
<li><p>Pages:created by companies to promote their bussiness</p></li>
<li><p>Groups:communities of individuals</p></li>
<li><p>Friends</p></li>
<li><p>News feed:the first page you see after you log in.</p>
<p>consists of a collection of recent posts</p></li>
<li><p>Share settings</p></li>
</ul>
<h4 id="blogsmicroblogspodcastsand-wikis">Blogs,MicroBlogs,podcasts,and Wikis</h4>
<ul>
<li>Personal websites is called blogs</li>
<li>Microblogs are designed to use with mobile devices,such as Twitter and Instagram</li>
<li>wiki is a website designed to allow visitors to add, edit,or delete the content</li>
</ul>
<h4 id="messaging">Messaging</h4>
<ul>
<li>Text Massaging,or <strong>short message service(SMS)</strong>:typically fewer than 160 characters</li>
<li><strong>Multimedia message servie(MMS)</strong>:a SMS with images, video or sound</li>
<li>Instant message(IM)</li>
</ul>
<h4 id="e-mail">E-mail</h4>
<p>A typical e-mail message has four basic parts:<strong>header, message,signature and newsletters</strong></p>
<p>Header appears first and includes</p>
<ul>
<li>Address:username@domain name</li>
<li>Subject:A one-line description</li>
</ul>
<p>You can add attachments in an e-mail</p>
<p>Two basic types of e-mail systems</p>
<ul>
<li>Client-based e-mail system:Run <strong>a program to communicate with ther e-mail service provider,</strong>such as Apple's Mail and Microsofts' Outlook</li>
<li>Web-based e-mail system:Once the web browser connected to the e-mail service provider, <strong>a webmail client is run on the provider's computer</strong> ,known as the webmail.</li>
</ul>
<p>Webmail is userd more widely because if frees the user</p>
<p>The unwelcomed e-mail is called spam</p>
<h3 id="search-tools">Search Tools</h3>
<ul>
<li>Special Programs called spiderscontinually look fornew information and update the search service's database</li>
</ul>
<h4 id="search-engine">Search Engine</h4>
<h4 id="contant-evalution">Contant Evalution</h4>
<ul>
<li>Authority</li>
<li>Accuracy</li>
<li>Objectivity</li>
<li>Currency</li>
</ul>
<h3 id="electronic-commerce">Electronic Commerce</h3>
<h4 id="basic-types-of-electronic-commerce">Basic types of Electronic Commerce</h4>
<ul>
<li>Bussiness-to-consumer(B2C)</li>
<li>Consumer-to-consumer(C2C):such as web auctions,ebay.com</li>
<li>Business-to-Bussiness(B2B)</li>
</ul>
<h4 id="security">Security</h4>
<h3 id="cloud-computing">Cloud Computing</h3>
<p>Basic components</p>
<ul>
<li>Clients</li>
<li>The internet</li>
<li>The service provider</li>
</ul>
<h3 id="the-internet-of-thingsiots">The Internet of Things(IoTs)</h3>
<hr />
<h2 id="chapter3-application-software">Chapter3 Application Software</h2>
<h3 id="application-software">Application Software</h3>
<h4 id="user-interface用户界面">User Interface(用户界面)</h4>
<ul>
<li><strong>Graphic user interface (GUI)(图形用户界面)</strong> displays graphical elements called icons to represent familiar objects.</li>
<li>The standard GUI includes
<ul>
<li>Menus:on the top of a window,displays in a menu bar</li>
<li>Toolbars:appear below the menu bar and include small graphical elements called buttons</li>
<li>Dialog boxes:additioanl information and request user input</li>
</ul></li>
<li>Many applications use <strong>an iterface known as the Ribbon GUI</strong>, which changes based on the need of the user
<ul>
<li>Ribbons:replace toolbars and menus by re-combining them together,displayed at tabs and appear in the first ribbon</li>
<li>Tabs:divide the ribbon into major activity areas.Then organized into groups containg related items. Some taabs called contextual tabs appear only when they are needed</li>
<li>Galleries:provide additional options and simplify choosing and option by showing the effect</li>
</ul></li>
</ul>
<h4 id="common-featuers">Common featuers</h4>
<ul>
<li>Spell checker</li>
<li>Alignment-centers</li>
<li>Fonts and font sizings</li>
<li>Character effects</li>
<li>Edit options: provide easy ways to edit text, such as cut, copy and paste</li>
<li>Find and Replace</li>
</ul>
<h3 id="general-purpose-applications">General-Purpose Applications</h3>
<h4 id="word-processors">Word Processors</h4>
<ul>
<li>Grmmar chacker</li>
<li>Autocorrect</li>
<li>Captions:Identifying figures with captions in areport makes the report easier to read and more professional</li>
<li>Footnote</li>
<li>Header ot Footer</li>
</ul>
<h4 id="spreadsheets">Spreadsheets</h4>
<ul>
<li>Workssheets</li>
<li>Functions</li>
<li>Cells</li>
<li>Formulas</li>
<li>Workbook</li>
</ul>
<h4 id="presentation-doftware">Presentation Doftware</h4>
<ul>
<li>Templates:provide an easy way to create a presentation by providing pre-designed styles and layouts</li>
<li>Animation</li>
<li>Document Theme</li>
</ul>
<h4 id="database-management-software">Database Management Software</h4>
<ul>
<li>Primary Key:the unique identification key</li>
<li>Record:A combination of data</li>
<li>Fields:are given names that are displayed at the top of each table</li>
</ul>
<h3 id="specialized-applications">Specialized Applications</h3>
<h4 id="graphic-programs">Graphic Programs</h4>
<ul>
<li><p>Video editors</p></li>
<li><p>Image Editor, also known as photo editor</p>
<p>A picture consists of thousands of <strong>dots, or pixels(像素) is referred as bitmap(位图) or raster images.</strong></p></li>
<li><p>Illustration programs, also known as drawing programs:to create and edit <strong>vector(矢量图) images</strong></p></li>
<li><p>Desktop Publishing programs</p></li>
</ul>
<h4 id="video-game-design-software">Video Game Design Software</h4>
<h4 id="web-authoring-programs">Web Authoring Programs</h4>
<h3 id="mobile-apps">Mobile APPs</h3>
<h4 id="apps">Apps</h4>
<h4 id="app-stores">App Stores</h4>
<h3 id="software-suites">Software Suites</h3>
<h4 id="office-suites">Office Suites</h4>
<h4 id="cloud-computing-1">Cloud Computing</h4>
<h4 id="specialized-and-utility-suites">Specialized and Utility Suites</h4>
<hr />
<h2 id="chapter4-system-software">Chapter4 System Software</h2>
<h3 id="system-software">System Software</h3>
<p>Four types</p>
<ul>
<li>Operating system</li>
<li>Utilities: perform specific taks related to computer's resources</li>
<li>Device Drivers（设备驱动）</li>
<li>Language translators(编译器): convert the programming instructions written by programmers into a language that computers understand and process</li>
</ul>
<h3 id="operating-software">Operating Software</h3>
<p>The most important type of computer programs</p>
<p>Often referred to as the software environment or software platform</p>
<h4 id="functions">Functions</h4>
<ul>
<li>Managing resource:coordinate computer's resource including memory, processing. storage and devices; monitor system performance, schedule taks, etc</li>
<li>Providing user interface</li>
<li>Running applications: most support multitasking or the ability to switch between different applications stored in the memory; the application you're running is in the <strong>foreground</strong>, the others are in the <strong>background</strong></li>
</ul>
<h4 id="features">Features</h4>
<ul>
<li>Starting or restarting a computer is called <strong>booting the system.</strong></li>
<li>Booting has two ways: <strong>a warm boot and a cold boot</strong></li>
<li>A warm boot is when the computer is running and you restart it without cutting the power off</li>
<li>A cold boot means start a computer that has been turned off</li>
<li>Most OSs provide a <strong>desktop</strong> to access the computer resource
<ul>
<li>Icons: a graphical representation of a application, a file or function</li>
<li>Pointer</li>
<li>Windows</li>
<li>Menus: a list of options or commands</li>
<li>Tabs: devide menus into major activity areas such as format and page layout</li>
<li>Dialog Boxes</li>
<li>Help:provide online assistance</li>
<li>Gesture control: <strong>ability to control operation with finger movements,</strong> such as swiping, sliding and pinching</li>
</ul></li>
</ul>
<h4 id="categories">Categories</h4>
<ul>
<li>Embedded operating systems, also <strong>real-time operating systems(RTOS)</strong>:small electronic devices such as smartphones and smartwatches.</li>
<li>Stand-alone operating systems,also known as <strong>desktop operating systems</strong>: control a single desktop or laptop computer</li>
<li>Netork operating systems: used to control and coordinate computers that are networked or linked together; thet're typically located on one of the connected computers' hard disks. the computer is called network server.</li>
</ul>
<h3 id="mobile-operating-systems">Mobile Operating Systems</h3>
<p>Less complicateed and more specialized for wireless communications</p>
<ul>
<li>Android: developed by Google based on the Linux</li>
<li>iOS</li>
</ul>
<h3 id="desktop-operating-systems">Desktop Operating Systems</h3>
<h4 id="windows">Windows</h4>
<h4 id="macos">macOS</h4>
<h4 id="unix-and-linux">UNIX and Linux</h4>
<ul>
<li>Linux is an operating system that extended onr of the UNIX versions</li>
<li>Chrome OS is based on Linux</li>
</ul>
<h4 id="virtualization">Virtualization</h4>
<ul>
<li><strong>A single computer can support multiple operating systems</strong> that operate independently</li>
<li>The virtual computers are called <strong>virtual machines</strong></li>
<li>The OS of the physical machine is called <strong>host operating system</strong>, and of the virtual machines are called <strong>guest operating systems</strong></li>
</ul>
<h3 id="utilities">Utilities</h3>
<ul>
<li>Search programs</li>
<li>Storage management programs</li>
<li>Backup programs</li>
<li>Antivirus programs</li>
<li>Troubleshooting or diagnostic programs</li>
<li>Virtual assistance</li>
</ul>
<h4 id="operating-system-utilities">Operating System Utilities</h4>
<ul>
<li>Search programs</li>
<li>Storage management program: identify and remove unused files and applications</li>
<li>Backup programe</li>
</ul>
<h4 id="utility-suites">Utility Suites</h4>
<hr />
<h2 id="chapter5-the-ststem-unit">Chapter5 The Ststem Unit</h2>
<h3 id="system-unit">System Unit</h3>
<ul>
<li>System unit, also known as system chassis is a container of electronic components</li>
</ul>
<h4 id="smartphones">Smartphones</h4>
<h4 id="tablets">Tablets</h4>
<h4 id="laptops">Laptops</h4>
<ul>
<li>Two-in-one laptops</li>
<li>Gaming laptops</li>
<li>Ultrabooks/ultraportables/mini notebooks</li>
</ul>
<h4 id="desktops">Desktops</h4>
<ul>
<li>All-in-one desktops</li>
<li>Tower unit or tower computer</li>
</ul>
<h4 id="wearble-computers">Wearble Computers</h4>
<ul>
<li>Smartwatches</li>
<li>Activity trackers</li>
</ul>
<h3 id="system-board">System Board</h3>
<ul>
<li><p>Also known as the <strong>mainboard or the mother board</strong></p></li>
<li><p>For mobile devices, the system board is located behind the screen; and for laptops and desktops is located at the bottom of the system unit or along one side</p></li>
<li><p>It's a flat circuit board covered with components, like:</p>
<ul>
<li><p>Sockets: a connection point for small specialized <strong>electronice parts called chips</strong></p>
<p><strong>Chips consist of tiny circuit boards</strong> etched onto squares of sandlike material called silicon</p>
<p>A chip is also called a silicon chip,semicondeuctor, or integrated circuit</p>
<p><strong>Chips are mounted onto chip carriers</strong>, and the carriers can be plugged into slots on the system board</p></li>
<li><p>Slots: a connection point for specialized <strong>cards or circuit boards</strong></p></li>
<li><p>Bus lines,also known as connecting lines: provide pathways for communicating</p></li>
</ul></li>
</ul>
<h3 id="microprocessor">Microprocessor</h3>
<p>Mostly, the central processing unit(CPU) or processor is contained on a single chip cakked the microprocessor</p>
<ul>
<li>Control unit: directs the movements of electronic signals between memory</li>
<li>Arithmetic-logic unit(ALU): Artithmetic operations includes: addition, subtraction, multiplication, and division;Logical operations consists equal, less than and greater than</li>
</ul>
<h4 id="microprocessor-chips">Microprocessor Chips</h4>
<ul>
<li>Chip <strong>processing capacity</strong> are expressed in <strong>word sizes</strong> such as 32/64bits</li>
<li>The <strong>processing speed</strong> is represented by its <strong>clock speed</strong></li>
<li>Many computers have <strong>multicore processor</strong>s that can provide two or more sparate and independent CPUs</li>
<li><strong>Parallel processing</strong> is a method to divide tasks into each CPU</li>
</ul>
<h4 id="specialty-processors">Specialty Processors</h4>
<ul>
<li><strong>Coprocessors</strong> are special chips to improve specific computing operations</li>
<li>Graphic coprocessors, also known <strong>as a GPU(graphics processing uni)</strong></li>
</ul>
<h3 id="memory">Memory</h3>
<h4 id="ramrandom-access-memory">RAM(Random-access memory)</h4>
<ul>
<li>RAM is called t<strong>emporary or volatile storage</strong> because ecerything in the RAM is lost once the power is cut off</li>
<li><strong>Cache memory</strong> acts as a temporary high-speed holding area between memory and the PCU</li>
<li><strong>DIMM(dual in-line memory module)</strong> can be inserted into the system board to expand the RAM</li>
<li><strong>Virtual memory</strong> is able to work as a RAM to run large programs</li>
</ul>
<h4 id="romread-only-memory">ROM(Read-only memory)</h4>
<ul>
<li>It's not volatile and can't be changed by the user</li>
<li>only CPU can read , or retrieve, data and programs written on the ROM chip</li>
</ul>
<h4 id="flash-memory">Flash Memory</h4>
<ul>
<li>used to store the start-up instructions, which is called the system's <strong>BIOS(basic input/output system).</strong></li>
</ul>
<h3 id="expansion-cards-and-slots">Expansion Cards and Slots</h3>
<ul>
<li>Graphics cards</li>
<li>Network interface cards(NIC),also known as network adapter cards</li>
<li>Wireless network cards</li>
</ul>
<h3 id="bus-lines">Bus Lines</h3>
<ul>
<li><strong>The number of bits</strong> that can travel simultaneously down a bus is known as the bus width</li>
<li><strong>System buses</strong> connects the <strong>CPU to memory</strong> and e<strong>xpansion buses</strong> connects CPU to other components on the system board, <strong>including expansion slots</strong></li>
</ul>
<h4 id="expansion-buses">Expansion Buses</h4>
<ul>
<li>Universal Serial Bus(USB):the current USB standard is USB 3.2</li>
<li>FireWire buses: used to connect video and audio devices</li>
<li>PCI express(PCIe): provide <strong>a singele dedicated path</strong> for each connected device</li>
</ul>
<h3 id="ports">Ports</h3>
<h4 id="standdard-ports">Standdard Ports</h4>
<ul>
<li>Universal serial bus ports:USB-A,B,C;a single SUB port can connect to many USB devices</li>
<li>HIgh Definition Multimedia Interface(HDMI) port</li>
<li>Thunderbolt ports</li>
<li>Ethernet ports</li>
</ul>
<h4 id="specialized-ports">Specialized Ports</h4>
<ul>
<li>Mini DisplayPort</li>
<li>VGA(Video Graphics Adapter) and DVI(Digital Video Interface)</li>
<li>FireWire ports</li>
</ul>
<h4 id="cables">Cables</h4>
<h3 id="power-supply">Power Supply</h3>
<p><strong>Computers require direcet current(DC)</strong></p>
<ul>
<li>DC adpter can convert AC to DC and charge the battery</li>
<li>Wireless charging platform can chage without cable</li>
<li>Power supply unit is working in a desktop</li>
</ul>
<h3 id="electronic-data-and-instructions">Electronic Data and Instructions</h3>
<h4 id="numeric-representation">Numeric representation</h4>
<ul>
<li>Decimal, binary and Hexadecimal system</li>
</ul>
<h4 id="character-encoding">Character Encoding</h4>
<ul>
<li>In the history, pC uses ASCII(America Standard Code for Information Interchange), the Mainframe uses EBCDIC(Extended Binary CodedDecimal Interchange Code)</li>
<li>Unicode</li>
</ul>
<hr />
<h2 id="chapter6-input-and-output">Chapter6 Input and Output</h2>
<h3 id="input-and-output">Input and Output</h3>
<h3 id="keyboard-entry">Keyboard Entry</h3>
<ul>
<li>Virtual keyboards</li>
<li>Laptop keyboards</li>
<li>Traditional keyboards: toggle keys and combination keys</li>
</ul>
<h3 id="pointing-devices">Pointing devices</h3>
<h4 id="touch-screen">Touch Screen</h4>
<ul>
<li>A <strong>stylus is a penlike device</strong> which works with the handwriting recognition software</li>
<li><strong>Writing recognition software</strong> translates handwritten notes into a form that the system unit can process</li>
<li>Multitouch screens can be touched with one or ore fingers</li>
</ul>
<h4 id="mouse">Mouse</h4>
<h4 id="game-controllers">Game Controllers</h4>
<ul>
<li>Joysticks</li>
<li>Gaming mice</li>
<li>Gamepads</li>
<li>Motion-sensing devices</li>
</ul>
<h3 id="scanning-devices">Scanning Devices</h3>
<h4 id="optical-scanners">Optical Scanners</h4>
<ul>
<li>Flatbed scanner: like a copy machine</li>
<li>Document scanner: quickly scan multipage document</li>
<li>Portable scanner</li>
<li>3D scanner</li>
</ul>
<h4 id="card-readers">Card Readers</h4>
<ul>
<li>Read the encoded information stored in the card</li>
</ul>
<h4 id="bar-code-readers">Bar Code Readers</h4>
<ul>
<li>UPC(Universal Product Codes): automate the process to check oult customers, change product prices and to maintain inventory records</li>
<li>MaxiCode</li>
</ul>
<h4 id="rfid-readers">RFID Readers</h4>
<h4 id="character-and-mark-recognition-device">Character and Mark Recognition Device</h4>
<ul>
<li>Magnetic-ink character recognition(MICR)</li>
<li><strong>Optical-character recognition(OCR)</strong></li>
<li>Optical-mark recognition(OMR): often <strong>used to score standardized multiple-choice test</strong>s</li>
</ul>
<h3 id="image-capturing-devices">Image Capturing Devices</h3>
<h4 id="digital-cameras">Digital Cameras</h4>
<h4 id="webcams">Webcams</h4>
<h3 id="audio-input-devices">Audio-Input Devices</h3>
<h3 id="monitors">Monitors</h3>
<h4 id="features-1">Features</h4>
<p>Clarity refers to the quality and sharpness of the displayed images</p>
<ul>
<li>Resolution</li>
<li><strong>Dot(pixel) pitch</strong>: the distance between each pixel; Cell phones can have smaller pitches</li>
<li>Contrast ratios</li>
<li>Active display area</li>
<li>Aspect ratio</li>
</ul>
<h4 id="flat-panel-monitors">Flat-Panel Monitors</h4>
<ul>
<li>LCD(liquid crystal display): used for older monitors and less expensive</li>
<li>LED(light-emitting diode)</li>
<li>OLED(organic light-emitting diode)</li>
</ul>
<h4 id="e-book-readers">E-Book Readers</h4>
<ul>
<li>E-ink, used by E-book readers, produces images that reflect light like ordinary paper</li>
</ul>
<h4 id="other-monitors">other Monitors</h4>
<ul>
<li>Digital or interactive monitors</li>
<li>Flexible screens</li>
<li>DIgital projectors</li>
</ul>
<h3 id="printers">Printers</h3>
<h4 id="features-2">Features</h4>
<ul>
<li>Resolution: meaured in dpi(dots per inch), the higher the better</li>
<li>Color capability: grayscale, images are displayed using many shades of gray</li>
<li>Speed</li>
<li>Memory: to store printing instructions and documents</li>
<li><strong>Duplex printing: printing in both sides of a sheet of paper</strong></li>
<li>Connectivity: the ability to connect to the network</li>
</ul>
<h4 id="inkjet-printers">Inkjet Printers</h4>
<h4 id="laser-printers">Laser Printers</h4>
<h4 id="d-printersadditive-manufacturing">3D Printers(additive manufacturing)</h4>
<h4 id="other-printers">Other Printers</h4>
<ul>
<li>Cloud printer</li>
<li>Thermal printer: use heat elements to produce image on heat-sensitive paper</li>
<li>Plotter</li>
</ul>
<h3 id="audio-output-device">Audio-output Device</h3>
<h3 id="combination-input-and-output-devices">Combination Input and Output Devices</h3>
<h4 id="headsets">Headsets</h4>
<h4 id="multifunctional-devicesmfd">Multifunctional Devices(MFD)</h4>
<h4 id="virtual-reality-head-mounted-displays-and-controllers">Virtual Reality Head-Mounted Displays and Controllers</h4>
<h4 id="drones">Drones</h4>
<h3 id="ergonomics">Ergonomics</h3>
<h2 id="chapter7-secondary-storage">Chapter7 Secondary Storage</h2>
<h3 id="storage">Storage</h3>
<ul>
<li>RAM is sometimes referred to as primary storage</li>
<li>characteristics of secondary storage
<ul>
<li>Media: physical material that holds the data and programes</li>
<li>Capacity: how much a device can hold</li>
<li>Storage devices: hardware that read data and programs from storage media. Often referred to as drives</li>
<li>Access speed</li>
</ul></li>
</ul>
<h3 id="solid-state-storage">Solid-State Storage</h3>
<ul>
<li>Provide access to flash memory, also known as solid-state storage</li>
</ul>
<h4 id="solid-state-drivesssds">Solid-State Drives(SSDs)</h4>
<ul>
<li>characters are represented by positive and negative charges using ASCII, EBCDIC, or Unicode binary codes.</li>
<li>Faster, durable and require little power</li>
</ul>
<h4 id="flash-memory-cards">Flash Memory Cards</h4>
<h4 id="usb-drives">USB Drives</h4>
<h3 id="hard-disks">Hard Disks</h3>
<ul>
<li>It rotates and have read/write heads that move in and out</li>
<li>Save files by altering the magnetic charges of the disks's surface to present 1s and 0s</li>
<li>Density refers to how tightly these charges can be packed next to one another on the disk</li>
<li>Platters are stacked one on top of another</li>
<li>Tracks are rings of concentric circles on the platter</li>
<li>Sectors refers to the sections a track is devided into</li>
<li>Cylinders differientes files stored on the same track</li>
</ul>
<h4 id="internal-hard-disks">Internal Hard Disks</h4>
<ul>
<li>Located inside the system unit</li>
</ul>
<h4 id="external-hard-disks">External Hard Disks</h4>
<h4 id="network-drives">Network Drives</h4>
<h4 id="performance-enhancements">Performance Enhancements</h4>
<ul>
<li>Disk caching: uses cache and anticipates data needs</li>
<li>Hybrid drives: contain both solid-state and hard disks</li>
<li>Redundant arrays of inexpensive disks(RAID)</li>
<li>File comparison and file decomparision: replace repeating patterns with a token, leaving enough tokens so that the original can are rebuilt or decompressed</li>
</ul>
<h3 id="optical-disks">Optical Disks</h3>
<p>The 1s and 0s are represented by flat areas called lands and bumpy areas called pits</p>
<ul>
<li>Compact discs: store 700MB; widely used for storing music</li>
<li>Digital versatile discs: DVD drives and CD drives are very similar; store 4.7GB</li>
<li>Blu-ray Discs</li>
</ul>
<p>Three types</p>
<ul>
<li>Read-only discs: cannot be written or erased by the user</li>
<li>Write-once(R for recordable) discs: can be written on once</li>
<li>Rewritable(RW for rewritable):</li>
</ul>
<h3 id="cloud-storage">Cloud Storage</h3>
<h3 id="mass-storage-devices">Mass Storage Devices</h3>
<h4 id="enterprise-storage-system">Enterprise Storage System</h4>
<h4 id="storage-area-network">Storage Area Network</h4>
<hr />
<h2 id="chapter8-communications-and-networks">Chapter8 Communications and Networks</h2>
<h3 id="communications-1">Communications</h3>
<ul>
<li>Texting</li>
<li>E-mail</li>
<li>Videoconferencing</li>
<li>Electronic commerce</li>
</ul>
<h4 id="connectivity">Connectivity</h4>
<p>Using computer network to link people and resources</p>
<h4 id="the-wireless-revolution">The Wireless Revolution</h4>
<h4 id="communication-systems">Communication Systems</h4>
<p>Electronic systems that transmit data from one location to another</p>
<p>Basic parts:</p>
<ul>
<li><p>Sending and receiving devices</p></li>
<li><p>Connection devices: act as an interface between the sending and receiving devices and the communication channel</p>
<p>They convert outgoing messages into packets that can travel across the communication channel</p></li>
<li><p>Data transmission specifications: <strong>rules and procedures</strong> that coordinate the sending and receiving devices</p></li>
<li><p>Communication channel: the <strong>actual connecting or transmission medium</strong> that carries the message. It can be physical wire or cable, or it can be wireless</p></li>
</ul>
<h3 id="communication-channels">Communication Channels</h3>
<p>Carry data from one computer to another</p>
<h4 id="wireless-connections">Wireless Connections</h4>
<p>Most use radio waves to communicate</p>
<ul>
<li><p>Cellular(蜂窝网络):uses multiple antennae(cell towers) to send and receive data within relatively small graphic regions(cells)</p></li>
<li><p>Bluetooth: short-range radio communication standard</p></li>
<li><p>Wi-Fi(Wireless fidelity): uses high-frequency radio signals;standard is 802.11a(g,n,ac,ax)</p></li>
<li><p>Microwave: sometimes referred to line-of-sight communication because it can only travel in a straight line; used in sending data between buildings in a city</p></li>
<li><p>WiMax(Worldwide Interoperability fir Microwave Access): extends the range of Wi-Fi networks using microwave connections.</p></li>
<li><p>Satellite: Intelsat(the International Telecommunications Satellite Consortium system):</p>
<p>Uplink is a term relating to sending data to the satellite</p>
<p>Global position system(GPS) uses satellite</p></li>
<li><p>Infrared: sending and receiving devices mustbe in a clear view of one another without any obstructions</p></li>
</ul>
<h4 id="physical-connections">Physical Connections</h4>
<ul>
<li>Twisted-pair cable: telephone lines or Ethernet cables</li>
<li>Coaxial cable</li>
<li>Fiber-optic cable</li>
</ul>
<h3 id="connection-device">Connection Device</h3>
<p>Telephone lines are designed to carry analog signals, while the coputer use digital signals, so you need to use modem to conver digital to analog</p>
<h4 id="modems">Modems</h4>
<ul>
<li>modem is a short for modulator-demodulator</li>
<li>Modulation means the process of converting from digital to analog</li>
<li>Transfer rate is measured in Mbps</li>
<li>Three types:
<ul>
<li>DSL(digital subscriber line): use standard phone lines</li>
<li>cable modem: use coaxial cable</li>
<li>wireless modem, or WWAN(wireless wide area network) modem: almost all hace built-in wireless modem</li>
</ul></li>
</ul>
<h4 id="connection-service">Connection Service</h4>
<ul>
<li>Copper lines, knwon as T1 lines,could be combined to formhigher-capacity options known as T3 or DS3 lines</li>
<li>The above lines have been replaced by faster optical carrier(OC) lines</li>
<li>Used to use dial-up service, but replaced
<ul>
<li>Cellular service providers</li>
<li>Digital subscriber line(DSL) services: use existing telephone lines; ADSL is one of the most widely used types</li>
<li>Cable service</li>
<li>Fiber-optic service(FiOS)</li>
<li>Satellite connection services</li>
</ul></li>
</ul>
<h3 id="data-transmission">Data Transmission</h3>
<h4 id="bandwidth">bandwidth</h4>
<p>The width or capacity of the communication channel</p>
<ul>
<li>Voiceband, or low bandwidth</li>
<li>Medium band: connect midrange computers and mainframes; capable of high-speed data transfer</li>
<li>Broadband: widely used for DSL, cable and satellite connection</li>
<li>Baseband</li>
</ul>
<h4 id="protocols">Protocols</h4>
<ul>
<li>https(hypertext transfer protocol secure)</li>
<li>TCP/IP(Transmission Control Protocol/Internet protocol): identifying sedning and receiving devices; breaking information into small parts or packets
<ul>
<li>Identification: use IP(Internet protocol) address; use DNS(domain name server) convert text-based addressto IP address</li>
<li>Packetization</li>
</ul></li>
</ul>
<h3 id="networks">Networks</h3>
<ul>
<li>Node</li>
<li>Client</li>
<li>Server</li>
<li>Directory server</li>
<li>Host</li>
<li>Router</li>
<li>Switch</li>
<li>Network interface cards</li>
<li>Network operating systems</li>
<li>Network administrator</li>
</ul>
<h3 id="network-types">Network Types</h3>
<h4 id="local-area-network">Local Area Network</h4>
<h4 id="home-network">Home Network</h4>
<h4 id="wireless-lan">Wireless LAN</h4>
<h4 id="personal-area-network">Personal Area Network</h4>
<h4 id="metropolitan-network">Metropolitan Network</h4>
<h4 id="wide-area-network">Wide Area Network</h4>
<h3 id="network-architecture">Network Architecture</h3>
<h4 id="topologies">Topologies</h4>
<ul>
<li>Bus network</li>
<li>Ring network</li>
<li>Star network</li>
<li>Tree network</li>
<li>Mesh network</li>
</ul>
<h4 id="strategies">Strategies</h4>
<ul>
<li>Client/server networks</li>
<li>Peer-to-peer (P2P) network</li>
</ul>
<h3 id="organizatioanl-networks">Organizatioanl Networks</h3>
<h4 id="internet-techonologies">Internet Techonologies</h4>
<ul>
<li>Intranet</li>
<li>Extranet: a private network that connects more than one organizations</li>
</ul>
<h4 id="network-security">Network Security</h4>
<ul>
<li>firewall: proxy server</li>
<li>Intrusion detection system(IDS)</li>
<li>Virtual private networks(VPN)</li>
</ul>
<hr />
<h2 id="chapter9-privacysecurity-and-ethics">Chapter9 Privacy,Security and Ethics</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>当代大学牲实录</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉领域简介</title>
    <url>/blog/posts/47952/</url>
    <content><![CDATA[<h2 id="references">References</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/33729052">春节囤货清单 | 15篇近期值得读的AI论文 - PaperWeekly的文章 - 知乎</a> <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/369671715">近期跨模态检测&amp;分割论文整理与解析（持续更新中） - 啪啪啪的文章 - 知乎</a> <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span><a href="https://www.zhihu.com/question/361928474/answer/949695859">language-vision领域有哪些值得推荐的论文？ - 知乎</a> <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1119486#undefined%5D">CVPR 2018 | UNC&amp;Adobe提出模块化注意力模型MAttNet，解决指示表达的理解问题</a> <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span>
</li>
</ol>
</div>
</section>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式简介和示例</title>
    <url>/blog/posts/3953/</url>
    <content><![CDATA[<h2 id="设计模式简介">设计模式简介</h2>
<h2 id="简介">简介</h2>
<figure>
<img src="/Users/guosurui/Documents/hexo/source/_posts/blob:https:/web.telegram.org/f966b061-7567-4a51-8674-7778715825cf" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="策略模式">策略模式</h3>
<h3 id="单例single模式">单例(Single)模式</h3>
<h3 id="适配器模式">适配器模式</h3>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>贰零贰贰</title>
    <url>/blog/posts/13932/</url>
    <content><![CDATA[<h2 id="一月一日">一月一日</h2>
<h3 id="关于西安">关于西安</h3>
<ul>
<li>封城的第不知道多少天</li>
</ul>
<h3 id="学业">学业</h3>
<ul>
<li>来不及复习了</li>
</ul>
<h3 id="视频">视频</h3>
<ul>
<li>拍摄加油视频</li>
</ul>
<h2 id="一月二日">一月二日</h2>
<h3 id="学业-1">学业</h3>
<ul>
<li>考了英语，凉了</li>
<li>高数还有救 大概</li>
</ul>
<h3 id="网络">网络</h3>
<ul>
<li>阿伟另一个作品 &gt; 【杰哥不要 阿瑋演員 性別平等教育宣導片 《有色狼！公共場所性騷擾》-哔哩哔哩】 https://b23.tv/tIFTWYY</li>
</ul>
<h3 id="日常">日常</h3>
<ul>
<li>兔子把易拉罐拉环拉掉了。。</li>
<li>张欣雨回家了</li>
</ul>
<h2 id="一月三日">一月三日</h2>
<h3 id="网络-1">网络</h3>
<ul>
<li>才浅新视频</li>
</ul>
<h3 id="日常-1">日常</h3>
<ul>
<li>大佬烫了个笛卡尔同款头</li>
</ul>
<h2 id="一月四日">一月四日</h2>
<h3 id="学业-2">学业</h3>
<ul>
<li>考高数</li>
<li>摆烂</li>
<li>又给自己加了一个管理学与领导艺术的选修课</li>
</ul>
<h3 id="网络-2">网络</h3>
<ul>
<li><p>一男子在南京景区穿印有「东京卍会」日漫服饰，被游客要求脱下</p>
<blockquote>
<p>如何看待一男子在南京景区穿印有「东京卍会」日漫服饰，被游客要求脱下？我们该如何更好地尊重历史？ - 知乎 https://www.zhihu.com/question/509781113</p>
</blockquote></li>
<li><p>中法俄英美发表「关于防止核战争与避免军备竞赛的联合声明」</p>
<blockquote>
<p>中法俄英美发表「关于防止核战争与避免军备竞赛的联合声明」，释放了什么信号？ - 知乎 https://www.zhihu.com/question/509711049</p>
</blockquote></li>
<li><p>影视飓风年终总结</p>
<blockquote>
<p>https://www.bilibili.com/video/BV1NR4y1G7TM?share_source=copy_web</p>
</blockquote></li>
</ul>
<h3 id="日常-2">日常</h3>
<ul>
<li>室友在收拾行李准备跑路</li>
</ul>
<h2 id="一月五日">一月五日</h2>
<h3 id="关于西安-1">关于西安</h3>
<ul>
<li>新增病例跌破一百</li>
</ul>
<h3 id="学业-3">学业</h3>
<ul>
<li>Java，寄</li>
<li>现场写链表基本操作</li>
</ul>
<h3 id="日常-3">日常</h3>
<ul>
<li>厦大三人组在思明会师&amp;拍视频</li>
<li>鼎楹联拿了第一</li>
</ul>
<h2 id="一月六日">一月六日</h2>
<h3 id="关于西安-2">关于西安</h3>
<ul>
<li>河南 危</li>
<li>一码通多少带点离谱</li>
</ul>
<h3 id="学业-4">学业</h3>
<ul>
<li>Java期末</li>
<li>写了一整个程序。。麻了</li>
<li>英语出来了 拉回来点儿</li>
</ul>
<h3 id="日常-4">日常</h3>
<ul>
<li>疯狂星期四</li>
<li>厦大三人组回家了</li>
</ul>
<h2 id="一月七日">一月七日</h2>
<h3 id="学业-5">学业</h3>
<ul>
<li>心理健康出成绩 还行</li>
</ul>
<h3 id="日常-5">日常</h3>
<ul>
<li>送椒椒回家</li>
<li>收拾一点行李</li>
</ul>
<h2 id="一月八日">一月八日</h2>
<h3 id="日常-6">日常</h3>
<ul>
<li>在宿舍装死</li>
</ul>
<h2 id="一月九日">一月九日</h2>
<h3 id="关于西安-3">关于西安</h3>
<ul>
<li>天津闹奥密克戎</li>
<li>XDU开学了</li>
</ul>
<h3 id="学业-6">学业</h3>
<ul>
<li>Java出成绩，87，平绩拉到3.53</li>
<li>Java实验时间出来了</li>
</ul>
<h3 id="视频-1">视频</h3>
<h3 id="音乐">音乐</h3>
<h3 id="网络-3">网络</h3>
<h3 id="日常-7">日常</h3>
<h2 id="一月x日">一月x日</h2>
<h3 id="关于西安-4">关于西安</h3>
<h3 id="学业-7">学业</h3>
<h3 id="视频-2">视频</h3>
<h3 id="音乐-1">音乐</h3>
<h3 id="网络-4">网络</h3>
<h3 id="日常-8">日常</h3>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>当代大学牲实录</tag>
      </tags>
  </entry>
  <entry>
    <title>近世代数初步</title>
    <url>/blog/posts/9252/</url>
    <content><![CDATA[<h2 id="基础知识">基础知识</h2>
<div class="note note-warning">
            <p>注意需要证明的对象或性质到底是针对哪个代数系统</br> 特别是涉及映射变换时</br> 需要证明哪个代数系统的性质，时刻记住在这个代数系统中取元素</br> 切忌由另一个代数系统去推理目标代数系统的性质</p>
          </div>
<h3 id="集合">集合</h3>
<h3 id="映射">映射</h3>
<blockquote>
<p>映射是对集合之间关系的描述</p>
</blockquote>
<h3 id="运算">运算</h3>
<h3 id="代数系统和运算律">代数系统和运算律</h3>
<h3 id="同态">同态</h3>
<blockquote>
<p>同态是对代数系统之间关系的描述，他要求集合之间满射；乘积的像等于像的乘积。</p>
</blockquote>
<h4 id="定义和性质">定义和性质</h4>
<p>对于两个集合<span class="math inline">\(A,{\bar{A} }\)</span>，其上分别定义了运算<span class="math inline">\({\circ},{\bar{\circ} }\)</span>，存在映射<span class="math inline">\({\Phi}:A{\rightarrow}{\bar{A} }\)</span>，如果总是有</p>
<p><span class="math display">\[
{\phi{(a{\circ}b)} }={ {\phi{a} }{\bar{\circ}{\phi{b} } } }
\]</span></p>
<p>则称<span class="math inline">\(\Phi\)</span>一个同态映射。</p>
<p>如果这个映射是满射，则称它为同态满射。</p>
<blockquote>
<p>我们一般会说对于代数运算<span class="math inline">\(\circ\)</span>和<span class="math inline">\(\bar{\circ}\)</span>，<span class="math inline">\(A\)</span>和<span class="math inline">\(\bar{A}\)</span>同态。</p>
</blockquote>
<p>同态对结合律和交换律具有保留性：</p>
<ol type="1">
<li>如果<span class="math inline">\(\circ\)</span>满足结合律，那么<span class="math inline">\(\bar{\circ}\)</span>也满足结合律</li>
<li>如果<span class="math inline">\(\circ\)</span>满足交换律，那么<span class="math inline">\(\bar{\circ}\)</span>也满足交换律</li>
</ol>
<p>对于定义了两个运算的代数系统，同态也能够保留分配律</p>
<div class="note note-warning">
            <p>同态的这两个性质只能从前者导出后者，反向不一定成立；同构是满足同是当且仅当的。</br> 这个性质差异主要是由同构满足双射导致的。</p>
          </div>
<p>对两个代数系统<span class="math inline">\(&lt;A,{\circ}&gt;\)</span>和<span class="math inline">\(&lt;{\bar{A} },{\bar{\circ} }&gt;\)</span>，<span class="math inline">\({\bar{e}{\in}{\bar{A} } }\)</span>是<span class="math inline">\({\bar{A} }\)</span>的单位元，如果满足</p>
<p><span class="math display">\[
f(a)=e,{\quad}{a{\in}A}
\]</span></p>
<p>则称<span class="math inline">\(f\)</span>是<span class="math inline">\(A\)</span>到<span class="math inline">\({\bar{A} }\)</span>的零同态。</p>
<h4 id="单同态和满同态">单同态和满同态</h4>
<p>如果两个代数系统之间同态，且</p>
<ul>
<li>映射<span class="math inline">\(f\)</span>为单射，称<span class="math inline">\(f\)</span>为单同态</li>
<li>映射<span class="math inline">\(f\)</span>为满射，称<span class="math inline">\(f\)</span>为满同态，称<span class="math inline">\(\bar{A}\)</span>是<span class="math inline">\(A\)</span>在<span class="math inline">\(f\)</span>下的同态像，记作<span class="math inline">\(A{\sim}{\bar{A} }\)</span></li>
<li>映射<span class="math inline">\(f\)</span>为双射，称<span class="math inline">\(f\)</span>为同构</li>
</ul>
<h3 id="同构">同构</h3>
<blockquote>
<p>在同态的基础上，同构还要求集合之间满足双射(一一映射)。</p>
</blockquote>
<h4 id="判定">判定</h4>
<p>两个代数系统的集合中元素个数不同时，显然也不构成同构。</p>
<p>如果两个代数系统的运算一个适合某运算律，另一个不适合，那么这两个代数系统必不可能是同构的。</p>
<blockquote>
<p>这个判定主要有前面性质是逆否命题推出。如果存在这个情况，与同构的性质相矛盾。</p>
</blockquote>
<h2 id="群">群</h2>
<h3 id="群的定义">群的定义</h3>
<p>下面的首先是群的第一定义</p>
<p>一个在<span class="math inline">\(G\)</span>上定义了一个映射<span class="math inline">\(\circ\)</span>的代数系统满足三个条件</p>
<ol type="1">
<li>具有封闭性 &gt; 说明<span class="math inline">\(\circ\)</span>是一个代数运算</li>
<li>满足结合律</li>
<li>对于任意<span class="math inline">\(a{\circ}x=b\)</span>和<span class="math inline">\(y{\circ}a=b\)</span>都有解 &gt; 不需要考虑唯一性，这个公理与群最早用来解高次方程有关</li>
</ol>
<p>可以被称为群，记作<span class="math inline">\((G,{\circ})\)</span>。<span class="math inline">\(\circ\)</span>也称为<span class="math inline">\(G\)</span>上的乘法；以上三条被称为群的三个公理。</p>
<p>比如代数系统<span class="math inline">\(({\mathbb{Z} }-\{0\},{\cdot})\)</span>不是一个群，因为不满足公理三；<span class="math inline">\(({\mathbb{Q} }-\{0\},{\cdot})\)</span>是一个群。</p>
<blockquote>
<p>比如对于方程<span class="math inline">\(2x=1\)</span>，第一个代数系统下是无解的。</p>
</blockquote>
<p>第二定义使用群的性质中的两个公理代替公理三</p>
<p>当群的集合是有限集时，群是有限群。否则是无限群。</p>
<p>如果群的运算额外满足交换律，该群被称为交换群（阿贝尔群）；否则是非交换群。</p>
<blockquote>
<p>若群满足<span class="math inline">\(x^2=e\)</span>，那么这个群是一个交换群。</p>
</blockquote>
<p><span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>进行若干次运算，被称为<span class="math inline">\(a\)</span>的<span class="math inline">\(n\)</span>次幂（n为正整数）</p>
<h4 id="有限群的群的第三定义">有限群的（群的第三）定义</h4>
<p>如果<span class="math inline">\(G\)</span>一个<strong>有限集</strong>，如果满足封闭性、结合律和消去律，那么他一定满足公理三，他和他定义的运算构成一个有限群。</p>
<h4 id="运算表的性质">运算表的性质</h4>
<h4 id="另一种详细的定义">另一种详细的定义</h4>
<ul>
<li>满足结合律的代数系统被称为半群，其运算常用<span class="math inline">\(\circ\)</span>表示，这个运算被称为乘法。</li>
<li>满足交换律的半群被称为可交换半群，其运算常用<span class="math inline">\(+\)</span>表示。</li>
<li>含有单位元的半群被称为幺半群，使用加法记号时单位元被称为零元；此时一定有半群的逆元，使用加法记号时被称为负元。</li>
<li>含有逆元的幺半群被称为群。</li>
<li>满足交换律的群被称为可交换群，或者阿贝尔群。</li>
</ul>
<h3 id="群的简单性质">群的简单性质</h3>
<p>群还有另外两个公理，首先是左、右单位元，这里放一个他们的证明</p>
<p><span class="math display">\[
\begin{array}{l}
假设有群(G,\cdot)，设其中元素a=b=c，\\
根据公理三，方程xc=c有解，设解为e,即有ec=c{\quad}(1) \\
方程cx=c=a，设解为d，即为cd=a{\quad}(2)\\
这样可以证明ea=e(cd)=(ec)d=cd=a
\end{array}
\]</span></p>
<p>另一个公理是左逆元的证明基于左单位元</p>
<p>进一步推出左逆元必定也是右逆元</p>
<p><span class="math display">\[
\begin{array}{l}
已知{a^{-1} }a=e，由公理三，y{a^{-1} }=e有解，设为a&#39;\\
那么a{a^{-1} }=e(a{a^{-1} })=(a&#39;{a^{-1} })a{a^{-1} }=a&#39;(a{a^{-1} })a^{-1}\\
=a&#39;ea^{-1}=a&#39;(ea^{-1})=a&#39;a^{-1}=e\\
由此可以证明a^{-1}既是a的左逆元也是a的右逆元
\end{array}
\]</span></p>
<p>最后还可以推出左单位元必定是右单位元</p>
<p><span class="math display">\[
ae=a(a^{ {-1} }a)=(a{a^{-1} })a=ea=a
\]</span></p>
<p>群的n次幂有两个基本性质</p>
<p><span class="math display">\[
\begin{array}{l}
a^{m+n}={a^m}{a^n}\\
(a^m)^n=a^{mn}
\end{array}
\]</span></p>
<p>当这是一个交换群时，还满足性质(m为正整数)</p>
<p><span class="math display">\[
(ab)^m={a^m}{b^m}
\]</span></p>
<blockquote>
<p>主要依靠交换律将a和b交换到一起进行合并</p>
</blockquote>
<h3 id="单位元逆元和幂等元">单位元、逆元和幂等元</h3>
<p>左单位元一定也是右单位元，被称为单位元。单位元存在且唯一；逆元同样具有唯一性。</p>
<p>如果<span class="math inline">\(ab=e\)</span>，那么ab互为逆元。</p>
<blockquote>
<p>如果<span class="math inline">\(a^2=e\)</span>，那么<span class="math inline">\(a^{-1}=a\)</span>，进而<span class="math inline">\(e^{-1}=e\)</span>。</p>
</blockquote>
<p>逆元具有这样一系列性质</p>
<p><span class="math display">\[
\begin{array}{l}
(a^{-1})^{-1}=a\\
({a_1}{a_2}{\dots}{a_n})^{-1}={(a_n)^{-1} }{(a_{n-1})^{-1} }{\dots}{(a_1)^{-1} }\\
(a^n)^{-1}=(a^{-1})^n
\end{array}
\]</span></p>
<p>对于n次幂，利用单位元和逆元上面的性质可以得到推广</p>
<p><span class="math display">\[
\begin{array}{l}
a^n=(a^{-1})^{-n},n为负数\\
a^0=e
\end{array}
\]</span></p>
<p>如果元<span class="math inline">\(a\)</span>满足<span class="math inline">\(a*a=a\)</span>，则称<span class="math inline">\(a\)</span>为幂等元。</p>
<blockquote>
<p>代数系统的单位元如果存在，那么他一定也是该代数系统的幂等元。</p>
</blockquote>
<h3 id="元的阶">元的阶</h3>
<p>使得<span class="math inline">\(a^m=e\)</span>成立时，正整数m为a的阶，记作<span class="math inline">\(|a|=m\)</span>或者<span class="math inline">\(o(a)\)</span>；若不存在，则<span class="math inline">\(|a|=\infty\)</span></p>
<blockquote>
<p>对阶的讨论是基于元素的，比如整数加群中0的阶为1，其他元素为无穷。</p>
</blockquote>
<p>如果<span class="math inline">\(|a|=k\)</span>且<span class="math inline">\(a^n=e\)</span>，那么<span class="math inline">\(k|n\)</span>。</p>
<p><span class="math display">\[
\begin{array}{l}
 设n=kq+r,0{\le}r{\lt}q\\
a^n=a^{kq+r}={(a^k)^q}{a^r}={e^q}{a^r}=a^r=e \\
所以r=0
\end{array}
\]</span></p>
<p>一个元的阶是1，<strong>当且仅当</strong>这个元就是单位元。</p>
<p>一个元的逆元是他自身，<strong>当且仅当</strong>它的自身是单位元或二阶元。</p>
<p>一个群中，阶为1的元只有一个（单位元）；阶为2的元个数不确定；阶大于2的元有偶数个，总是成对出现。</p>
<blockquote>
<p>所以一个有限群的阶由阶为2的元的个数决定。</p>
</blockquote>
<p>对任意元<span class="math inline">\(a\)</span>，有<span class="math inline">\(|a|=|a^{-1 }|\)</span></p>
<p>一个有限群里阶大于2的元一定有偶数个。</p>
<p>一个有限群的每一个元的阶都有限。</p>
<h3 id="消去律">消去律</h3>
<p>群的乘法一定适合消去律。</p>
<blockquote>
<p>也被称作群的公理3'</p>
</blockquote>
<p><span class="math display">\[
\begin{array}{l}
  ax=ax&#39; \\
  a^{-1}(ax)=a^{-1}ax&#39;\\
  (a^{-1}a)x=(a^{-1}a)x&#39;\\
  ex=ex&#39;\\
  x=x&#39;
\end{array}
\]</span></p>
<p>根据消去律，可以得知<span class="math inline">\(ax=b\)</span>和<span class="math inline">\(ya=b\)</span>各有唯一解。</p>
<p><span class="math display">\[
\begin{array}{l}
  假设有ax=b，设解为c\\
  ac=b\\
  ac&#39;=b\\
  所以ac=ac&#39;\\
  由消去律，c=c&#39;
\end{array}{l}
\]</span></p>
<h3 id="群的同态">群的同态</h3>
<blockquote>
<p>提供了一个快速判断代数系统是否为群的方法</p>
</blockquote>
<p>已知群<span class="math inline">\((G,{\circ})\)</span>是一个群，<span class="math inline">\((\bar{G},\bar{\circ})\)</span>是一个代数系统，如果<span class="math inline">\(G {\sim}\bar{G}\)</span>，那么<span class="math inline">\(\bar{G}\)</span>也是一个群。</p>
<p>这样得到的群<span class="math inline">\(\bar{G}\)</span>，<span class="math inline">\(\bar{G}\)</span>的单位元是<span class="math inline">\(G\)</span>的单位元的像；<span class="math inline">\(\bar{G}\)</span>的逆元是<span class="math inline">\(G\)</span>的逆元的像。</p>
<p>如果<span class="math inline">\(G{\cong}\bar{G}\)</span>，那么<span class="math inline">\(G\)</span>中元<span class="math inline">\(a\)</span>在<span class="math inline">\(\bar{G}\)</span>中对应元的阶相等。</p>
<h3 id="变换群">变换群</h3>
<p>集合上的所有一一变换与变换的复合运算构成群。</p>
<p>所有旋转、位似和平移都分别构成群。</p>
<p>集合上的若干一一变换对变换的乘法作成群，这样的群被称为变换群。</p>
<p>一个变换群的单位元一定是恒等变换。</p>
<h4 id="凯莱定理">凯莱定理</h4>
<p>任何一个群都同构于一个变换群</p>
<h3 id="置换群">置换群</h3>
<p>有限集上的一一变换叫做置换，同一集合上的若干置换构成的群叫做置换群。</p>
<blockquote>
<p>置换和变换的差异仅在于置换要求有限集，所以置换群是变换群的一种。</p>
</blockquote>
<p>包含<span class="math inline">\(n\)</span>个元素的集合上的<strong>全体置换</strong>作成的群叫做<span class="math inline">\(n\)</span>次对称群，记作<span class="math inline">\(S_n\)</span>。通常将其中元素记作</p>
<p><span class="math display">\[
\begin{pmatrix}
  1 &amp; 2 &amp; 3 &amp; {\dotsb} &amp; n \\
  {r_1} &amp; {r_2} &amp; {r_3} &amp; {\dotsb} &amp; {r_n}
\end{pmatrix}
\]</span></p>
<blockquote>
<p><span class="math inline">\(n\)</span>次对称群是同一集合上最大的置换群</p>
</blockquote>
<p>这些元素也可以使用<span class="math inline">\(({r_1}{r_2}{\dotsb}{r_n})\)</span>的形式简写，其中简写形式括号内有<span class="math inline">\(k\)</span>个数字时该元素被称为一个<span class="math inline">\(k-循环\)</span>，统称所有<span class="math inline">\(k-循环\)</span>为循环置换。</p>
<blockquote>
<p>二循环也被称为对换。</p>
</blockquote>
<p><span class="math inline">\(S_n\)</span>中有<span class="math inline">\(n!\)</span>个，记作<span class="math inline">\(S_n\)</span>的阶，即<span class="math inline">\(|S_n|=n!\)</span>。</p>
<blockquote>
<p>其实就是矩阵第二行的全排列。</p>
</blockquote>
<p>置换的乘法，特别是使用简写形式下，可以配合图形辅助运算。由于置换本就是特殊的变换，所以置换乘法和变换复合是一回事儿。</p>
<p>两个不相交的循环置换的乘积可交换。</p>
<h4 id="有限群的凯莱定理">有限群的凯莱定理</h4>
<p>任何一个<strong>有限群</strong>都同构于一个置换群</p>
<h4 id="奇偶置换">奇、偶置换</h4>
<p>任何一个<strong>置换</strong>可以表示为若干个不相交<strong>循环置换</strong>的乘积。</p>
<p>任何一个<strong>循环置换</strong>都可以写成若干个相连的<strong>对换</strong>的乘积。</p>
<p>上面的两个结论可以推出任何一个置换可以表示为若干个对换的乘积，即</p>
<p><span class="math display">\[
({r_1}{r_2}{\dotsb}{r_n})={({r_1}{r_k})}{({r_1}{r_{k-1} })}{\cdots}{({r_1}{r_2})}
\]</span></p>
<p>由此，所有可以使用偶数个对换乘积的置换称为偶置换，所有偶置换记作<span class="math inline">\(A_n\)</span>；否则称为奇置换。</p>
<p><span class="math inline">\(n{\lt}2\)</span>时，<span class="math inline">\(S_n\)</span>中奇、偶置换各占一半。</p>
<h4 id="置换群的逆元">置换群的逆元</h4>
<p>对一个循环置换来讲</p>
<ul>
<li>矩阵形式下，可以很直观的写出一个置换的逆元。</li>
<li>简写形式下，只需反序写循环；特别地，对换的逆元与它本身相等。</li>
</ul>
<h4 id="置换群的阶">置换群的阶</h4>
<p>k-循环的阶等于k</p>
<p>如果一个置换<span class="math inline">\(\sigma\)</span>可以表示为<span class="math inline">\(k\)</span>-循环和<span class="math inline">\(l\)</span>-循环的乘积，那么<span class="math inline">\(|\sigma|=lcm({k,l})\)</span>（最小公倍数）</p>
<h3 id="循环群">循环群</h3>
<blockquote>
<p>循环群的结构、分类要比其他群简单</p>
</blockquote>
<p>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a{\in}G\)</span>，对任意的<span class="math inline">\(b{\in}G\)</span>，总是有<span class="math inline">\(m{\in}\mathbb{Z}\)</span>满足<span class="math inline">\(b=a^m\)</span>，<span class="math inline">\(G\)</span>就是一个循环群，<span class="math inline">\(a\)</span>是这个循环群的生成元，记作<span class="math inline">\(G=(a)\)</span>。</p>
<p>一个循环群一定是交换群。</p>
<p>循环群的生成元可以不只有一个，比如说整数加群<span class="math inline">\((\mathbb{Z},+)\)</span>就是一个循环群，<span class="math inline">\(1\)</span>和<span class="math inline">\(-1\)</span>都是它的生成元。</p>
<p>显然单位元不可能作为生成元。</p>
<p><span class="math inline">\(A_n\)</span>关于变换的乘法作成群，这个群叫做<span class="math inline">\(n\)</span>次交错群。</p>
<blockquote>
<p>举个例子，<span class="math inline">\(A_3\)</span>体现正三角形的旋转对称性。</p>
</blockquote>
<h4 id="欧拉函数">欧拉函数</h4>
<p>欧拉函数<span class="math inline">\(\phi({n})\)</span>被定义为小于<span class="math inline">\(n\)</span>且与<span class="math inline">\(n\)</span>互素的非负整数的个数。</p>
<p>欧拉函数具有一些性质</p>
<ul>
<li>对质数<span class="math inline">\(n\)</span>来讲，<span class="math inline">\(\phi({n})=n-1\)</span></li>
</ul>
<h4 id="模n剩余类加群">模<span class="math inline">\(n\)</span>剩余类加群</h4>
<p>在<span class="math inline">\(\mathbb{Z}_n\)</span>上定义<span class="math inline">\({\forall}{[a]},{[b]{\in} }{\mathbb{Z}_n},{[a]}+{[b]}={[a+b]}\)</span>，则<span class="math inline">\(({\mathbb{Z}_n},+)\)</span>是一个循环群，这个群叫做模<span class="math inline">\(n\)</span>剩余类加群。</p>
<h4 id="循环群基本定理">循环群基本定理</h4>
<blockquote>
<p>任意给出一个循环群，可以使用两个基本的循环群大概描述它</p>
</blockquote>
<p>设<span class="math inline">\(G=(a)\)</span></p>
<ul>
<li><span class="math inline">\(|a|=\infty\)</span>时，<span class="math inline">\(G{\cong}(\mathbb{Z},+)\)</span></li>
<li><span class="math inline">\(|a|=n\)</span>时，<span class="math inline">\(G{\cong}(\mathbb{Z}_n,+)\)</span></li>
</ul>
<p>可以得到推论</p>
<ul>
<li><span class="math inline">\(|a|=\infty\)</span>时，<span class="math inline">\(G\)</span>恰有两个生成元<span class="math inline">\(a,a^{-1}\)</span></li>
<li><span class="math inline">\(|a|=n\)</span>时，<span class="math inline">\(G\)</span>至少有两个生成元<span class="math inline">\(a,a^{-1}\)</span>，分别对应<span class="math inline">\([1],[n-1]\)</span></li>
</ul>
<p>以及</p>
<ul>
<li><span class="math inline">\(|a|=\infty\)</span>时，则<span class="math inline">\(|G|=\infty\)</span></li>
<li><span class="math inline">\(|a|=n\)</span>时，则<span class="math inline">\(|G|=n\)</span></li>
</ul>
<p>对一个<span class="math inline">\(n\)</span>阶循环群<span class="math inline">\(G=(a)\)</span>，<span class="math inline">\(G\)</span>中有欧拉函数<span class="math inline">\(\phi(n)\)</span>个生成元。</p>
<h3 id="子群">子群</h3>
<p>简单定义不难理解，记<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的群为<span class="math inline">\(H{\le}G\)</span>。</p>
<p>单位元子群(<span class="math inline">\(\{e\}\)</span>)、群(<span class="math inline">\(G\)</span>)本身被称为群的平凡子群，每个群都会有这两个群；其它子群被称为真子群。</p>
<p>典型例子有</p>
<p><span class="math display">\[
{(\mathbb{Z},+)}{\le}{(\mathbb{Q},+)}{\le}{(\mathbb{R},+)}{\le}{(\mathbb{C},+)}
\]</span></p>
<p>同时具有性质<span class="math inline">\(e_H=e_G,a^{-1}_H=a^{-1}_G\)</span></p>
<p>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(S\)</span>是<span class="math inline">\(G\)</span>的一个非空子集，则</p>
<p><span class="math display">\[
(S)=\{a^mb^n{\cdots}c^k|a,b,{\cdots},c{\in}S,m,n,k{\in}\mathbb{Z}\}
\]</span></p>
<p>其中<span class="math inline">\(a^mb^n{\cdots}c^k\)</span>是有限个元的有限次幂的乘积，他是一个<span class="math inline">\(G\)</span>的子群，并且是包含<span class="math inline">\(S\)</span>的最小子群，成为<span class="math inline">\(S\)</span>的生成子群。</p>
<h4 id="子群的判定">子群的判定</h4>
<p>第一判定定理，<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的子群，当且仅当：</p>
<ul>
<li><span class="math inline">\({\forall}a,b{\in}H\)</span>，都有<span class="math inline">\(ab{\in}H\)</span></li>
<li><span class="math inline">\(a{\in}H\)</span>，有<span class="math inline">\(a^{-1}{\in}H\)</span></li>
</ul>
<p>第二判定定理，<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的子群，当且仅当：</p>
<ul>
<li><span class="math inline">\({\forall}a,b{\in}H\)</span>，总是有<span class="math inline">\(ab^{-1}{\in}H\)</span></li>
</ul>
<blockquote>
<p>通过控制<span class="math inline">\(a,b\)</span>的取值可以得到第一判定定理的两个条件。</p>
</blockquote>
<p>第三判定定理，<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的子群，当且仅当：</p>
<ul>
<li><span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的非空有限子集</li>
<li><span class="math inline">\({\forall}a,b{\in}H\)</span>，总是有<span class="math inline">\(ab{\in}H\)</span></li>
</ul>
<h2 id="环与域">环与域</h2>
<h3 id="环与域的基本内容">环与域的基本内容</h3>
<h4 id="环的定义和性质">环的定义和性质</h4>
<p>对集合<span class="math inline">\(R\)</span>，定义映射<span class="math inline">\(+,\cdot\)</span>，满足</p>
<ol type="1">
<li><span class="math inline">\((R,+)\)</span>是一个交换群（加群）</li>
<li><span class="math inline">\((R,\cdot)\)</span>具有封闭性、结合律</li>
<li>左右分配律</li>
</ol>
<p>称<span class="math inline">\(R\)</span>关于<span class="math inline">\(+.\cdot\)</span>作成一个环，记作<span class="math inline">\((R,+,\cdot)\)</span>。此时加群中的单位元改称零元，逆元改称复元，并定义简写“减法”；另一个群称呼不变。</p>
<p>为了区分环内的加群，对一些运算的形式进行了改变，比如 <span class="math inline">\(a^0\)</span>变更为<span class="math inline">\(0a\)</span>的形式，<span class="math inline">\(a^n\)</span>变更为<span class="math inline">\(na\)</span>的形式等等。</p>
<blockquote>
<p>这些改变并没有改变运算和性质，作用范围和条件也没有改变，主要是为了区分加群和乘法群。</p>
</blockquote>
<h4 id="更详细的分类">更详细的分类</h4>
<ul>
<li>对代数系统的<span class="math inline">\(&lt;{\mathbb{R} },+,{\times}&gt;\)</span>，如果<span class="math inline">\(&lt;{\mathbb{R},+}&gt;\)</span>是一个Abel群，<span class="math inline">\(&lt;{\mathbb{R},{\times} }&gt;\)</span>是一个半群，且满足左右分配律，这样的代数系统被称为环。</li>
<li>环<span class="math inline">\(R=\{0\}\)</span>被称为零环。</li>
</ul>
<blockquote>
<p><span class="math inline">\(&lt;{\mathbb{Z},+,{\cdot} }&gt;\)</span>是整数环，<span class="math inline">\(&lt;{\mathbb{Z(i)},+,{\cdot} }&gt;,{\mathbb{Z(i)}=\{a+bi|a,b{\in}{\mathbb{Z} }\} }\)</span>是高斯环，<span class="math inline">\(&lt;{\mathbb{(Z)_n} },+,{\cdot}&gt;\)</span>是矩阵环，<span class="math inline">\(&lt;{\mathbb{Z[x]} },+,{\cdot}&gt;\)</span>是多项式环，<span class="math inline">\(&lt;{\mathbb{Z_n} },{+_n},{ {\cdot}_n}&gt;\)</span>是模n剩余环。</p>
</blockquote>
<p>啊吧啊</p>
<ul>
<li>若环<span class="math inline">\(&lt;{\mathbb{R} },+,{\cdot}&gt;\)</span>中，<span class="math inline">\(&lt;{\mathbb{R},{\cdot} }&gt;\)</span>是一个幺半群，其单位元被称为环的单位元，用1表示，此时该环被称为由单位元/1的环。</li>
<li>对有1的环，如果<span class="math inline">\(&lt;{\mathbb{R},{\cdot} }&gt;\)</span>有逆元，该逆元也被称为环的逆元，用<span class="math inline">\(a^{-1}\)</span>表示。</li>
<li>有1的环的所有可逆元在乘法运算下构成群<span class="math inline">\(R^*\)</span>，被称为环的乘法群。</li>
<li>当<span class="math inline">\(&lt;{\mathbb{R},{\cdot} }&gt;\)</span>为可交换半群时，称这个环为可交换环。</li>
<li>有单位元、无零因子的交换环被称为整环。</li>
<li>对一个有1的环，令<span class="math inline">\({\hat{R} }=R-\{0\}\)</span>，如果<span class="math inline">\(&lt;{\hat{R} },{\cdot}&gt;\)</span>，是一个群则称<span class="math inline">\(R\)</span>为除环。</li>
<li>一个无零因子的有限环，其模大于2，该环是一个除环。</li>
<li>可交换的除环被称为域。</li>
<li>有限整环必为域。</li>
</ul>
<h4 id="域的定义和性质">域的定义和性质</h4>
<blockquote>
<p>域是“最好的环”</p>
</blockquote>
<p>所有非零元关于乘法能作成交换群的环，被称为域。</p>
<blockquote>
<p>我们常常提到的实数域、复数域就和有理数环进一步定义得到的有理数域一样，就是这里所说的“域”。</p>
</blockquote>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>离散数学</tag>
        <tag>近世代数</tag>
      </tags>
  </entry>
  <entry>
    <title>重整Windows10——再见win11</title>
    <url>/blog/posts/3097/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<h2 id="受够你了win11">受够你了，Win11</h2>
<p>该死</p>
<p>为什么你总是出现各种各样的bug</p>
<p>烦了</p>
<p>不想写</p>
<h2 id="受够你了软件管理">受够你了，软件管理</h2>
<p>乱七八糟</p>
<p>烦死了</p>
<p><strong>总之就是想要个干净的操作系统</strong></p>
<h1 id="复盘">复盘</h1>
<h2 id="软件列表">软件列表</h2>
<p>软件还是挺多的，这里简单分个类，考虑一下解决方案</p>
<h3 id="音视频处理">音视频处理</h3>
<h4 id="adobe全家桶">Adobe全家桶</h4>
<p>这个没办法了，还是用@vposy大佬的破解版本即可</p>
<h4 id="davinci-resolve">Davinci Resolve</h4>
<p>必装</p>
<h4 id="melodyne">Melodyne</h4>
<p>melodyne还是会用到的，有必要装一下</p>
<h4 id="obs">OBS</h4>
<h4 id="studio-onecubase">Studio One/Cubase</h4>
<p>没想好整哪个。。</p>
<h4 id="riffstation">Riffstation</h4>
<p>还听哈用的</p>
<h4 id="剪映">剪映</h4>
<h4 id="audionodes">AudioNodes</h4>
<p>一个模块化的DAW</p>
<p>https://www.audionodes.com</p>
<h4 id="music-brainz-picard">Music Brainz Picard</h4>
<p>一个mp3元数据标签编辑工具</p>
<p>https://picard.musicbrainz.org</p>
<h4 id="handbrake">HandBrake</h4>
<p>一个拥有良好界面的高性能视频编码和转换工具</p>
<p>https://handbrake.fr</p>
<h3 id="文件阅读和处理">文件阅读和处理</h3>
<h4 id="操作系统激活">操作系统激活</h4>
<p>使用这个工具</p>
<p>https://github.com/TGSAN/CMWTAT_Digital_Edition</p>
<h4 id="office">Office</h4>
<p>使用这位朋友提供的工具</p>
<p>https://github.com/YerongAI/Office-Tool</p>
<p>https://www.coolhub.top/archives/42</p>
<h4 id="pdf查看和编辑">PDF查看和编辑</h4>
<h4 id="wps">WPS</h4>
<p>试着找一下破解版</p>
<p>应该有国际版</p>
<h4 id="guitar-pro">Guitar Pro</h4>
<p>找一下新版的破解吧</p>
<h4 id="potplayer">Potplayer</h4>
<p>老牌免费播放器</p>
<p>https://potplayer.daum.net</p>
<h4 id="blendeer">Blendeer</h4>
<p>开源的3D设计工具</p>
<p>https://www.blender.org</p>
<h3 id="运行环境驱动程序和管理软件">运行环境、驱动程序和管理软件</h3>
<h4 id="amd-radeon-software">AMD Radeon Software</h4>
<h4 id="intel的驱动">Intel的驱动</h4>
<h4 id="nvdia-control-panel">Nvdia Control Panel</h4>
<p>记得装Studio版本的驱动</p>
<h4 id="联想提供的驱动包">联想提供的驱动包</h4>
<h4 id="net环境">.Net环境</h4>
<h4 id="vc运行库">vc运行库</h4>
<p>使用vcpkg进行管理</p>
<p>https://github.com/microsoft/vcpkg/blob/master/README_zh_CN.md</p>
<h3 id="开发">开发</h3>
<h4 id="git">Git</h4>
<p>用windows的包管理试一试</p>
<h4 id="jetbrains全家">Jetbrains全家</h4>
<h4 id="jdk">JDK</h4>
<h4 id="visual-studio">Visual Studio</h4>
<p>宇宙第一IDE</p>
<h4 id="vscode及各种配置">VSCode及各种配置</h4>
<h4 id="matlab">Matlab</h4>
<p>都装上吧。。</p>
<h4 id="unity">Unity</h4>
<h4 id="wsl">WSL</h4>
<p>配置好WSL</p>
<h4 id="windows-terminalzsh">Windows Terminal&amp;Zsh</h4>
<h4 id="包管理">包管理</h4>
<p>考虑下面三个</p>
<ul>
<li>winget：微软自家的包管理工具</li>
<li>scoop：蛮火的</li>
<li>choco</li>
</ul>
<h4 id="sandbox">sandBox</h4>
<p>windows自带的沙盒</p>
<h4 id="hyper">hyper</h4>
<p>开源终端</p>
<p>https://hyper.is</p>
<h3 id="小工具">小工具</h3>
<h4 id="背景更换工具">背景更换工具</h4>
<p>https://github.com/Krutonium/Windows-10-Login-Background-Changer</p>
<h4 id="easyconnect">EasyConnect</h4>
<p>不但要装还要<strong>配置一下学校的VPN</strong></p>
<h4 id="everything">Everything</h4>
<p>经典</p>
<h4 id="zip">7-Zip</h4>
<p>https://www.7-zip.org</p>
<h4 id="x-rite-color">X-rite color</h4>
<h4 id="坚果云">坚果云</h4>
<p>真的很好用</p>
<h4 id="百度网盘">百度网盘</h4>
<p>真的很难用</p>
<h4 id="translucenttb">TranslucentTB</h4>
<p>一个任务栏透明小工具</p>
<p>https://github.com/TranslucentTB/TranslucentTB</p>
<h4 id="quicklook">QuickLook</h4>
<p>神器好吧</p>
<p>也是被macOS惯坏了</p>
<p>但预览真的很重要不是吗！</p>
<p>https://github.com/QL-Win/QuickLook</p>
<h4 id="wox">Wox</h4>
<p>新一代文件定位工具，堪称 Windows 上的 Alfred</p>
<h4 id="snipaste">Snipaste</h4>
<p>可取代QQ/微信的强大截图工具，还能把截图当便利贴用</p>
<h4 id="nvdia-rtx-voice">Nvdia RTX Voice</h4>
<p>NV提供的AI降噪工具</p>
<p>https://www.nvidia.com/en-us/geforce/guides/nvidia-rtx-voice-setup-guide/</p>
<h4 id="powertoys">PowerToys</h4>
<p>微软自家的增强工具</p>
<p>https://github.com/microsoft/PowerToys</p>
<h4 id="typora">Typora</h4>
<p>找个破解版</p>
<h4 id="openhashtab">OpenHashTab</h4>
<p>右键查看Hash、MD5等</p>
<p>https://github.com/namazso/OpenHashTab</p>
<h4 id="autohotkey">AutoHotKey</h4>
<p>开源的脚本语言</p>
<p>https://www.autohotkey.com</p>
<h3 id="娱乐">娱乐</h3>
<h4 id="steam">Steam</h4>
<p>Steam永远不会缺席</p>
<p>顺便试一下这个小东西</p>
<p>https://github.com/BeyondDimension/SteamTools</p>
<h4 id="epic-game">Epic Game</h4>
<p>其实是为了启动虚幻引擎</p>
<h4 id="origin">Origin</h4>
<h4 id="yuzu">Yuzu</h4>
<p>一个Switch模拟器</p>
<h4 id="dopamine">Dopamine</h4>
<p>一个音频播放器</p>
<p>http://www.digimezzo.com/software/dopamine/</p>
<h2 id="文件的备份">文件的备份</h2>
<p>有哪些需要备份的数据呢。。</p>
<h3 id="色彩配置文件">色彩配置文件</h3>
<h1 id="思路">思路</h1>
<blockquote>
<p>多多尝试包管理</p>
<p>多多尝试开源工具</p>
</blockquote>
<h2 id="系统优化">系统优化</h2>
<h3 id="关掉他妈的自动更新">关掉他妈的自动更新</h3>
<blockquote>
<p>参考资料</p>
<p>https://zhuanlan.zhihu.com/p/38070514</p>
<p>https://os.51cto.com/article/661443.html</p>
</blockquote>
<h3 id="补驱动">补驱动</h3>
<p>先用联想自己的搞一搞</p>
<p>然后Nv、AMD</p>
<h3 id="解压缩工具开启wsl和terminal包管理">解压缩工具、开启WSL和Terminal、包管理</h3>
<p>解压缩先用7-zip吧</p>
<p>WSL单独开一个文章讲</p>
<p>Terminal得先搞一下</p>
<p>搞完Terminal搞包管理，最后整WSL</p>
<h3 id="安装各种运行库">安装各种运行库</h3>
<p>先用vcpkg</p>
<p>其他的VS基本都会补上去</p>
<h2 id="开发环境">开发环境</h2>
<h3 id="java环境">Java环境</h3>
<h3 id="python环境">python环境</h3>
<h2 id="开发工具的配置">开发工具的配置</h2>
<h2 id="专业应用的安装和管理">专业应用的安装和管理</h2>
<h2 id="运行环境的管理">运行环境的管理</h2>
<h2 id="小工具-1">小工具</h2>
<h1 id="过程记录">过程记录</h1>
<h2 id="前期准备">前期准备</h2>
<p>其实前期准备没什么可说的了，上面的内容就是前期准备</p>
<p>非要说的话也有一些</p>
<h3 id="准备pe和镜像">准备PE和镜像</h3>
<p>很奇怪啊现在的人都不用PE了，但我还是爱微PE</p>
<h3 id="清理数据">清理数据</h3>
<p>先不动启动分区和恢复分区了</p>
<p>主分区格式化一下</p>
<p>数据盘删点东西</p>
<h3 id="安装">安装</h3>
<p>说实话好久没有安装过了，这里使用WinNTSetup来安装</p>
<p>驱动器位置也就是格式为FAT32的小分区，一般也就是256M</p>
<p>出现一个尴尬点的问题，忘了windows10版本怎么分了，这里摘录一下</p>
<p>先来几个图</p>
<figure>
<img src="https://pica.zhimg.com/80/941c41be5cb441d5f1aedf5ccc469168_1440w.jpg?source=1940ef5c" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>微软官网的比较</p>
<p>https://www.microsoft.com/zh-cn/windowsforbusiness/compare</p>
<p>最后还是来个最牛逼的吧</p>
<p>然后直接安装就可以了</p>
<h2 id="系统的基本优化">系统的基本优化</h2>
<p>安装的时候依旧登录了微软账号，桌面和浏览器记录都得到了保存。我们来顺便看一眼目最干净的目录结构</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- C:
	|-- PerfLogs
	|-- Program Files
	|-- Program Files(x86)
	|-- Windows
	|-- Users</code></pre></div>
<p>简单删除一下，目前的软件列表如下（不说明的就是不可移除），共21个</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- HEIF图像拓展
|-- Microsoft Edge
|-- Microsoft Edge Update
|-- Microsoft Store
|-- NVDIA Control Panel（可移除）
|-- NVDIA图形驱动程序466.81.1（可移除）
|-- Realtek Audio Console（可移除）
|-- Web媒体扩展（可移除）
|-- Webp图像扩展
|-- Xbox（可移除）
|-- Xbox Game Bar（可移除）
|-- Xbox Live（可移除）
|-- 获取帮助
|-- 计算器（可移除）
|-- 截图和草图（可移除）
|-- 录音机（可移除）
|-- 闹钟和时钟
|-- 人脉
|-- 相机
|-- 应用安装程序
|-- 照片</code></pre></div>
<p>现在有哪些问题捏</p>
<ul>
<li>登录界面背景图片</li>
<li>任务栏美化</li>
<li>桌面图标美化</li>
<li>系统还没有激活</li>
<li>一些基本的设置</li>
<li>没有关闭更新</li>
</ul>
<h3 id="先进行一个激活和更新的关闭">先进行一个激活和更新的关闭</h3>
<p>用奶牛快传真方便</p>
<p>使用自动模式激活<code>ProfessionalWorkstation</code>版本，几秒钟之后激活成功</p>
<p>接下来再看一眼应用列表和文件夹，嗯，很好，没什么变化</p>
<p>试着将它移除后重启，看看激活会不会掉</p>
<p>nice，一点儿事都没有，看来是永久激活了</p>
<p>然后<code>win+R</code>运行<code>services.msc</code>打开服务，找到<code>Windows Update</code>，停止顺便禁用掉</p>
<p>然后进一下组策略，运行<code>gpedit.msc</code>，<code>计算机配置-管理模板-Windows更新-配置自动更新</code>，进行一个禁用</p>
<p>上面的操作属于是双重保险了，应该没啥问题</p>
<p>重启看一眼，提示“某些设置由你的组织来管理”，OK</p>
<h3 id="安装一下7-zip">安装一下7-zip</h3>
<p>差点把他忘了。。</p>
<p>直接官网开冲，安装在<code>C:\Program Files\7-Zip</code>里，然后应用列表里会出现一条<code>7-Zip 21.07(x64)</code>，截至目前共有22个应用</p>
<h3 id="梯子">梯子</h3>
<p>Clash安放在<code>C:\Program Files\Clash</code>里，启动一下订阅，安装Service Mode，开启系统代理和自启动</p>
<h3 id="进行一梭子驱动的补">进行一梭子驱动的补</h3>
<p>联想驱动管理安装在<code>C:\Program Files(x86)\Lenovo Driveers Management</code>，完事儿进行一套驱动的安装，最后把他干掉</p>
<p>安装一下联想电脑管家，路径在<code>C:\Program Files(x86)\Lenovo\</code>，启动开盖开机，关闭其他自启动和提示</p>
<p>此时多出以下三个应用（25），更新一个版本</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- NVDIA HD 音频驱动程序1.3.38.60
|-- NVDIA PhysX 系统软件9.21.0713
|-- 联想电脑管家
|-- NVDIA图形驱动程序466.81.1 &#x3D;&gt; 472.56</code></pre></div>
<p>NVDIA驱动安装在<code>C:\Program Files\NVDIA\</code>，安装会增加三项（28），以及两个VC运行库（30）</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- NVDIA FrameView SDK
|-- NVDIA GeForce Experience
|-- NVDIA USBC Driver
|-- VC++ 2015-2019 Redistributable(x64) 14.22.27821
|-- VC++ 2015-2019 Redistributable(x86) 14.22.27821</code></pre></div>
<blockquote>
<p>NV的驱动套装一共有五项，分别是</p>
<ul>
<li>NVDIA HD音频驱动程序</li>
<li>NVDIA PhysX</li>
<li>NVDIA USBC Driver</li>
<li>NVDIA图形驱动程序</li>
<li>NVDIA Geforce Experience</li>
</ul>
</blockquote>
<p>AMD芯片组驱动安装到<code>C:\AMD</code>下，自解压安装，添加一项<code>AMD Chipset Software</code>（31）</p>
<p>截至目前，系统目录还很干净，但发现另一个问题</p>
<ul>
<li>商店不可用</li>
</ul>
<h3 id="修复win10商店0x8013-1500">修复win10商店0x8013 1500</h3>
<ol type="1">
<li><p>运行<code>inetcpl.cpl</code>，高级- 使用TLS1.2</p>
<p>寄了</p></li>
<li><p>相同页面恢复高级设置</p></li>
<li><p>相同页面重置</p></li>
</ol>
<h3 id="安装配置windows-terminal">安装配置Windows Terminal</h3>
<p>直接在微软商店安装<code>Terminal(Pre)</code>顺便安装<code>Windows Package Manager Source(winget)</code>（33）</p>
<h3 id="安装wsl">安装WSL</h3>
<p>运行<code>WSL --install</code>安装最新的Ubuntu发行版，配置用户名和密码，安装以下应用（37）</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- Windows Subsystem for Linux Update
|-- Ubuntu
|-- Microsoft Windows Desktop Runtime - 3.1.22(x64)
|-- Microsoft Windows Desktop Runtime - 6.0.2(x64)</code></pre></div>
<h3 id="安装devtoys和powertoys">安装Devtoys和Powertoys</h3>
<p>前往GitHub安装即可，增加<code>DevToys</code>和<code>PowerToys(Preview)</code>（39）</p>
<blockquote>
<p>不知为何出现了一项<code>Microsoft Edge WebView2 Runtime</code>和<code>Xbox Live</code>（40）</p>
</blockquote>
<p>这一段就先这样吧，优化和美化回头再说，眼看着运行库越来越多了，先打个包</p>
<h3 id="安装和配置git">安装和配置Git</h3>
<p>前往Git-scm下载安装在<code>C:\Program Files\Git</code>，应用添加一行<code>Git</code>（41）</p>
<p>运行<code>git config --global user.name "name"</code>和<code>git config --global user.email email_address</code></p>
<p>生成一下SSHKey，运行<code>ssh-keygen -t rsa -b 4096 -C "email_address"</code></p>
<p>生成的key将会被保存在<code>~/.ssh/id_rsa.pub</code>中</p>
<h3 id="vc运行库-1">VC++运行库</h3>
<p>前往官网下载安装<code>VC_redist.x64</code></p>
<p>应该会补全了。。回头Steam再补一次</p>
<h3 id="windows-sandbox">Windows Sandbox</h3>
<p>微软官方文档</p>
<p>https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-sandbox/windows-sandbox-overview</p>
<p>搜索启用或关闭Windows功能，勾选Windows沙盒，等待安装完成后重启。沙盒不会作为应用程序出现在应用列表里</p>
<h3 id="安装scoop和chocolatey">安装scoop和chocolatey</h3>
<p>https://scoop.sh</p>
<p>安装scoop时，需要先添加环境变量<code>C:\Users\&lt;account&gt;\scoop\shims</code></p>
<p>先运行<code>scoop install openssh</code>安装ssh，再添加几个源</p>
<div class="code-wrapper"><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">scoop bucket add extras
scoop bucket add versions</code></pre></div>
<h2 id="常用软件的安装">常用软件的安装</h2>
<p>目前为止算是可以放心用了</p>
<h3 id="尝试用winget管理一些软件">尝试用winget管理一些软件</h3>
<p>安装一梭子软件(54)</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">|-- TIM
|-- WeChat
|-- OBS Studio
|-- QuickLook
|-- Wox
|-- AutoHotKey
|-- OpenHashTab
|-- PotPlayer
|-- MusicBrainz Picard
|-- HandBrake
|-- Nutstore
|-- Dopamine
|-- 百度网盘</code></pre></div>
<h2 id="开发-1">开发</h2>
<h3 id="visual-studio-1">Visual Studio</h3>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>Windows</tag>
        <tag>开源</tag>
      </tags>
  </entry>
</search>
