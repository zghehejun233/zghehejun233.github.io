---
title: C/C++入门学习笔记
description: 主要参考教材为机械工业出版社《程序设计教程》
categories: 编程
tags:
  - C
  - C++
abbrlink: 5078
banner_img: /post_img/C.jpg
index_img: /post_img/C.jpg
---

# 基础知识

## 关于二进制

### 存储和转换

#### 十进制整数

- 逐个与2相除，得到的余数依次组成一串数字，最后进行反转即可得到对应的二进制数

#### 十进制小数

- 逐次与2相乘，得到的个位数组成一串数字，并且每次个位不为零时都抹去个位数进入下次操作

### 原码、反码和补码

1. 原码即数字的原形式
2. 将原码逐位取反，即得到对应的反码
3. 反码+1得到的就是补码

> 求得反码时，$0$会出现$+0$和$-0$两种表达，因此引入了补码

## C的编码风格

### 匈牙利命名法

- 以一个或多个小写字母开头，指定数据类型

- 后跟一个或多个首字母大写的单词，描绘变量的功能

  > 可以视作对驼峰命名法的强化数据类型的命名方法

### Google标准

> <https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/>

### 定义和声明

- 定义性声明称为定义
- 非定义性声明称为声明

## 结构化程序设计

- 单入口和单出口
- 原来，面向过程就是结构化程序设计

## C++的简单示例

```c++
#include<iostream>

using namespace std;

int main()
{
cout << "Hello World" << endl
return 0;
}
```

- `#include<name>`与`import`的作用类似，可以近似理解为对文件的引用或调用
- C++一般使用流来进行输入输出，比如`cout << "Hello World" << endl`，而C一般会使用printf和scanf来实现基本输入输出

## C一家人

### C++

C++在C的基础上，添加类代表的面向对象语言；C++模板添加了泛型编程

早期的C++编译器将C++代码转译为C代码，再由C编译器编译。这个编译器也就是下面要提到的前端（CFront）

# 编译与环境配置

## 简述

### GNU、GCC、CLang和CMake都是些啥

> 参考资料
>
> <https://developer.51cto.com/article/630677.html>

#### 编译器的一般构成

传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)

在编译过程中，**前端主要负责词法和语法分析**，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。

#### GCC（GNU Compiler Collection）

GCC是一套GNU开发的**编译器**

GCC 作为一款开源的编译器，一直做得不错，但 Apple 逼事儿比较多，对编译工具会提出更高的要求。原因主要有以下两点

- GCC对Objective-C的支持慢。Apple 对 Objective-C 语言（包括后来对C语言）新增很多特性，但 GCC 开发者并不买Apple的账——不给实现，因此索性后来两者分成两条分支分别开发，这也造成 Apple 的编译器版本远落后于 GCC 的官方版本
- GCC代码质量差。GCC 的代码**耦合度太高**，很难独立，而且越是后期的版本，代码质量越差，但 Apple 想做的很多功能（比如更好的 IDE 支持），需要模块化的方式来调用 GCC，但 GCC一直不给做。

#### LLVM (Low Level Virtual Machine，底层虚拟机)

LLVM提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种编译器的**后台**来使用

#### Clang—LLVM2.0

Clang的诞生和Apple息息相关，准确的说，和巨佬Chiris Lattner相关。

> 2000年，本科毕业的 Chris Lattner 像中国多数大学生一样，按部就班地考了GRE，最终前往UIUC（伊利诺伊大学厄巴纳香槟分校），开始了艰苦读计算机硕士和博士的生涯。
>
> 在这阶段，他不仅周游美国各大景点，更是翻烂了《Compilers: Principles, Techniques, and Tools》，成了GPA满分(4.0) 牛人，并不断地研究探索关于编译器的未知领域，发表了一篇又一篇的论文。

他在求学阶段一个值得讨论的故事，是在**硕士毕业论文**里提出了一套完整的在编译时、链接时、运行时甚至是在闲置时优化程序的编译思想，直**接奠定了LLVM 的基础**。

LLVM 在他念博士时更加成熟，使用GCC 作为前端来对用户程序进行语义分析产生IF（Intermidiate Format），然后 LLVM 使用分析结果完成代码优化和生成。

后来，Chirs Lattner被Apple吸收，在Apple，他干了这些事情

- 优化OpenGL

  > Chris Lattner把 LLVM运行时的编译架在 OpenGL 栈上，这样OpenGL 栈能够产出更高效率的图形代码。
  >
  > 如果显卡足够高级，这些代码会直接扔入GPU 执行。但对于一些不支持全部OpenGL特性的显卡（比如当时的Intel GMA卡），LLVM 则能够把这些指令优化成高效的 CPU指令，使程序依然能够正常运行

- Apple1代码链接优化

  > LLVM的链接优化被直接加入到 Apple 的代码链接器上，而 LLVM-GCC也被同步到使用 GCC4.0 代码。

- 开发Clang

Clang也就是文章这一部分的重头戏，它是LLVM的前端。相比GCC，只支持C/C++/Objective-C三种语言。

与GCC相比，Clang有如下主要的特点

- 高性能：Clang在编译速度、空间占用上都优于GCC

  > 速度快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 比 GCC 快2倍多。
  >
  > 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10 倍。

- 高可用性：Clang有更好的错误提示信息，还支持GCC不具有的静态分析

  > Clang显示的错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有~~~~~和^的提示，相比之下 GCC 的提示很天书。

- 高兼容性：可以说GCC最初就被设计为一个单独的应用程序，而Clang1有更好的可移植性。Clang与GCC相比更像是一个插件，任何IDE都可以考虑将他设计进去

  > Clang 从一开始就被设计为一个API，允许它被源代码分析工具和 IDE 集成。GCC 被构建成一个单一的静态编译器，这使得它非常难以被作为 API 并集成到其他工具中。

- 平台的局限：Clang的诞生和Apple高度绑定，而且GCC还支持Fortran等语言

与此同时，二者的许可证也有区别。Clang使用BSD许可证，GCC则使用GPL许可证

![详解三大编译器：gcc、llvm 和 clang](https://s3.51cto.com/oss/202011/03/8a147a8adcb105088554299a2afecb87.jpg)

#### 总结

对新的项目而言，LLVM-GCC 看起來应该是个安全的选择，苹果公司认为它够稳定够成熟，所以才把它当做Xcode 4的预设选项。而且，既然选项使用的是GCC parser，向后兼容性应该没问题。

回顾GCC的历史，虽然它取得了巨大的成功，但**开发GCC的初衷是提供一款免费的开源编译器**，仅此而已。可后来随着GCC支持了越来越多的语言，GCC架构的问题也逐渐暴露出来。

**但GCC到底有什么问题呢？**

LLVM的优点也正是GCC的缺点。

传统编译器工作的时候过程一般如下

1. 前端负责**解析源代码，检查语法错误，并将其翻译为抽象的语法树（Abstract Syntax Tree）**。

2. 优化器对这一中间代码进行**优化，试图使代码更高效**。

3. 后端则负责将优化器优化后的**中间代码转换为目标机器的代码**，这一过程后端会最大化的利用目标机器的特殊指令，以提高代码的性能。

   >  事实上，不光静态语言如此，动态语言也符合上面这个模型，例如Java。JVM也利用上面这个模型，将Java代码翻译为Java bytecode。

这一模型的好处有

- **当我们要支持多种语言时，只需要添加多个前端就可以了**。当需要支持多种目标机器时，只需要添加**多个后端就可以**了。对于中间的优化器，我们可以使用通用的中间代码。

- **开发前端的人只需要知道如何将源代码转换为优化器能够理解的中间代码**就可以了，他不需要知道优化器的工作原理，也不需要了解目标机器的知识。这大大降低了编译器的开发难度，使更多的开发人员可以参与进来。

**虽然这种三段式的编译器有很多优点，并且被写到了教科书上，但是在实际中这一结构却从来没有被完美实现过。**

做的比较好的应该属Java和.NET虚拟机。虚拟机可以将目标语言翻译为bytecode，所以理论上讲我们可以将任何语言翻译为bytecode，然后输入虚拟机中运行。但是这一动态语言的模型并不太适合C语言，所以硬将C语言翻译为bytecode并实现垃圾回收机制的效率是非常低的。GCC也将三段式做的比较好，并且实现了很多前端，支持了很多语言。但是上述这些编译器的致命缺陷是，**他们是一个完整的可执行文件，没有给其它语言的开发者提供代码重用的接口**。即使GCC是开源的，但是源代码重用的难度也比较大。

LLVM最初的定位是比较底层的虚拟机。它的出现正是为了解决**编译器代码重用的问题**，LLVM一上来就站在比较高的角度，制定了LLVM IR这一中间代码表示语言。LLVM IR充分考虑了各种应用场景，例如在IDE中调用LLVM进行实时的代码语法检查，对静态语言、动态语言的编译、优化等。从上面这个图中我们发现LLVM与GCC在三段式架构上并没有本质区别。

LLVM与其它编译器最大的差别是，**它不仅仅是Compiler Collection，也是Libraries Collection**。

> 举个例子，假如说我要写一个X语言的优化器，我自己实现了PassX算法，用以处理X语言与其它语言差别最大的地方。而LLVM优化器提供的PassA和PassB算法则提供了X语言与其它语言共性的优化算法。那么我可以选择X优化器在链接的时候把LLVM提供的算法链接进来。

LLVM不仅仅是编译器，**也是一个SDK**。

Apple LLVM compiler 4.2是一个真正的LLVM编译器，前端使用的是Clang，基于最新的LLVM 3.2编译的。LLVM GCC 4.2编译器的核心仍然是LLVM，但是前端使用的是GCC 4.2编译器。从LLVM的下载页面可以看出，LLVM从1.0到2.5使用的都是GCC作为前端，直到2.6开始才提供了Clang前端。

如果你下载 LLVM 的代码，那么它就是一个IR到ARM/机器码的编译器。比如bin/opt就是对IR的优化器，bin/llc就是IR->ASM的翻译，bin/llvm-mc就是汇编器。如果你再从<http://llvm.org>下载Clang，那么就有了C->IR的翻译以及完整的编译器Driver。GDB是GNU的调试器。只要编译器支持DWARF格式，就可以用GDB调试。

### IDE（集成开发环境）

### 编辑器

## GNU Make

> 参考资料
> <https://seisman.github.io/how-to-write-makefile/overview.html>

## 具体平台下的配置记录

### VSCode with Clang on macOS

> 参考资料
>
> <https://code.visualstudio.com/docs/cpp/config-clang-mac>

#### 概述

#### Clang的安装与配置

#### VSCode配置

#### 编译指令

#### 备注

### VSCode with GCC on Windows

### Visual Studio

# 语言的基本语法和特性

## 基本数据类型

C为数据之间提供了基本的类型转换，但建议使用`<type>(var)`的形式（C++形式）

### 字面常量

- 十进制、八进制和十六进制的表示
- 整数类型字面常量默认为`int`类型，可以附加l/L、u/U表示类型
- 浮点类型默认为double类型，也可以附加f和l
- 特别的，有转义字符及其对应的八进制、十六进制
- 字符串常量直接使用双引号引起，一般会存储一个终止位`\0`

### 符号常量

- 使用以下形式声明

  ```c++
  #define <标识符> <值>;
  const <类型> <标识符> = <值>
  ```
  
  > 值得注意的是，这里的`#define`和`#include`一样使用#表示
  > 我们称这些命令为**宏定义命令**，他们是一种**预处理命令**
  > `const`声明在c++中引入，建议使用
  
- 使用`#define`声明会在预编译阶段替换标识符出现的位置为其值再进行进一步编译运算，`const`声明直接参与编译和运算

### 全局变量

- 与Python、Dart不同，C中一般不会使用下划线开头的命名方式
- 变量的基本特性有变量名、类型、值和内存空间地址
- 全局变量会**自动赋初值**

> 全局变量可以定义在函数外的任何地方，如果在使用一个全局变量时未见到它的定义，则在使用前需要对该全局变量进行声明

```c++
extern <类型名> <变量名>;
```

### 整型

- 最基本的整型为int

- 除int外，可以使用**long和short**进一步修饰。当使用修饰符时，也可以省略int关键字

- 除此之外，还有**long long int**类型

- 所有的数字类型都可以**附加signed和unsigned来声明是否有符号**

- 常见的实现大小

  | 类型          | 大小 | 数字范围 |
  | ------------- | ---- | -------- |
  | short int     | 2    |          |
  | int           | 2或4 |          |
  | long int      | 4    |          |
  | long long int | 8    |          |

- 计算机内，整型都是用**二进制补码**表示

### 浮点型

- float和double两种类型
- double提供了**long double**类型进一步表示更大的数
- float.h中定义了`FLT_EPSILON`和`DBL_EPSILON`两个值，约为$1e-6$用来辅助判断浮点型之间是否近似相等

### 字符型

- char类型

- 提供signed和unsigned

  > 其实所谓的unsigned，也就是相当于最早的七位ASCII码
  
- ASCII码使得大小写转换等操作比较方便，例如

  - 大小写：相差32，或者`int a = 'd' - 'a' + 'D'`
  - 提取字符数字：`int a = '9' - '0'`

### 逻辑数据类型

- 1为true，0为false
- bool同样使用了一个字节而不是位表示

### 空值数据类型

主要用于以下场景

- 没有返回值的函数
- 通用指针`void *`

### 整型和算术型

- int、char以及bool统称为**整型**
- 整型和float统称为算术型

## 变量的存储类型

### 分类方法

- 对于一个变量，我们会从两个角度考虑，一是这个变量的数据类型，具体体现就是在内存中开辟空间的大小；二是这个变量的生存周期，具体表现为在哪一块儿内存空间
- 保存变量当前值的存储单元有两类，一类是**内存**，另一类是 CPU 的寄存 器
- C 语言中定义了 4 种存储属性，即**自动变量、外部变量、静态变量和寄存器变量**

### 作用域

- 变量的**作用范围又称为作用域**,从空间角度,可以将变量分为**全局变量和局部变量**

- 局部变量是在一 个函数或复合语句内定义的变量，它仅在函数或复合语句内有效。

  编译时，编译系统不为局部变量分配内存单元，而是在程序运行过程中，当局部变量所在的函数被调用时，编译系统根据需要临时分配内存，调用结束，空间释放。

- 全局变量是在函数之外定义的变量，其作用范围为从定义处开始到本文件结束编译时，编译系统为其分配固定的内存单元，在程序运行的自始至终都占用固定单元。

- 默认情况下，使用**作用范围最小的同名变量**。

  如果要使用外部的变量，可以使用`::x`的形式调用。

  > 不要饱了撑的重复定义同名变量

### 生存期

- 变量的保留时间又称为生存期,从时间的角度,可将变量分为**静态存储和动态存储**两种情况

- 静态存储是指**变量存储在内存的静态存储区**，在编译时就分配了存储空间

  在整个程序的运行期间，该变量占有固定的存储单元，程序结束后，这部分空间才释放，变量的值在整个程序中始终存在

- 动态存储是指变量存储在内存的动态存储区，在程序的运行过程中，只有当变量所在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值只在函数调用期存在

### C中的内存分配

![img](https://pic3.zhimg.com/80/v2-deb39dc05a514a6e3bcf5751be932846_1440w.jpg)

- stack
- heap
- bss(Block Started by Symbol)：通常是指用来存放程序中未初始化的全局变量的一块内存区域，由static修饰，BSS段属于静态内存分配。
- code/text segment：用来存放程序执行代码的一块内存区域。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等

### 存储类型

#### 自动变量

- auto通常作为缺省选项自动添加
- 自动型变量只能作为局部变量
- 对于出现嵌套的重名变量，以**作用域最小的变量为准**

#### 寄存器变量

- 使用register关键字声明
- 通常用来声明**少数调用最频繁的变量**，将会被存储在**CPU的通用寄存器中**
- 值得注意的是，不是都会被存储在寄存器中，需要寄存器有空余空间，存储数据短于寄存器位长

#### 外部变量

- 使用extern关键字声明
- extern用于**跨文件调用变量**，将会存储在静态数据区
- 对于一个在其他文件中定义的变量，在另一个文件中访问时需要使用extern关键字，编译器将会在其他源文件中寻找变量的定义

#### 静态变量

- 使用static关键字声明

- 使用const定义也具有文件作用域

  > 建议使用在C++中引入的const
  >
  > 二者的区别详见
  >
  > <https://www.runoob.com/w3cnote/cpp-static-const.html>

- static声明后的变量，**不能通过extern引用**

## 基本输入输出

> 记得引入stdio.h(cstdio)

### 格式化输出

- 与所有的格式化输出一样，printf函数接受两组变量，分别是输出格式和输出项系列，示例

  ```c
  printf("num = %f \n",num);
  ```

- 常用转换说明符

  | 说明符 | 含义                      |
  | ------ | ------------------------- |
  | %d     | 十进制整数（**D**ecimal） |
  | %x     | 十六进制整数（he**X**）   |
  | %f     | 浮点数（**F**loat）       |
  | %c     | 字符（**C**har）          |
  | %s     | 字符串（**S**tring）      |

- 说明符的更多控制方式（详见教材2.7.1）

  - 整数：

    %md，其中m为指定的输出长度，若长度不足则用**空格补足**，比如

    ```c
    int n = 234;
    print("%6d",n);
    ```

    由于234不足666位，将会输出“000234”

    %mld，输出长整型数据，同样可以指定长度

  - 浮点数

    留空，默认输出六位小数

    %m.nf，输出m位整数，n位小数，长度不足用空格补足

- 值得注意的是，格式化输出中的格式说明符与输出项系列是一一对应的，例如

  ```c
  printf("%d %d %d",n1,n2,n3);
  ```

  就会依次输出n1,n2,n3的内容
  
- 使用转义字符要比`endl`效率更高

### 格式化输入

- scanf函数与printf函数使用基本相同，需要记住的是输入项系列的每一项需要附加一个&

  > &用来表示表示变量的地址

- 输入分隔符的指定，示例

  ```c
  scanf("%d,%d",&n1,&n2);
  scanf("%d:%d",&n1,&n2);
  scanf("%d;%d",&n1,&n2);
  ```

  他们的分隔符，分别为,、:和;

- 输入长度的指定

  > 一定程度上可以用来解析数据
  
  示例：
  
  ```c
  scanf("%4d%2d%2d",&a,&b,&c);
  ```
  
  会将输入值“19900125”拆分为1990、01和25

> 有些IDE会在结束执行任务之后关闭cmd窗口，这样会导致看不到运行的结果
>
> 可以添加一个`cin.get`语句，读取依次键盘输入即可解决（如果一个不行那就来两个）

### 字符输入与输出

- getchar与putchar函数

# 预处理器

# 数组类型

> 数组之所以被叫做“复合数据类型”，是因为它有某个数据类型来创建的
>
> 在C中，他们被叫做“派生数据类型”，但C++引入了类的“派生”，因此使用术语了“复合”来描述这个关系
>
> 因此严格来讲，我们应该称呼一个数组为“xxx数组”

## 声明

```c++
int nums[];
int nums[10]; // 并不会进行初始化
int nums[] = {1,1,...};
int nums[10] = {1,1};  // 未初始化的位置都会初始化为0
```

C++11提供了一系列新的初始化方式

```c++
int nums[] {1,1,...}; //省略等号
int nums[10] {}; //编译器将所有元素设置为0
```

> C并不会对数组越界问题报错，如果我们访问了这个数组以外的位置，C会从最后一个元素所在的内存地址继续找下去。因此数组越界在这里只是找到了另一个地址，他确实能取到值，但不知道会是什么

## 数组的大小

对数组使用`sizeof()`获得的是这个数组占用的内存空间，因此元素个数可以使用以下方式获得

```c++
type nums[] {1,1,...};
int num_of_list = sizeof(nums)/sizeof(type);
```

> 需要注意`sizeof()`返回的是`sizez_t`数据类型，他的占位符是`%zd`或`%zu`

## 参数传递

由于数组是内存中连续的一串空间，所以需要一个开头的内存地址即可，但是我们一般还会传入她的长度

因此C也将数组的变量名直接作为内存地址来处理，所以我们在将数组作为指针时就是采用了引用传递，比如说下面二者就是等价的

```c
// 写法一
int sum(int arr[], int len);
// 写法二
int sum(int* arr, int len);
```

传递二维数组时，形参必须含有列数、不含行数，例如`int[][5]`；如果函数的参数是多维数组，那么除了第一维的长度可以当作参数传入函数，其他维的长度需要写入函数的定义。举个例子

```c
int sum_array (int a[][4], int n);
```

函数sum_array()的参数是一个二维数组。第一个参数是数组本身（a[][4]），这时可以不写第一维的长度，因为它作为第二个参数，会传入函数，但是一定要写第二维的长度4。

> 这是因为函数内部拿到的，只是数组的起始地址a，以及第一维的成员数量2。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成int a[][4]，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是4 * sizeof(int)。

传入变长数组时，需要注意先传入数组长度这个参数才能确定需要划分的内存大小

基于这种思想，我们可以得到一种新的传入高维数组的方式

```c
int sum_array(int n, int m, int a[n][m]);
```

## 数组指针

C对数组名和数组指针的处理，带来一些有意思的特性

首先是对数组成员的访问，有这样的关系恒成立

```c
a[b] == *(a + b)
```

对于一个指针变量，我们都知道它是具有加法的，数组指针的加法其表现就是在数组元素之间移动，因此`p++`其实就是指针移向下一个元素，利用这个性质可以遍历数组，比如

```c
int a[] = {11, 22, 33, 44, 55, 999};

int* p = a;

while (*p != 999) {
  printf("%d\n", *p);
  p++;
}
```

这份demo有两个需要关注的地方

1. 数组名`a`相当于被`const`修饰，是不可以改变指向的。因此不能够使用`a++`这样的语句，而是使用`p`进行操作；显然，这是为了保护数组，避免数组称为垃圾
2. 循环条件的判断一般使用数组元素，或者也可以接受`start`和`end`两个指针

由于数组名是不可变的指针，所以其复制不能简单使用一个声明语句；非要说的话，`a=b`的含义也只是指向同一块内存地址而已，并不能算是复制，应该叫做“备份”。要复制一个数组，有两种方式

1. 循环遍历，不建议使用，low
2. `memcpy()`函数。顾名思义，可以拷贝内存数据，其调用形式为`memcpy(*ptr,*new_ptr,int length)`，速度要快得多

> 其实从这个复制操作，可以看出C具有底层操作性的特点，这里`memcpy()`所做的就是直接操作内存，其效率确实要比遍历复制快得多，但也相对危险
> 简化指针的操作，在C++中引入代替C的指针

# 字符串类型

字符串处理的方便与否是衡量语言便利程度的标尺（暴论

## C风格字符串

C风格字符串是一个末位元素为`\0`的char数组

> 严格来讲，C没有字符串类型

```c
char string[] = {'a','b','c','\0'}; // 这才是一个字符串
char not_string[] = {'a','b','c'}; // 这个不是！
```

当然，这样写多少有点离谱，C提供了一个语法糖，将双引号之间的内容自动处理成字符数组；对于跨行的字符串，为了便于缩紧，C还可以将两个间隔只包含空格的双引号的内容进行连接

```c
/* {'H','e','l','l','o'} = "Hello"*/

char string[50] = "Hello"
  "world";
```

### 声明

C有两种基本的声明形式，字符数组和字符指针

```c
char* s = "Hello, world";
char s[] = "Hello,world";
```

### 基本属性

C字符串对应的`cstring`头文件提供了`strlen()`函数，可以计算字符串的长度（而不是数组的长度）；同时，`strlen()`不会计算空字符

### 读入数据

`cin`对象默认是以‘单词’作为对象读取的，他根据空白符（空格、制表符等等）作为分割的依据，因此使用`cin >> string`不能读入一行字符串

`cin`提供了`getline()`和`get()`函数来解决问题，他们都接受目标字符串和接受字符长度两个参数

二者的区别在于`getline()`会抛弃换行符，也就是说，使用`get()`函数的话，命令行中结束输入时的最后一个换行符，将被留在输入队列而不读入，如果在这个语句之后紧跟着一个`cin.get()`就可以吞掉没有读入的换行符

### 复制和拼接

`cstring`提供了`strcpy()`和`strcat()`实现复制粘贴
还有更安全的两个函数`strncpy()`和`strncat()`，他们接受第三个参数作为目标数组的最大长度

![image-20220408082914099](https://tva1.sinaimg.cn/large/e6c9d24ely1h120dptlhrj20x20qsq62.jpg)

## string类

C++98提供了string类库，将string作为一种对象处理，string因此可以被看做一个“数据类型”

与C字符串比起来，string类有这样的特点

- 自适应长度

- 重载了`+、+=、=`等运算符

- string作为一个对象，使用`.size()`方法获取长度

- 由于istream类在设计时没有考虑到string类型的读写，因此我们使用另一个`getline()`方法读取string

  ```c++
  string str; // 未被初始化的string长度将被置为0
  getline(cin,str);
  ```

# C的函数

## 定义与调用

### 函数的定义

- 函数是对过程/功能的抽象
- 一般建议函数的体积不超过单屏的显示面积
- C中采用如下格式声明函数

  ```c
  <存储类型> <返回值类型> function (形式参数及其说明){
   ;
  }
  ```

  注意，存储类型只有extern和static两种

  返回值除了常见的数据类型，还可以是指针和结构体
  
- C的实参可以指定参数名

- C支持可变参数的定义，通过`...`标识

- 对于main函数，返回值可以使用`EXIT_SUCCESS`或`EXIT_FAILURE`宏，其被定义在`<strlib>`中

### 函数的调用

函数调用主要存在两种情况，本文件调用和跨文件调用，但在此之前首先要明确函数的声明以及函数原型。

由于C编译器在编译时如果发现一个函数，需要立刻对其进行编译，因此调用的函数必须在调用前进行声明后使用；但问题来了，如果函数很多，甚至我们调用了外部的函数，就会难以满足这个条件，因此C提供了函数原型。只需要在源文件头部生命函数原型，即可正常调用该函数。

### static标识符

static标识符在发展过程中得到了三种主要的作用，首先最直观的是

1. 声明静态变量。</br>
对一个函数来讲，其内部变量在函数被调用时总是会被初始化；使用`static`声明后，该变量将在第一次初始化之后被保护起来
1. 声明内部函数。</br>
既然可以对一个变量使用`statcic`声明，自然也可以对一个函数使用。这种情况下，函数被视作内部函数，不可以被其他文件调用

> 换句话讲，这意味着函数不刻意生命的话是能够被其他文件调用的。这其实是`extern`标识符的作用，二者在这一角度上正好有相反的作用，而所有函数相当于默认都会添加一个`extern`标识符允许外部调用

1. 修饰数组参数。

比如`void function(int a[static 3])`意味着该参数的数组长度应当大于3，这与其字面含义有些出入

### const标识符

`const`含义更多的在于维持原本的值，而不是`static`这样一直保持这个值。在函数参数中出现的`cosnt`，意义在于表示函数内部不得修改该参数变量。

特别的，对于函数指针会有两种情况

```c
void f(const int* p );
void f(int* const p);
```

前者`const`能够保证`p`这个指针的值不会被修改，也就是`p`所指向的内存被保护起来，其值不可以被修改；后者保证了`p`的安全，也就意味着`p`的指向不可以被修改，但其指向的值并没有被保护起来；当然，我们也可以在两个位置都使用`const`声明。

#### 头文件声明

- 对于C标准库，我们通过类似`#include <stdio.h>`的形式调用

- 自己定义头文件，使用类似`#include "file.h"`的形式调用

  > `<文件名>`表示在**系统指定的目录**下寻找指定文件。
  >
  > `“文件名”`表示先在包含#include命令的源文件所在的目录下查找指定文件，找不到时，再到系统指定的目录下寻找指定文件。

## 由函数终止程序

其实就是讨论`exit()`函数

exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件stdlib.h里面。其返回值一是`EXIT_SUCCESS`或`EXIT_FAILURE`

有时调用`exit()`函数时还需要一些其他函数，C提供了一个`atexit()`函数，用来登记exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件stdlib.h。

```c
int atexit(void (*func)(void));
```

## 函数间数据传递

### 通过参数（值）传递

> C默认使用值传递

- 只适合传输少数数据
- 传送的数据的**一份样本**
- 传入值的所有操作不会对外部变量产生影响

### 通过地址传递

很明显值传递往往是不符合需要的，而且C/C++不支持返回多个返回值，这会带来很大不便

要解决这个小问题，只需要传入变量的地址即可，比如

```c
void Swap(int* x, int* y) {
  int temp;
  temp = *x;
  *x = *y;
  *y = temp;
}
```

### 可变参数

有时函数接受的参数长度并不确定，可以使用`...`来表示可变数量的参数

头文件stdarg.h定义了一些宏，可以操作可变参数。

1. `va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。
2. `va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。
3. `va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。
4. `va_end`：一个函数，用来清理可变参数对象。

示例

```c
double average(int i, ...) {
  double total = 0;
  va_list ap;
  va_start(ap, i);
  for (int j = 1; j <= i; ++j) {
    total += va_arg(ap, double);
  }
  va_end(ap);
  return total / i;
}
```

上面示例中，va_list ap定义ap为可变参数对象，va_start(ap, i)将参数i后面的参数统一放入ap，va_arg(ap, double)用来从ap依次取出一个参数，并且指定该参数为 double 类型，va_end(ap)用来清理可变参数对象。

# 指针

首先啊要明确，指针是C的概念，它是一个记录内存地址的值；C++为了简化，设计了引用。

## 基本概念和引入

不难理解指针是一个指向某个内存地址的值，那么指针迎来了第一个问题——类型

指针是有类型的，它的类型决定了内存地址块的大小，区分数据类型本身和他的指针的方式就是指针类型会添加一个`*`。准确来说，`*`并不依附于原本类型，比如说

```c
int* p1;
int * p2;
int *p3;
int        *             p4;
```

都是合法的声明方式，只是添加一个`*`即可。一般来说，我们使用`type* p`的形式，用来强调指针类型也是一种类型。

在声明后，编译器会为指针随机指向一块内存空间，显然这是不安全的，我们可以用声明同种数据类型的方式对他进行初始化

```c
int* p;
int i;
p = &i;

int* p = NULL;
```

> 为了防止错误的使用，我们可以像最后一行那样将指针变量先指向`NULL`(内存地址0)，在没有初始化时对其调用就会报错

指针指向一块内存地址，我们需要有方法得到和保存着快地址的一些信息

- 取出地址:使用`&`运算符，获得该指针指向的**内存地址**
- 取出值:使用`*`运算符，获得该指针指向的内存地址所保存的**数据值**

## 指针运算

指针的运算会有所不同，首先我们考虑指针具有的数据类型，其类型决定一个变量在内存中占据的大小，因此我们可以得到指针变量加法和减法的一些概念

- 指针变量与数值加减：在原来内存地址的基础上，移动若干个类型的长度
- 指针变量之间的减法：返回两个指针指向的内存地址之间相隔该数据类型的个数
  > 此时返回值为``ptrdiff_t，被定义在`stddef.h`中
- 指针变量之间的比较：较大的一方返回1

## 受限指针

声明指针变量时，可以使用`restrict`说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。

## 指针与数组

## 指针与函数

> 在C内部，函数名也被视作一个指针：函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址

函数指针的定义和使用会有些混乱，但我们先考虑上面所说的因素，这会使得调用函数有如下形式

```c
print(var);
(*print)(var);
(&print)(var);
```

笔者认为其实这三种都可以认为是通过函数名直接调用，只是第一种方式通过符号名与实际内存地址的映射进行调用，有点像是语法糖的感觉；

> 之所以这样说，是因为我们可以考虑将所有变量调用、函数调用都视作对内存的直接操作，这种语境下符号名显然就不具有实在的作用——特别是与后面两者相比，它既没有取出函数的地址也没有取出函数的值，所以不妨把它看作一种简化、语法糖

第二种方式取出该函数名作为指针指向的内存的值，相当于取出了整块内存的数据得到这个函数；第三种则是将变量传入这块内存中。

如果我们引入函数指针，首先一个问题是它的声明会有些奇怪

```c
void (*print_ptr)(int) = &print;
```

这样对函数的调用还有两种

```c
(*print_ptr)(var);
*print_ptr(var);
```

那么问题来了，为什么没有

```c
&print_ptr(var);
```

# C的内存操作

## 分配内存

C提供了几个可以为程序在堆区分配内存的函数，分别是`malloc()`、`calloc()`和`realloc()`，他们都可以在内存中开辟指定大小的连续空间，其中`calloc()`简化了`malloc()`部分操作，`realloc()`则用于修改内存空间。

### 开辟内存空间

`malloc()`接受一个`size_t`类型的参数，返回万能指针`void*`，用来记录开辟的内存的地址。

`malloc()`分配的内存空间不包含类型信息，也没有对内存进行初始化，也就是说，仅仅分配内存也是可以访问的，但不安全也不确定。

通常会使用`sizeof(type)`来计算需要的内存空间大小，有时还会进行一次强制类型转换增强可读性，比如这样

```c
int* p = (int*) malloc(sizeof(int));
//动态分配内存
int* q = (int*) malloc(sizeof(*q));
```

> 由于`malloc()`可以指定要分配的内存大小，所以在参数中包含的变量能够实现动态数组——根据前面运行的情况分配一定大小的数组，这是直接使用数组声明无法实现的。

`malloc()`分配内存有可能分配失败，这时返回常量 `NULL`。`Null`的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括`stdlib.h`等多个头文件里面都有定义，所以只要可以使用`malloc()`，就可以使用NULL。由于存在分配失败的可能，所以最好在使用`malloc()`之后检查一下，是否分配成功。比如

```c
int* p = malloc(sizeof(int));

if (p == NULL) {
  // 内存分配失败
}

// or
if (!p) {
  //...
}
```

> 事实上，`NULL`的值不一定是0.前桥和弥在《征服C指针》中提到了`NULL`的细节

malloc()最常用的场合，就是为数组和自定义数据结构分配内存。

### `calloc()`的简化

`calloc()`可以视作对`malloc()`的简化，他有两个差异

1. 接受两个参数，分别是数据类型的数量和单位字节长度。这使得使用`malloc()`时的`sizeof(type)*n`更换为两个参数，有更好的可读性。
2. `calloc()`会将所分配的内存全部初始化为0。`malloc()`不会对内存进行初始化，如果想要初始化为0，还要额外调用`memset()`函数。

### 内存块大小的修改

`realloc()`函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回`NULL`。

`realloc()`可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。`realloc()`优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自行调用`memset()`）。比如下面的例子就是动态控制数组的长度

```c
int* b;

b = malloc(sizeof(int) * 10);
b = realloc(b, sizeof(int) * 2000);
```

当`realloc()`的第一个参数为`Null`，等价于开辟一块新的内存空间；第二个参数为`0`等价于清空内存。

## 对内存的操作

### 设置值

`memset()`函数可以向内存地址填充连续的同一个值，常用来初始化分配的新的内存块。

### 复制

`memcpy()`可以将内存中的内容从一个地址复制到另一个地址，这两个内存块不应该有互相重叠的区域。

`memcpy()`可以取代`strcpy()`进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快。

以下是一种实现方式

```c
void* my_memcpy(void* dest, void* src, int byte_count) {
  char* s = src;
  char* d = dest;

  while (byte_count--) {
    *d++ = *s++;
  }

  return dest;

}
```

`memmove()`函数用于将一段内存数据复制到另一段内存。它跟`memcpy()`的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与`memcpy()`行为相同。

### 比较内容

`memcmp()`函数用来比较两个内存区域。

## 清理内存

`free()`用于释放`malloc()`函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。

> 如果程序存在未被回收的内存，最终就会引发“内存溢出”。</br>
> C中使用`malloc()`、`free()`等函数的过程可以算是一些语言的内存垃圾回收机制的核心工作。

# 结构与联合

## 结构

### 声明和初始化

C与C++在声明结构时有语法习惯的差异，C会保留关键字`struct`，而C++会省略，这种改变目的在于强调对数据类型的声明

```c++
struct c_style_type {};
cpp_style_type {};
```

通常情况下，使用外部声明声明结构数据类型，这也是C++鼓励的用法

C中，由于`struct`的声明需要采用这种形式

```c
struct hello {
  int a;
  int b;
};

struct hello h;
```

总是需要带上`struct`很是别扭，所以往往使用`typedef`关键字定义一个别名便于使用，增强可读性。

`struct`占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。

> 为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</br>
> 由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递减的顺序定义每个属性将最大的一个属性放在最后，这样就能节省一些空间。

### 参数的传递

- 默认情况下，结构数据类型作为形参使用值传递

在使用`struct`指针时，`(*t).age`这样的写法很麻烦。C 语言就引入了一个新的箭头运算符`->`，可以从 `struct`指针上直接获取属性，大大增强了代码的可读性。比如

```c
void happy(struct turtle* t) {
  t->age = t->age + 1;
}
```

也就是说，对于`struct`变量名，使用点运算符`.`获取属性；对于`struct`变量指针，使用箭头运算符`->`获取属性。

### 位字段

### 弹性数组成员

很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。

弹性数组成员总是为结构的最后一个属性，且这个结构需要至少一个其他属性

```c
struct vstring {
  int len;
  char chars[];
};
struct vstring* str = malloc(sizeof(struct vstring) + n * sizeof(char));
str->len = n;
```

## `typedef`

## 联合/共用体

共用体像是对数据类型的重载，他可以保存多种数据类型，但只能使用一种类型

他最常见的目的是节省内存

# C++与C

## C++引入的特性

### 一些关键字

### 命名空间

- 在一个源文件中要用到两个分别在另外两个源文件中定义的不同全局程序实体（如：全局函数），而这两个全局程序实体的名字相同。

- 在一个命名空间中定义的全局标识符，其作用域为该命名空间

- 当在一个命名空间外部需要使用该名空间中定义的全局标识符时，可用该命名空间的名字来修饰或受限。

- 示例

  ```c++
  //模块1
  namespace A
  { int x=1;
  void f()
  { ;
  } 
  }
  //模块2
  namespace B
  { int x=0;
  void f()
  { ;
  } }
  
  //模块3
  ... A::x ... //A中的x 
  A::f(); //A中的f
  ... B::x ... //B中的x
  B::f(); //B中的f
  ```

## 类与结构体

# C++多模块结构

## 简介

- 模块是为了便于从物理上对程序进行组织、管理和理解，便于多人合作开发一个程序
- 可以按某种规则对构成C++程序的各个逻辑单位（全局函数、全局常量、全局变量/对象、类等）的定义进行分组，分别把它们放在若干个源文件中（.cpp），构成若干个模块
- 模块可以单独编译

## 构成和实现

- 接口（.h）：给出在本模块中定义的、提供给其它模块使用的一些程序实体（如：全局函数、全局变量等）的**声明**和（如类型、常量等）**定义**
- 实现(.cpp)：给出模块中的**程序实体的定义**
- 在模块A中要用到模块B中定义的程序实体时，可以在A的.cpp文件中用文件**包含命令（#include）把B的.h文件包含进来**

# 面向对象

## 类与对象

## this指针

## 类成员、特殊成员和对象成员等

## 友元

## 继承

## 多态

# 常用库

## <stdio.h>

## <cctype.h>

- `tolower`和`tohigher`

## <bios.h>

- basic input & output system

### 常用函数

- bioskey()

  读取参数0时，能够获取键盘上的功能键

# C和C++的风格差异

## 小规则

- 类型强制转换

  ```c++
  (type) var;// C
  type(var);// C++
  ```
