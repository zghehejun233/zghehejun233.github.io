---
title: Thinking in Java 笔记
description: Thinking in Java笔记
categories: 开发
tags:
  - Java
index_img: /post_img/85713731_p0.jpg
banner_img: /post_img/85713731_p0.jpg
abbrlink: 63900
header: ''
---

## 初始化与清理

从概念上讲，“初始化”与“创建”是分离的，但是Java的构造器（构造方法）保证了“初始化”和“创建”捆绑在一起。

### 构造器与方法重载

构造方法的重载是方法重载这一特性的典型场景。被重载的方法通过**参数列表**进行区分。

> 为什么不使用返回值区分？</br>
> 在一些使用场景下，对方法的调用是一种“只希望得到函数副作用”的调用，此时并不接受函数的返回值（这与是否返回`void`无关，我们只是调用一个函数`func()`且不接受返回值），在这个情况下，编译器无法判断程序员在调用哪一个函数。

`this`关键字只能在方法内使用，它是**使用这个方法的那个对象的引用**

> C中的`this`并不是引用而是一个指针，不过作用其实是相似的。`this`关键字再语义上等价于`*this`释放指针引用

利用`this`关键字，我们可以在一个构造方法中调用另一个构造方法。比如，无参构造方法可以调用一个全参构造方法并进行默认的初始化。

与`this`相对，`ststic`关键字表明的就是没有`this`，也就是没有调用对象的方法，`static`方法直接通过类调用，可以访问`static`域，有些类似全局方法。

> 其实这里可以考虑另一种对方法的描述。
>
> 在面向对象的概念下，方法的调用其实是向一个对象发送了一个消息，例如`demo.func()`应该理解为`Demo.func(demo)`。而`static`方法是不需要发送消息的，所以从原教旨主义（bushi的角度来看，`static`方法多少有些不OOP。

### 清理：终结和垃圾回收

> 一个对象的创建、初始化，使用，直到他被销毁、清理，其实就是安卓和Spring里进行的所谓对象的生命周期的管理。安卓给一个`Activity`类的实例规定`initState`等等方法，无非就是给一个类规定一些方法在相应的情况下被调用嘛，并在这些阶段做对象应该做的事情。

Java的GC负责回收无用对象占据的内存区域，但是，GC无法释放那些特殊的内存（比如Java调用C代码使用`malloc()`函数开辟的内存空间）。因此Java为类提供了一个`finalize()`方法，他将在GC准备释放对象的内存空间时，首先被调用，并在下一次被调用时在真正回收对象的内存。

必须指出`finalize()`方法不是析构函数，Java里的对象并不总是被垃圾回收

1. 对象可能不被垃圾回收
2. 垃圾回收并不等驾驭“析构”
3. 垃圾回收只与内存有关

注意，**使用GC的唯一目的就是为了回收程序不再使用的内存**

因此`finalize()`的使用总是很别扭的，但书中指出可以用于**对象终结条件**的验证。调用`finalize()`时一定要调用`super.finalize()`。

### GC的工作原理

#### 引用计数

#### 停止-复制

#### 标记-清扫

#### 即时编译器（Just-In-Time, JIT）

### 成员初始化

#### 构造器初始化

默认初始化是无法阻止的，一定会在手动初始化之前先=执行；即使构造器中存在初始化的代码也一定会把所有数据成员先初始化成默认的值。

类的内部，变量定义的先后顺序决定了初始化的顺序；即使变量定义散布在方法各处，他们依旧会在哥任意方法（包括构造器）被调用钱得到初始化。

静态初始化只有在必要的时候才会进行。

从总体上看，对象的初始化过程为：

1. 首次创建类的对象或访问类的静态区域时（构造方法也是静态方法），Java解释器将定位`Demo.class`文件
2. 载入`Demo.class`文件，创建`Class`对象，进行静态初始化
3. 使用`new`关键字时，在堆上分配足够的空间
4. 空间清0，所有基本数据类置为了`0`，引用置为了`null`
5. 执行字段定义处（可能分散在各个方法处）的初始化动作
6. 执行构造器

#### 显式的静态初始化

域内使用`static`关键字声明的语句将跟其他静态初始化动作一样，只执行一次。

#### 非静态实例初始化

实例初始化子句是在两个构造器之间进行的，这个语法对于支持匿名内部类是必要的。

#### 数组初始化

所有数组都包含一个`length`成员。

## 数据和引用

### static和final关键字

- `static`强调只有一份
- `final`强调是一个常量

具体来讲，对于一个数据，或者说域

#### 数据（域）

一个又`final`又`static`的域是内存上不变的连续区域。

`final`修饰基本数据类型时，数据的值不改变；修饰引用时，值也是不改变，但引用的值不改变其实就是不可以改变引用指向的对象。

#### 方法

`final`方法主要用于方法锁定，禁止继承类修改这个方法的定义。

`private`关键字在这个角度上与`final`有相同的效果，二者可以并存，但没什么意义。

> 开发项目时，除了设计好用于继承的基类，将所有方法都先声明为`final`是一个好习惯。

#### 类

`final`类禁止被继承，且所有方法都被隐式指定为`final`的。

## 类的复用

> 对应原书第七章

类的复用主要有两种方式，组合和继承

一条通用的准则：“**用继承表示行为间的差异，用字段表示状态上的变化**”。

### 组合

组合是一种更自由的方式。他不会继承接口，不会有转型的问题，被组合的类以对象（字段）的形式存在于调用类内部，因此调用类需要编写一系列方法去调用被组合类。

组合适合添加某个类的功能，利用它实现某个功能，而不是暴露他的所有接口。

### 继承

继承会自动得到基类的所有域和方法。

> 要访问基类的域，必须使用`super`关键字访问。

继承方式得到的类，其构建过程是从基类“向外”扩散的所以基类在导出类的构造方法调用前就已经完成了构造；当然，导出类构造时将会先装在导出类的构造方法，再通过显式的`super()`调用基类构造方法（或隐式调用基类的无参构造方法）。

为了解决继承时错误的override，Java引入了`@Override`注解，该注解能够提示编译器检查是否override成功。

继承往往用于构造基类的一个特殊版本。

> 要判断是否使用继承，可以考虑这个类需不需要向上转型，如果不需要就不使用继承。

通常，实体类应避免使用继承的方式构造。

### 代理

代理是一种折中的方法，他将一个成员对象置于所要构造的类中（类似组合），与此同时，在类中暴露了该成员对象的所有方法（类似继承）

## 多态和类型信息

> 对应原书第八章和第十四章

继承会带来类与类之间的耦合，而多态就是用来消除这种耦合关系的。

Java中，除了`static`和`final`方法，所有的方法都是后期绑定的。

> C++就不同，我们使用`virtual`关键字使得一个方法可以被后期绑定，也就是赋予其多态性。

即使引用并不知道对象的具体类型也可以正常工作。引用只是向对象发送一条信息，发送的前提是对象有这个接口（显然继承保证了导出类具有基类的所有这些接口），至于如何执行全部交给对象，因此对象总是可以执行其自身定义的正确的方法。

由于任何域访问操作都将由编译器解析，因此不是多态的。当访问基类的域时，就必须要使用`super`引用。

### 协变返回类型

自Java SE5开始，重写方法可以返回原方法返回值类型的导出类型。

### RTTI

Java会对所有向下转型进行类型检查，存在错误就会抛出`ClassCastException`异常。

这种运行期间检查类型的机制被称为运行时类型识别（RTTI）。

## 接口、抽象方法和内部类

{% note success %}
接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。
{% endnote %}

> 原书第九、十章

### 抽象类和抽象方法

很多时候一个基类中的方法有许多无效方法，他们只用于为导出类提供一个接口；如果导出类对象向上转型后调用这个方法，得到的是没有意义的结果。

Java为这种情况下的方法提供了`abstract`关键字，这个关键字允许创建一个只有签名、没有实现的方法，这种方法就是**抽象方法**。抽象方法就是一个单纯的接口了，他的实现必须由基类实现。因此，一个继承自抽象方法的类，必须对所有抽象方法实现；否则的话，这个导出类也会被处理为抽象类，同时编译器强制要求加上`abstract`关键字。

因此，包含抽象方法的类不能被实例化，因为这些抽象方法没有方法体，我们自然的将含有抽象方法的类称为**抽象类**。抽象类不可以被实例化。

抽象方法和抽象类主要有两个作用

1. 明确抽象性，告诉编译器需要做的工作。
2. 有利于重构，将公共方法沿着继承层次向上移动。

### 接口

接口是一种完全抽象的类，不包含任何实现。他为类与类之间的通信建立了一个协议，因此有些语言使用`protocol`关键字实现这个功能。接口也可以包含域，这些域隐式地`static`和`final`。

接口可以实现完全解藕。如果一个方法使用类声明，他就只能接受这个类及其子类；但接口可以几乎完全忽视这种限制。

### 内部类

## 对象容器

Java的容器类有两个概念，单列集合`Collection`和双列集合`Map`；其中`Collection`又有三个拓展`List`、`Set`和`Queue`；因此共有四个基本的容器接口，每个接口提供了一些实现。

在使用容器类时，有必要向具体容器传入类型参数（也就是将使用范型设计的类实例化），这样

1. 编译器可以提供编译阶段的类型检验
2. 从容器中取出的对象将直接拥有类型，而不需要向下转型

理想情况下，**应该使用`list`等四个接口进行容器的操作**，除非需要使用具体实现类的特殊方法。

> 对于`Collection`的实现类，尽管可以在构造时传入参数，但先创建一个空对象，再使用`Collection.addAll()`方法要快得多。

对于有查询速度要求的情况，使用`HashSet`、`HashMap`等基于散列函数的类是最优解；要维护插入顺序或结构的话，就要考虑`TreeSet`等类。

### `List`列表

通常，可以使用`Arrays.asList()`方法由数组创建一个集合，但该方法创建的元素类型是所有元素的“最小公倍数”，有时并不是我们期望的类型；针对这种情况，可以使用显式类型参数说明`Arrays.<Type>asList()`。

`List`有两个主要的实现

- `ArrayList`，底层是动态数组
- `LinkedList`，底层是链表

![List](https://img-blog.csdn.net/20160413184734236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

从这个继承图[^6]可以看出

- `List`接口共有`ArrayList`,`LinkedList`,`Vector`和`Stack`四个实现，后两者已经被弃用。
- `AbstractList` 是一个抽象类，它继承与 `AbstractCollection` `。AbstractList` 实现了 `List` 接口中除了 `size()`、`get(int location)`之外的方法。
- `AbstractSequentialList`是一个抽象类，它继承与`AbstrctList`。`AbstractSequentialList`实现了“链表中，根据index索引值操作链表的全部方法”。

`List`接口定义了一个`subList()`与`String`的`subString()`方法不同，他返回的只是一个原列表的引用，因此其修改会直接影响到原`List`；要避免这个副作用，可以嵌套一层`List`作为引用的引用，这样操作的就不是原数据。

### `Set`集合

`Set`完全继承并实现了`Collection`接口的内容，实际上二者就是一回事儿，只是行为不同。

### `Queue`队列

队列是一种能够可靠的将对象从程序的一个区域传输到另一个区域的途径。

> 比如用在并发编程。

### `Map`双列集合

并不知道有什么特别要说的。。或许，`Map`可以生成 key 或 value 的`Collection`？

### Iterator迭代器

迭代器是一个轻量的对象。它的作用是遍历并选择序列中的对象，且不需要知道序列的具体实现。

这个概念很奇怪，其实迭代器是一种实现和操作分离的方式。例如

1. 使用`hasNext()`和`next()`方法进行迭代，这种方式无需使用`for`或`foreach`语句和序列长度即可进行遍历；解决了序列长度不可知的问题。
2. `remove()`方法替代了使用引用指向要被删除的元素，并且对于一些结构（如链表），隐藏了重新连接序列的过程，使得基于动态数组或链表的数据结构得到了统一的实现。

因此，迭代器能够将遍历序列的操作与序列底层的结构分离。

> 迭代器统一了对容器的访问方式。

在 Java 中，实现`Collection`接口就意味着提供`iteartor()`方法，二者似乎被绑定了。实际上对于一个已有的类，要让它实现`Collection`接口需要实现较多方法，这并不方便，因此，在这种情况下，继承这个类并提供创建迭代器的能力要更加合适。

### `Iterable`接口

这个接口提供`iterator()`方法，它用于产生一个`Iterator`。

## 异常处理机制

### 异常的创建与捕获

对于 Java 的异常处理机制而言，异常也是一个对象，因此异常的产生大致有这三个阶段

1. 使用`new`在堆上创建异常对象。
2. 从当前环境弹出异常对象的引用。
3. 寻找一个合适的地方接管程序，这个地方就是异常处理程序。

理论上，异常处理理论有两种模型：终止模型和恢复模型。终止模型是 C++ 和 Java 采用的设计。

> 现在也有一些人认为异常的意义不大。他们指出很多程序错误的情况，并不是通过异常处理机制就能解决的，例如用户的错误交互，文件、网络流的错误。

### `finally`子句的使用

`finally`与析构函数要解决的问题不同，理论上，我们应该使用它保证程序在结束 try 块后处于正确的状态。例如，文件应该是被关闭的，TDP 连接断开，物理设备连接断开等等。

### 继承与异常

当 override 方法时，只能抛出基类方法的异常说明里列出的异常，或者这些异常的派生异常。

上面提到的异常限制对构造方法是无效的；但由于积累构造器必定被直接或间接的调用，因此派生类的构造方法还是要包含积累构造方法的异常说明才行。

### 捕获构造时的异常

一些异常会发生在对象的构造阶段，比如执行建立网络连接、打开文件等。在这种情况下，一个 try-catch 语句很难有效的捕获这种异常。

基于一个基本原则：在创建需要清理的对象后，立即进入一个 try-finally 语句块。

真正写起来的话，大概是这个样子

```java
try {
  Object o = new Object();
  try {
    // do something
  } catch(Exception e) {
    // 正常的异常处理
  } finally {
    // 执行类似dispose()的方法收尾
  }
} catch(Exception e) {
  // 处理对象构造时出现的异常
}
```

### 异常的使用场景

书中将异常使用分为这几个主要的类别（有所整理）

1. 知道如何处理潜在的异常
2. 解决问题后重新调用原方法
3. 调整后，绕过抛出异常的部分或用代替的方法执行
4. 尽量做完剩下的事情，向上层跑出异常
5. 及时终止程序并回收资源

## 范型

## 多线程与并发

计算机程序不论做什么事情，归根到底可以分类为“**计算任务**”和“**读写任务**”。两者使用的是计算机上的不同的资源，CPU是计算资源，硬盘、网络是读写资源。多个计算任务之间可能有顺序依赖也可能没有，把*彼此之间没有顺序依赖的**计算任务**同时进行以缩短处理时间的做法叫做“**并发（concurrency）**”*；当计算任务对读写任务有依赖时，*不把计算资源浪费在对**读写任务**的等待上的做法叫做“**异步（asynchronous）**”*。并发和异步都是单一线程无法实现的[^2]。

一般，CPU密集型使用多进程，IP密集型使用多线程即可[^5]。

### 多进程和多线程

> 多线程是一个适用面极窄、效果一般的、向现实妥协的设计；它的出现和火爆都只是一种偶然、且推广乏力[^3]。

总的来讲，共识是多线程比多进程成本低，但性能更低[^4]；而且由于系统差异在Linux下编程多用多进程编程少用多线程编程[^4]。

#### 协程

协程(coruntine)，又称微线程是近几年兴起的技术。是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调用切换时，将寄存器上下文和栈保存到其他地方，再切回来的时候，恢复先前保存的寄存器上下文和栈，
直接操作栈则没有内核切换的开销，可以不加锁的访问全局的变量，所以上下文切换非常快[^5]。

## 参考材料

[^1]: Thinking in Java
[^2]: [多线程是否有意义？ - chris sun的回答 - 知乎](https://www.zhihu.com/question/25371167/answer/117658801)
[^3]: [并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决？ - invalid s的回答 - 知乎](https://www.zhihu.com/question/25390536/answer/2510944114)
[^4]: [多进程跟多线程如何取舍，在不同系统，不同场景下？ - 崔学彬的回答 - 知乎](https://www.zhihu.com/question/48153562/answer/109506150)
[^5]: [关于多线程和多进程 - 飞鸟梦想的文章 - 知乎](https://zhuanlan.zhihu.com/p/125761836)
[^6]: [java集合框架05——ArrayList和LinkedList的区别 武哥聊编程 CSDN](http://t.csdn.cn/c1L4E)
