---
title: Linux应用
description: Linux应用课程的备考笔记，包含常见指令和Shell脚本的一些东西
categories: 学习
tags:
  - Linux
  - 操作系统
abbrlink: 7ae00066
date: 2021-12-15 10:08:21
---

## 课程基础

### 计算机硬件系统基本原理

![image-20211214220439572](https://tva1.sinaimg.cn/large/008i3skNly1gxdpoolvpxj31000js0xa.jpg)

### 操作系统发展简史

### 操作系统定义

### Linux内核组成及简介

- 基本组成：Kernel(内核)、Shell、Applications

- Linux启动顺序：init -> login -> passwd -> shell

  #### 关于Kernel

  - 管理程序的运行，为程序分配资源，并且处理程序之间的通信。

  - 管理对文件系统的读写，把对文件系统的操作映射成对磁盘或其它块设备的操作。

  - 管理存储器，为程序分配内存，并且管理虚拟内存。

  - 管理输入、输出，将设备映射成设备文件。

  - 管理网络。

  #### 关于Shell

  - Shell本身是一个解释器，是Kernel和用户之间的接口
  - Shell是一种脚本语言(Shell script)
  - Shell会在用户登录后启动
  - Shell能够为用户屏蔽内核的复杂性并保护内核
  - Shell有好几种，常见的如bash，csh，zsh
  
  #### 关于Application
  
  - Linux应用程序：标准的LInux应用程序都具有一整套称为应用程序的程序集，包括文本编辑器、Xwindow、办公套件、Internet工具和数据库等

## Linux基本命令

### 登录和退出

- 登录

```shell
$login:userName
$passwd:[your password]
```

- 退出

```shell
<ctrl + D>
$exit
$logout
```

> logout是专门用于命令行中退出当前登录的Shell命令，**exit也具有logout的功能**，但exit同时还能**用于退出执行的shell脚本**，并通过设置参数返回给调用shell的程序本身，这个可以方便协同跨程序间的调用。

### 关于echo

```shell
# Enter "\" to have a new line
$echo "Hello"
$echo Hello \World
```

- 添加选项 -n 表示输出文字后不换行
- 字符串加不加引号都可以，加双引号全部视作字符串但保留变量引用，**单引号全部强制视作字符串**

### 日期和时间

```shell
# 显示时间
$date
# 设置时间
$date -s 
# 显示日历
$cal[month][year]
# 显示当前月份
$cal
# 显示年份（0<year<1000）
$cal[year]
```

- date实例

```shell
$date    显示日期和时间	
-> Wed Sep 29 09:58:29 CST 2004
#date -s 20041229    设置日期	
-> Wed Dec 29 00:00:00 CST 2004
#date -s 12:23:23    设置时间
#date -s “2006-10-10 12:12:23″
```

> 设置日期和时间需要管理员权限



### 其他基本命令

```shell
# 清屏
$clear
# 显示登录到系统的所有用户的信息
$who
# 显示当前登录的用户的信息
$whoami
# 打印当前目录
$pwd
# 中断当前的命令并返回Shell
<ctrl-c>     
# 中断当前的通信或从文件中退出
<Ctrl-d>     
# 删除整行
<ctrl-u>     

```

### 关于mail

- 发送mail：$mail [-n] address


- 一旦邮件被打开，其将被放在 $HOME/mbox目录中，若想再看这些信息则用：mail –f 

### 关于man

### 关于source命令

- source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于**重新执行刚修改的初始化文件**，使之立即生效，而不必注销并重新登录。 

> /etc/profile:此文件为**系统的每个用户设置环境信息**,当用户**第一次登录**时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.
>
> /etc/bashrc:为**每一个运行bash shell的用户执行此文件**.当bash shell被打开时,该文件被读取.
>
> ~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.
>
> ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件.  

- bash是大多数Linux系统默认的shell 。
- bash的命令语法是Bourne shell命令语法的超集。数量庞大的Bourne shell脚本大多不经修改即可以在bash中执行，只有那些引用了Bourne特殊变量或使用了Bourne的内置命令的脚本才需要修改。 

## 文件系统

- Linux文件名最长256个字符
- 不能含有"/"（路径的分隔符）
- **大小写敏感**
- 由一组普通文件、目录文件、设备文件和**符号链接**组成
- Linux下的所有文件都依附在根目录/下

### 文件类型

- 普通文件

  - 二进制文件
  - 文本文件(.txt)

> 从本质上来说文本文件和二进制文件之间没有什么区别，因为他们在硬盘上都有一种的存放方式：**二进制**
> 但是如果要对他们有些区分的话，那可以这样理解。我们现在的每个字符 由一个或多个字节组成，每个字节都是用的-128—127之间的**部分数值**来表示的，也就是说，-128—127之间还有一些数据没有对应任何字符的任何字节。如果一个文件中的**每个字节的内容都是可以表示成字符的数据**，我们就可以称这个文件为文本文件，可见，**文本文件只是二进制文件中的一种特例**。
> 为了与文本文件相区别，人们又把除了文本文件以外的文件称为二进制文件。
> 由于很难严格区分文本文件和二进制文件的概念，所以我们可以简单地认为，如果一个文件专门用于存储文本字符的数据，没有包含字符以外的其他数据，我们就称之为文本文件，除此之外的文件就是二进制文件

- 目录文件

  - 是一个包含文件的容器，用于存放目录中文件列表信息。

  - 目录文件存储一组相关文件的**位置、大小等与文件有关的信息**，但它不包含具体的文件内容，因而和常规文件相比占用的**磁盘空间很小**。

  - 每一项(entry) 主要表示的是一个文件名(或子目录名)以及文件的**索引节点号**(i-node number ) 。

    **索引节点号：**指向**该文件内容所在的数据块的位置，记录了该文件的属性**

    通过 i-node表与文件之间建立对应关系，**目录文件是存放文件名唯一的地方**，**但文件名不放在 i-node表中**

  - 访问一个文件或子目录时，首先访问他所在的目录（因此需要目录文件的执行权限），找到该文件的i-node值，然后再查找i-node 表找出相应的i-node项（i-node entry），从而找到了相应的数据。

  - 在Linux系统中，也可以把目录文件看作是将文**件的名称和它的索引节点号**结合在一起的一张表。 

- 设备文件

  - 块设备：以块为单位进行随机存取。如软盘、光盘和硬盘
  - 字符设备：以单个字符为单位进行顺序存取。如：打印机终端、键盘、鼠标
  
  > 在Linux中 ，因为它是Unix的一种，系统可以使用的不同文件系统，不能像Windows或DOS一样通过设备标识符存取(例如一个驱动器数字或一个驱动器命名)， 而是它们被构建成为一个单一的层次树状结构以作为代表文件系统的实体。



### 关于i-node

- i-node是什么

  硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是**一次性读取一个：“块”（block），每个”块”（block）由八个连续的sector组成**。这种由多个扇区组成的**“块”，是文件存取的最小单位**。”块”的大小，最常见的是4KB，文件数据都储存在”块”中，那么还必须找到**一个地方储存文件的元信息**，比如文件的创建者、文件的创建日期、文件的大小等等。这种**储存文件元信息的区域就叫做inode**，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。

- i-node的内容

  inode包含文件的元信息，具体有以下内容： 
    * 文件的字节数 

    * 文件拥有者的User ID 

    * 文件的Group ID 

    * 文件的读、写、执行权限 

    * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 

    * 链接数，即**有多少文件名指向这个inode** 

    * 文件数据block的位置 

    >  可以用stat命令查看某个文件的inode信息

- i-node号码

  每个**inode都有一个号码**，Unix/Linux系统**内部不使用文件名，而使用inode号码来识别文件**。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 

  > 使用ls -i命令，可以看到文件名对应的inode号码

- 目录文件和i-node

  Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。 
  目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：**所包含文件的文件名，以及该文件名对应的inode号码。** 
  ls命令只列出目录文件中的所有文件名，ls -i命令列出整个目录文件，即文件名和inode号码

  目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以**如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中**，而**读取inode节点内的信息需要目录文件的执行权限（x）**。


### 挂接（mount）

- Linux 通过挂接（mount）一个文件系统将该新文件系统加入它的文件系统树中。

- 所有的文件系统, 不管是什么类型，都挂接在文件系统树的一个目录上并且**该文件系统之上的文件将掩盖掉这个挂接目录中原来存在的内容**。
- 这个目录称为挂接目录或挂接点。当文件系统被卸掉之后，挂接目录中原来的文件才再次可见。

### 用户主目录

- 用户每次登录后自动位于主目录下
- 用户主目录由系统管理员在创建帐号时建立，每个合法的用户在文件系统中都有一个唯一的起始目录。默认的主目录位于**/home目录下，以该用户名命名**。

### 链接文件

- 目录中每一对**文件名称和索引节点号**称为一个链接

#### 硬链接

- 原文件名和链接文件名都指向相同的**物理位址**（i-node number）
- 如果删除硬链接文件的源文件，**硬链接文件仍然存在，而且保留了原有的内容** 
- 不允许**普通用户对目录建立硬链接**；硬链接不能跨越文件系统（不能跨越不同的分区）

#### 符号链接

- 内容是它所**链接的文件的路径名**
- 每个链接文件**都有各自的索引节点号**
- 如果删除符号链接文件的源文件，符号链接文件将无法找到原有资料
- 可用于链接目录，且符号链接能够跨越文件系统

### 相关指令

#### cat、more

- cat是将文件的文本内容一次全部显示在屏幕上，more可以分屏显示全部内容

- cat（concatenate）用于连接文件并打印到标准输出设备上:
  - -n(number):打印行号
  - -b(blank):打印行号，**空行不编号**
  - cat可以通过**重定向**实现文件的合并、建立、覆盖和添加内容等操作
  
  ```shell
  # 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：
  $cat -n textfile1 > textfile2
  # 把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：
  $cat -b textfile1 textfile2 >> textfile3
  # 清空 /etc/test.txt 文档内容：
  $cat /dev/null > /etc/test.txt
  # 例如要制作软盘的镜像文件，将软盘放好后输入：
  $cat /dev/fd0 > OUTFILE
  # 相反的，如果想把 image file 写到软盘，输入：
  $cat IMG_FILE > /dev/fd0
  ```
  
  
  
- more
  - F或space：下一页
  - B:上一页
  - Enter:向下移动一行
  - q:退出


#### wc 

- 统计文件中的字符数、单词数和行数
- 若不给出文件名，则从标准输入中读取
- 选项，若不加选项则会列出字符数、单词数和行数。格式为：**行数 单词数 字符数 文件名**
  - -c(char):显示字符数
  - -l:显示行数
  - -w:显示单词数

#### ls 

- 不带任何选项的ls命令只列出文件名
- 选项
  - -a:列出所有文件，包含.开头的隐藏文件
  - -l：长格式列出文件，格式为：文件类型 操作权限 链接数 属主名 属组名 字节数 最近修改时间 文件名。其中文件类型包括：
    - d：目录文件
    - -：普通文件
    - l(link)：符号链接文件
    - b(byte)：块设备文件
    - c(char)：字符设备文件
  - -d：显示**目录名而不现实文件**
  - -R(recursion)：递归列出子目录
  - -r(reverse)：逆序显示文件名列表
  - -x：显示时以字母顺序，正常是按照ASCII码顺序
  - --color：着色显示(/etc/DIR_COLORS可以修改颜色)
    - 绿色：可执行文件
    - 蓝色：目录
    - 红色：压缩文件
    - 浅蓝色：链接文件
    - 灰色：一般文件

#### touch

- 以当前时间创建文件或更新已有文件的时间戳
- 时间格式为[YYYY] [MMDDhhmm]
- 选项为-t

#### cp src_file dst_file

- 若目标文件名已存在，则会**覆盖目标文件**
- 如果目的文件是一个目录，那么将源文件拷贝到目录下
- 拷贝多个文件，则最后一个参数是**目标目录**
- 选项
  - -i：在覆盖文件前提示用户
  - -R/r：递归复制目录

> ​		可以试一下 -f 选项，-f 一般表示强制执行（force）：cp -f file dir
> ​		但好像结果并不像我们希望的那样，系统依然会有覆盖提示。为什么呢？
> ​		原因很简单，系统将 **cp 命令alias为 cp -i**。当我们执行cp命令的时候，系统往往执行的是cp -i，-i 选项表示有交互的提示信息，所以执行 cp -f 的时候，**系统实际执行的是   cp -i -f**， 所以仍然会有覆盖提示。
> 　　想要执行原始的cp也很简单，可以在**调用cp的时候加入绝对路径**，当然还可以直接执行下面的语句：**\cp -f file dir**

#### mv

- 对文件进行名称更改或路径迁移

  ```shell
  # 把文件aaa改名为bbb
  $mv aaa  bbb         
  # 把文件aaa移动到/home/paul下
  $mv aaa /home/paul  
  # 将version1改名为proposal，并提示用户确认。
  $mv -i version1 proposal 
  # 把当前目录下的file1文件移动到当前目录的父目录下
  $mv file1 .. 
  # 另一种文件重命名的方式
  $mv file1  ../new-filename
  
  
  ```

  

- 选项
  - -f：强制执行
  - -i：提示覆盖信息

#### rm

- 选项
  - -f
  - -r
  - -i

#### rmdir

- 删除空目录
- 对该目录的**父目录文件必须有写权限**
- 被删除的目录必须是**空目录**，否则只能考虑-p
- **比起rm -rf来，rmdir是更安全的操作**
- 选项
  - -p：由指定目录的最底层开始，**逐层尝试删除空目录**，当碰到非空目录时便停止删除的动作。

#### mkdir

- 创建新目录时必须对其**父目录文件有写权限**

- 选项
  - -p(parent)：自动建立父目录
  - -m(mode)：建立指定权限的目录

#### whereis

- 显示指令的二进制码、原始码与在线手册说明文件的存放目录
- 选项
  - -b：只查找二进制
  - -m：只查找在线手册
  - -s：只查找原始码文件
- whereis找不到某个文件的部分原因可能是这个文件没有存在于任何whereis命令搜索的子目录中
- whereis命令检索的子目录是固定编写在它的程序中的

#### locate

- 使用的是一个文件名数据库
- 查找文件位置又比whereis命令速度更快
- 数据库的更新是**每星期执行一次**,可执行 updatedb 手工更新数据库

#### ln

- **一个物理文件可以有多个文件名**

- ln用于对一个已经存在的文件再创建一个新的链接，而不复制文件的内容

- ln后的链接文件名与物理文件**具有相同的权限**

- 格式： ln [-s] target [link name]

  - -s(soft)：符号链接。不加此选项代表硬连接

  - Target:链接所对应的源文件 

  - Link name：链接文件名。**如果是符号链接，也可以是目录名** 

- ls –l 命令可列出一个文件拥有的硬链接数。


#### cd

- cd/cd ～：返回到HOME目录下

## 权限管理

### 用户类型

- 文件所有者：能够设定同组用户和其他用户对该文件的访问权限。一般来说是文件的创建者。
- 同组用户：具有相同性质的所有用户,被系统管理员分在同一组。**文件所有者或系统管理员**可将文件的权限赋予组内的其它用户。
- 其他用户：文件所有者或系统管理员还可以将文件的访问权赋予系统中所有其它的用户。这 样,系统中每一位用户可能都能访问你的某一文件或目录。

### 表示方法

#### 用户的表示

- 所有者u(user)
- 同组用户g(group)
- 其他用户o(other)
- 所有用户a(all)

#### 权限的表示

- 三组分别表示文件所有者、同组用户和其他用户的权限

  | rwx  | 7    | 4+2+1 | 读、写、执行     |
  | ---- | ---- | ----- | ---------------- |
  | rw-  | 6    | 4+2+0 | 读、写           |
  | r-x  | 5    | 4+1   | 读、执行         |
  | r--  | 4    | 4+0+0 | 只读             |
  | -wx  | 3    | 2+1   | 写、执行         |
  | -w-  | 2    | 0+2+0 | 只写             |
  | ---  | 0    | 0+0+0 | 禁止读、写、执行 |

### 权限控制实例

- 在移动文件时不需要被移动文件的权限，但需其**所在目录具有写和执行权限**
- 在目录下**增删文件、子目录**时要有目录的写权限（touch,rm,mkdir,rmdir）
- 用ls列目录要有**目录的读权限**(这里只读了目录的文件名列表而不涉及到i-node)
- **进入目录或将该目录作路径分量**时(cd)要有目录的**执行权限**，故要**使用任一个文件，必须有该文件及找到该文件的路径上所有目录分量的执行权限。**
- 只有执行权限只能进入目录，不能看到目录下的内容，要想**看到目录下的文件名和目录名，需要可读权限**
- 一个文件能不能被删除，主要看该**文件所在的目录对用户是否具有写权限，**如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外 
- 仅当要打开一个文件时，即执行**涉及到文件内容的操作**时，才需要文件的许可。

### 相关指令

#### chmod

```shell
$ chmod [-options] xyz [filelist]
$ chmod [-options] u/g/o/a  +/-/=  r/w/x  [filelist]
-c（check）：只有在文件权限确实改变时才进行详细说明；
-f（force）：不打印“权限不能改变”之类的文件错误信息；
-R：递归改变目录及其内容的权限；
-v：详细说明权限的变化。
```

- 用户修改密码，是通过运行命令passwd来实现的，最终必须要修改/etc/passwd文件，而passwd的文件只对于root用户是可写的，而对于所有的他用户来说都是没有写权限的。

#### chown

- 用于改变文件的所有者,可以同时也改变其所属用户组 $chmod user:usergroup file
- 仅用于**系统管理员**对文件和用户的管理

```shell
$ chown [-options] user[：group] filelist 
 -R：递归改变目录及其内容的所属用户或用户组；
```

#### su

#### sudo

## 进程管理

- 进程是程序的执行的过程，是**执行的程序**

- 程序是静态的，是保存在磁盘上的**可执行代码和数据**的集合；

  进程是动态的，是Linux系统的基本调度单位

- PID(Process Identity number)：一个PID唯一的标识一个进程。 

  PPID(Parent Process ID)：进程的父进程号。

### init进程

- 内核启动后的第一个进程，其PID=1

- 扮演**终结父进程**的角色，所有进程追溯其祖先最终都会落到init进程身上。

- 因为init进程永远不会被终止，所以系统总是可以确信它的存在，并在必要的时候以它为参照。如果某个进程在它衍生出来的全部子进程结束之前被终止，此时那些**失去了父进程的子进程就都会以init作为它们的父进程**。

### 启动方式

- 手工启动：当时设置当时启动

  - 前台启动:启动一个进程后，如果不中断或挂起该进程，用户会**一直被禁止与 Shell 进行交互**，直至该进程执行结束。经常用于一般Linux命令的执行，和一些不太耗时的进程的启动。  

    停止: <Ctrl+c> 挂起：<Ctrl+z>

  - 后台启动:启动进程后，用户仍可以与Shell进行交互。可用于一些耗时长的作业运行。

    启动：$command &，附一个**&**

    终止和挂起后台进程：**使用kill命令**

- 调度启动：用户可事先进行设置安排，指定任务运行的时间或场合，到时候由系统自动启动进程完成此项任务。

### 进程的挂起和恢复

#### 进程挂起

-  前台进程的挂起：
       <Ctrl+z> 
-  后台进程的挂起：
       kill –s 01 {PID|%job ID}

#### 进程恢复

- 恢复到前台：
      fg %jobID
- 恢复到后台：
      bg %jobID

### 相关指令

#### ps

- 确定有哪些进程正在运行以及运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。

- 是一个**静态列表**，显示启动这个命令时正在运行的进程的快照

- 不跟任何选项表示查看系统中**属于自己的进程**

- 选项
  - -e：显示**所有**进程
  - -f(full)：全格式
  - -l：长格式
  - -w：宽格式
  - -a：显示**所有用户**的进程
  - -u：用户格式，显示用户名和进程起止世间
  - -x：显示与终端无关的所有进程
  
  ![image-20211214202306806](https://tva1.sinaimg.cn/large/008i3skNly1gxdmr2rijjj310u0ikwif.jpg)

> Linux下显示系统进程的命令ps，最常用的有**ps -ef 和ps aux** (请不要使用ps -aux) 这两个到底有什么区别呢？
>
> 显然，没太大差别。
>
> 讨论这个问题，要追溯到Unix系统中的两种风格，System Ｖ风格和BSD 风格，ps aux最初用到Unix Style中，而ps -ef被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。



> linux上进程有5种状态: 
>
>   1. 运行(正在运行或在运行队列中等待)
>
>   2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
>
>   3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
>
>   4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
>
>   5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 
>
> ps工具标识进程的5种状态码: 
>   1. D 不可中断 uninterruptible sleep **(usually IO)** 
>      
>   1. R 运行 runnable (on run queue)
>      
>   1.  S 中断 sleeping 
>      
>   1. T 停止 **traced or stopped** 
>      
>   1. Z 僵死 a defunct ("zombie") process 
>      
>  注: 其它状态还包括W(无驻留页), <(高优先级进程), N(低优先级进程), L(内存锁页). 



#### top

- 显示的是可根据真实情况 , 定时更新的运行进程列表
- 与终端设备进行交互，根据用户从终端输入的交互命令来显示或管理进程
- 交互命令（**注意到排序的指令都是大写**）
  - [Space] 立即刷新显示
  - d     设置刷新进程的时间间隔，你会被提示输入一个数（秒）
  - q     **退出top命令**。
  - k     **杀死某进程。你会被提示输入进程 ID 以及要发送给它的信号**。       
  - h     显示帮助屏幕
  - n     显示的进程数量。你会被提示输入数量。
  - u     选择用户。
  - M     **按内存用量排序**。
  - P     **按 CPU 用量排序**。
- top命令的功能强于ps，但需要长久占用前台，所以用户应该根据自己的情况来使用这个命令。

```shell
# [例] 键入top命令查看系统状况
$ top
# 当前时间、系统启动时间、当前系统登录用户数目、平均负载。
1：55pm up 7 min， 4 user， load average:0.07，0.09，0.06
# 进程情况，依次为进程总数、休眠进程数、运行进程数、僵死进程数、终止进程数。
29 processes:28 sleeping， 1 running， 0 zombie， 0 stopped
# CPU状态，依次为用户占用、系统占用、优先进程占用、闲置进程占用。
CPU states: 4.5% user， 3.6% system， 0.0% nice， 91.9%
# 内存状态，依次为平均可用内存、已用内存、空闲内存、共享内存、缓存使用内存。
idle
Mem: 38916K av， 18564K used， 20352K free， 11660K shrd， 1220K buff
# 交换状态，依次为平均可用交换容量、已用容量、闲置容量、高速缓存容量
Swap: 33228K av， 0K used， 33228K free， 11820K cached
# 下面就是和ps相仿的各进程情况列表
---------------------------------------------------------------
PID USER PRI NI SIZE RSS SHARE STAT LIB %CPU %MEM TIME 
COMMAND
363 root 14 0 708 708 552 R 0 8.1 1.8 0:00 top
1 root 0 0 404 404 344 S 0 0.0 1.0 0:03 init
2 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 kflushd
3 root -12 -12 0 0 0 SW< 0 0.0 0.0 0:00 kswapd
4 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 md_thread
5 root 0 0 0 0 0 SW 0 0.0 0.0 0:00 md_thread
312 root 1 0 636 636 488 S 0 0.0 1.6 0:00 telnet
285 root 6 0 1140 1140 804 S 0 0.0 2.9 0.00 bash
286 root 0 0 1048 1048 792 S 0 0.0 2.6 0.00 bash
25 root 0 0 364 364 312 S 0 0.0 0.9 0.00 kerneld
153 root 0 0 456 456 372 S 0 0.0 1.1 0.00 syslogd
160 root 0 0 552 552 344 S 0 0.0 1.4 0.00 klogd
169 daemon 0 0 416 416 340 S 0 0.0 1.0 0.00 atd
178 root 2 0 496 496 412 S 0 0.0 1.2 0.00 crond
187 bin 0 0 352 352 284 S 0 0.0 0.9 0.00 portmap
232 root 0 0 500 500 412 S 0 0.0 1.2 0.00 rpc.mountd
206 root 0 0 412 412 344 S 0 0.0 1.0 0.00 inetd
215 root 0 0 436 436 360 S 0 0.0 1.1 0.00 icmplog
```



> 什么是系统平均负载(Load average)？ 在Linux系统中，uptime、w、top等命令都会有系统平均负载load average的输出，那么什么是系统平均负载呢？ 
>
> 系统平均负载被定义为在**特定时间间隔内运行队列中的平均进程数**。如果一个进程满足以下条件则其就会位于运行队列中： 
>
> - 它没有在等待I/O操作的结果 
> - 它没有主动进入等待状态(也就是没有调用'wait') 
> - 没有被停止(例如：等待终止) 
>
> 例如： 
> [root@opendigest root]# uptime 
> 7:51pm up 2 days, 5:43, 2 users, load average: 8.13, 5.90, 4.94 
>
> 命令输出的最后内容表示在过去的1、5、15分钟内运行队列中的平均进程数量。 
> 一般来说只要**每个CPU的当前活动（指一分钟内）进程数不大于3那么系统的性能就是良好**的，如果每个**CPU的任务数大于5，那么就表示这台机器的性能有严重问题**。对于上面的例子来说，假设系统有两个CPU，那么其每个CPU的当前任务数为：8.13/2=4.065。这表示该系统的性能是可以接受的。

#### jobs

- 用于显示和控制后台正在执行的和被挂起的任务序列。
- 选项
  - -l：**显示后台任务的进程号与信息**。 
  - -p：**只显示后台任务的 PID**。 
  - -n（new）：显示上次通知用户后，执行状态有更动的后台任务状态。 
  - -r：显示执行中的后台任务。
  - -s：显示暂停执行的后台任务。

> +号和-号
>
> 带有**加号的作业被视为默认作业**，如果命令行没有指定作业编号，则它应该是任何作业控制命令引用的作业。带有减号的作业是下一个默认作业。**一次只有一个作业带有加号,一个作业带有减号**

#### kill

- 向正在进行的进程发送信号，进程接收到信号后进行信号对应的相应操作

- 格式

  kill [-option] [signal] {PID | %job ID}

  -  signal - 信号。与-s配合使用。不指定则送出信号 15(TERM）
  - pid - 要终止的进程号
  - job ID - 要终止的进程对应的后台任务编号。

- 常用信号

  - 信号15（SIGTERM）
    - 终止进程运行
    - 为kill命令的缺省信号
    - 经常用于**后台进程的终止**
    - 当某个进程占用的CPU时间过多，或是某进程已经挂起，可以用这种方法终止其执行
    - 除root用户外，**一般用户只能终止属于自己的进程**
  - 信号09(SIGKILL)
    - **强制**终止进程
  - 信号01(SIGHUP)（ctrl+Z）
  - 信号02(SIGINT)

#### nohub

- 用于在用户退出系统时，继续执行程序
- 格式：nohub {command|script} &



## Vi编辑器

#### 启动命令

- 基本语法：  vi [-options] [+n] [file]
- 常用选项：
  - -r  恢复系统突然崩溃时正在编辑的文件。
  - -R  以只读方式打开文件
  - +[n]  指明进入vi后直接位于文件的第n行，如果只有“+”而不指定n，则**光标位于文本的最后一行**

#### 搜索命令

- 正向搜索（/）：从光标所在位置起向文件末尾方向搜索。
- 反向搜索（?）：从光标所在位置起向文件开头方向搜索。
- 搜索得到结果后，可以使用重复命令n或N沿着相同或相反的方向重复上一次的搜索

## Shell

### Shell的启动和退出

```shell
$shellname
$exit
```

### 环境变量和变量

- 环境变量的值只能传递给子进程，而不能传递给它所在的父进程

```shell
# 定义变量
$ var=value
$ {var=value}
# 清除变量
$ unset var
# 显示所有shell环境变量
$ set
# 显示所有当前用户的用户环境变量
$ env
```

#### 环境变量分类

- 本地环境变量

  - 只能在当前shell中使用，不能传递给该shell创建的任何子进程

  - 这个值只在用户当前Shell生命期有意义

- 全局环境变量

  - 可以用于所有进程，原则上均为**大写**
  - 但赋值后必须将变量值导出，否则无法传递给子进程
  - 子进程不会自动地继承父进程中本地的变量

#### 设置环境变量

- 修改文件设置
  - /etc/profile：存放系统管理员设置的环境变量
  - ~/.bash profile：用于增加新变量或覆盖/etc/profile中设置的变量，**每次登录时都会被初始化**
- 命令行设置
  - 显式赋值：var=value。**等号两边不能直接接单独的空格。**
  - read读取：read var1 var2 。若读入个数多于变量，则多出的都赋给最后一个变量；若少，则后面的变量赋空。

#### Shell内嵌变量

- HOME：用户主目录的完全路径名

- LOGNAME：登录用户名

- PS1：主提示符。对root用户是#，普通用户是$

- PATH：path1:path2:path3:

  添加新的PATH：\$PATH=$PATH:filelist\\\$export PATH

### 引号

#### 双引号

- 由双引号括起来的字符，除下面几种符号具有其特殊功能外，其余字符都作为普通字符对待
  - $符号：用其后指定的变量值来代替这个变量
  - \ 符号：它是**转义字符**，它告诉Shell不要对其后面的特殊字符($、\和引号)进行特殊处理，只当做普通字符即可
  - 引号

#### 单引号

- 单引号括起来的所有字符都作为普通字符出现
- 特殊字符用单引号括起来后，也会失去原有意义，而只作为普通字符解释

#### 反引号

- 内层嵌套的反引号要使用反斜线**将其转义**
- 反引号括起来的内容被Shell解释为命令行

### 通配符和正则表达式(Regular Expression)

- 通配符
  - ***** ：可以匹配文件名中的任何字符串
  - **？**：可以匹配文件名中的任何**单个字符**
  - **[…]** ：匹配方括号[ ]中指定范围内的字符，可以**使用-来连接两个字母或数字，以表示范围**
  - **[!...]** ：匹配不在指定范围内的任何字符
- 正则
  - ^：只匹配行首，用在字符串前面
  - $：只匹配行尾，用在字符串后面
  - X*：0个或多个字符X
  - .：只匹配任意单字符
  - [字符表]：字符表中的任意字符
  - [^字符表]：不在字符表中的任意字符
  - \：屏蔽其后的特殊字符的特殊含义
  - \\{n\\}：前导的正则表达式重复n次
  - \\{min, max\\}：前导的正则表达式重复min~max次

### 变量参数

- 位置变量参数 $0, \$1,···

  - Shell在解释用户命令时,将把**命令行的第一个字**作为命令,而其它字作为参数通过位置变量传递给程序

  - \$1-\$9是第一到九个参数，**第九个**以后的参数都不会被访问

  - 位置变量$0指命令对应的可执行名

- 特定变量参数

  - $#：传递到脚本的参数个数
  - $?：**最后一个程序或命令的执行状态**。用数字表示：0表示执行没有错误，其他任何值表明有错误
  - $*：所有参数
  - $$：**脚本运行的当前Shell的PID**
  - $@：所有参数，每个参数用双引号引起

### 标准文件和文件描述符

- 在Shell中执行命令的时候，**每个进程都和三个打开的文件相联系**，并使用文件描述符来引用这些文件。
  　      文件      　　　    文件描述符
- 输入文件 —　标准输入 – stdin	     0
- 输出文件 —　标准输出 – stdout	     1
- 错误输出文件 —标准错误输出 – stderr     2

### 重定向和管道

- 由于大多数命令都以参数的形式在命令行上指定输入档的文件名，所以输入重定向并不经常使用。尽管如此，当要使用一个不接受档名作为输入参数的命令，而需要的输入内容又存在一个文档里时，就能用输入重定向解决问题。 
- 重定向：<、>，追加：<<、>>

- 错误重定向：2 > errfile/2 > /dev/null

```shell
# 标准输入与标准错误输出
$cat filea fileb
# 标准输出
->This is output from filea.
# 标准错误输出
->cat: cannot open fileb

```

- 再举个例子

  ```shell
  Command > outfile  2> errfile  <  infile
  # 以infile为标准输入，将标准输出送到outfile,标准错误输出送到errfile. 
  Command >> outfile  2>> errfile  < infile
  # 以infile为标准输入，将标准输出追加到outfile,标准错误输出追加到errfile. 
  
  ```

- 将stdout和stderr同时重定向到outfile：\$Command > outfile  **2>&1**

> https://www.jianshu.com/p/d5ea4a8acfb9

- 管道是把一个命令在**屏幕上的输出**传递给另一个命令作为输入。用竖杠|表示。

### 算术扩展

- \$((expression))，有\$符号

- 运算符源于C

- 算术扩展中包含的只有变量、运算符和常数，所以变量不需要\$引用

- 算术扩展内空格可以随意使用

- 表达式内的变量若未定义，则当作其值为0

  ```shell
  # 判断真假
  $i=2 ; echo $((  i==2 ))    
  # 变量赋值
  $ result= $(( i>=0 &&i<=3))
  ```

  

### 各种操作符号

- 命令组

  多个命令在一行输入时，用 “;”作为命令间分隔符。

### 常用指令

#### exit

- 正常退出返回0

- 如果直接在终端上执行exit命令，会导致从系统注销，因为它会终止登陆Shell的执行。

#### \$\$和||

- 注意这个运算符也是短路的，只有前者为真后者才会进行or前者失败才执行后者
- 注意这个是对于两个命令，而不是逻辑判断

#### test

- 用于测试一种或几种条件

- 格式

  Test expression

  [ expression ]：要注意在**条件两边加上空格**。涉及到变量值（$variable）的比较时最好把**变量取值用双引号括起来**，以免Shell误解变量值。

##### 字符串操作符

```shell
# 相等
$test string1 = string2
# 不等
$test string1 != string2
# 非空
$test string 
```

- 等号和不等号操作符两边必须有空格
- 在长度和内容上判断两个字符串相等

##### 整数操作符

```sh
# 相等
$test int1 -eq int2
# 不等
$test int1 -ne int2
# 小于
$test int1 -lt int2
# 大于
$test int1 -gt int2
# 小于等于
$test int1 -le int2
# 大于等于
$test int1 -ge int2
```

##### 文件操作符

- -e(exist)：文件存在
- -d(directory)
- -f
- -s：文件大小不为0
- -r：及以下两个都需要有**文件所有者**的权限
- -w
- -x

##### 逻辑操作符

- -a(and)：与
- -o(or)：或
- !：非

#### expr

- 表达式的各部分(操作数和运算符之间)必须以空格分隔。

- 表达式中某些对shell有特殊意义的字符必须转义。

- \*需要进行转义\\\*

  ```shell
  # 多个算术表达式可以组合在一起
  $expr 5 + 7 / 3
  # 使用反引号改变计算次序
  $expr `$expr 5 + 7` / 3
  #expr命令一般用于整数值，此外，还可用于字符串测试
  $s1=“hello”
  $expr  $s1 = “hello”
  ```

#### grep(global regular expression print)

- 允许对文本文件的内容进行模式查找。如果找到匹配模式，**grep显示包含该模式的所有行**
- 在g r e p命令中输入字符串参数时，最好将其用双引号括起来。在调用模**式匹配时，应使用单引号**
- 选项
  - -c(count)：只输出计数
  - -n：显示匹配行及行号
  - -v：显示不包含匹配文本的所有行

#### find

- 格式：find path expression [-exec -ok] [command]

- 所查找的目录路径，对**目录的搜索是递归**的。.表示当前目录，/表示根目录

- -exec command：find命令对匹配的文件执行该参数所给出的Shell命令command

  -exec后的命令形式：command {} \; 注意{ }和\；之间的空格。

- -ok command：和-exec的作用相同，只是在执行每一个命令之前，**都会给出提示**，让用户来确定是否执行。如果用户不回应 'y' 或 'Y'，command 将不予以执行，并回应 false。 

- expression的名称标准：

  - -name file：寻找名为file的文件，要找的文件名包括**在引号中**,可以使用通配符。
  - -user name：按照**文件属主**来查找文件
  - -group name
  - -type type：查找某一类型的文件(b、c、d、f、l)
  - -size n[c]：查找文件长度为n块(block)的文件，带有c时表示文件长度以字节计。
  - 时间标准 -mtime n：-n表示在n天以内，n/+n表示在n天以上

### 运行Shell脚本

- sh：这种运行方式是启动了一个子Shell,set_dir 文件中的Shell命令都是在子Shell中执行, **Shell命令执行完后，退回到命令提示符下**时，子Shell结束
- .(source)：
- 赋予执行权限：这种执行方式，Shell首先查找 **PATH 变量中的各路径中是否有相应程序**，若没有则会出错。因而需要在**PATH变量中添加脚本所在的路径**。这种方式也是在子Shell中执行脚本
  - 用户必须对该文件具有读权限和执行权限
  - 开放执行权限：\$chmod +x set_dir
  - 执行：\$set_dir

